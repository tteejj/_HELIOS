####\modules\dialog-system.psm1
#
# MODULE: modules/dialog-system.psm1
#
# PURPOSE:
#   Manages the creation, display, and interaction of modal dialogs. This system
#   constructs dialogs using Helios components and intercepts all user input
#   while a dialog is active, ensuring a modal experience.
#
# ARCHITECTURE:
#   - This module maintains a private state object, $DialogSystem, which holds a
#     stack of active dialogs.
#   - Public functions like `Show-ConfirmDialog` and `Show-AlertDialog` act as
#     factories, composing Helios panels and components to build the dialog UI.
#   - When a dialog is shown, this system takes control of focus, managing a
#     temporary tab order for the dialog's components. It restores the previous
#     focus state when the dialog is closed.
#   - The TUI Engine interacts with this module via two hooks:
#     - `Get-ActiveDialog()`: To get the dialog's root panel for rendering.
#     - `Handle-DialogInput()`: To pass keyboard input for processing.
#

using module "$PSScriptRoot/logger.psm1"
using module "$PSScriptRoot/exceptions.psm1"
using module "$PSScriptRoot/../ui/helios-components.psm1"
using module "$PSScriptRoot/../ui/helios-panels.psm1"
using module "$PSScriptRoot/focus-manager.psm1" # For Get-FocusedComponent, Request-Focus

#region Private State
# ------------------------------------------------------------------------------
# Private state for the Dialog System.
# ------------------------------------------------------------------------------

$DialogSystem = [PSCustomObject]@{
    # A stack to manage nested dialogs.
    DialogStack = [System.Collections.Stack]::new()

    # The root panel of the currently visible dialog.
    CurrentDialog = $null

    # The component that was focused on the main screen before the dialog appeared.
    PreviousFocusedComponent = $null

    # A temporary, ordered list of focusable components within the active dialog.
    DialogTabOrder = [System.Collections.Generic.List[object]]::new()
}
#endregion

#region Private Functions
# ------------------------------------------------------------------------------
# Internal helper functions for managing dialog state and focus.
# ------------------------------------------------------------------------------

function Find-DialogFocusableComponents {
    param(
        [Parameter(Mandatory = $true)]
        [PSCustomObject]$RootComponent
    )
    # This is a local reimplementation of the same logic in focus-manager.psm1,
    # specifically for traversing a dialog's component tree.
    $focusable = [System.Collections.Generic.List[object]]::new()
    $queue = [System.Collections.Generic.Queue[object]]::new()
    $queue.Enqueue($RootComponent)

    while ($queue.Count -gt 0) {
        $current = $queue.Dequeue()
        if (-not $current) { continue }

        if ($current.PSObject.Properties['IsFocusable'] -and $current.IsFocusable -and $current.PSObject.Properties['Visible'] -and $current.Visible) {
            $focusable.Add($current)
        }

        if ($current.PSObject.Properties['Children']) {
            foreach ($child in $current.Children) {
                $queue.Enqueue($child)
            }
        }
    }
    return $focusable
}

function Show-ActiveDialog {
    param(
        [Parameter(Mandatory = $true)]
        [PSCustomObject]$DialogPanel
    )

    Invoke-WithErrorHandling -Component 'DialogSystem.ShowActiveDialog' -Context @{ DialogType = $DialogPanel.Name } -ScriptBlock {
        Write-Log -Level Debug -Message "Showing dialog '$($DialogPanel.Name)'"

        # If another dialog is already active, push it onto the stack.
        if ($DialogSystem.CurrentDialog) {
            $DialogSystem.DialogStack.Push($DialogSystem.CurrentDialog)
        }
        else {
            # This is the first dialog being shown, save the screen's focus state.
            $DialogSystem.PreviousFocusedComponent = Get-FocusedComponent
        }

        # Take over focus from the main screen.
        Request-Focus -Component $null -Reason 'DialogShown'

        $DialogSystem.CurrentDialog = $DialogPanel

        # Build the tab order for the new dialog.
        $DialogSystem.DialogTabOrder.Clear()
        $focusableComponents = Find-DialogFocusableComponents -RootComponent $DialogPanel
        $DialogSystem.DialogTabOrder.AddRange($focusableComponents)
        Write-Log -Level Trace -Message "Dialog has $($DialogSystem.DialogTabOrder.Count) focusable components."

        # Focus the first component in the dialog.
        if ($DialogSystem.DialogTabOrder.Count -gt 0) {
            Request-Focus -Component $DialogSystem.DialogTabOrder[0] -Reason 'DialogInitialFocus'
        }

        # The TUI Engine needs to be told to redraw.
        Request-TuiRefresh
    }
}

function Close-ActiveDialog {
    Invoke-WithErrorHandling -Component 'DialogSystem.CloseActiveDialog' -Context @{} -ScriptBlock {
        Write-Log -Level Debug -Message "Closing active dialog."
        $closedDialog = $DialogSystem.CurrentDialog

        # Blur whatever was focused in the dialog.
        Request-Focus -Component $null -Reason 'DialogClosed'
        $DialogSystem.DialogTabOrder.Clear()

        if ($DialogSystem.DialogStack.Count -gt 0) {
            # There's another dialog on the stack, so show it instead.
            $nextDialog = $DialogSystem.DialogStack.Pop()
            Show-ActiveDialog -DialogPanel $nextDialog
        }
        else {
            # No more dialogs, return control to the main screen.
            $DialogSystem.CurrentDialog = $null
            Write-Log -Level Debug -Message "Dialog stack is empty. Restoring screen focus."

            # Restore focus to the component that was active before the first dialog appeared.
            if ($DialogSystem.PreviousFocusedComponent) {
                Request-Focus -Component $DialogSystem.PreviousFocusedComponent -Reason 'RestoreScreenFocus'
                $DialogSystem.PreviousFocusedComponent = $null
            }
            Request-TuiRefresh
        }
    }
}

#endregion

#region Public API - Dialog Factories
# ------------------------------------------------------------------------------
# Exported functions to create and show standard dialog types.
# ------------------------------------------------------------------------------

function Show-ConfirmDialog {
    <#
    .SYNOPSIS
        Displays a modal confirmation dialog with 'Yes' and 'No' buttons.
    .PARAMETER Title
        The title to display in the dialog's border.
    .PARAMETER Message
        The confirmation message to display to the user.
    .PARAMETER OnConfirm
        A scriptblock to execute when the 'Yes' button is clicked.
    .PARAMETER OnCancel
        A scriptblock to execute when the 'No' button is clicked or Esc is pressed.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$Title,

        [Parameter(Mandatory = $true)]
        [string]$Message,

        [Parameter(Mandatory = $true)]
        [scriptblock]$OnConfirm,

        [scriptblock]$OnCancel = { }
    )

    Invoke-WithErrorHandling -Component 'DialogSystem.ShowConfirmDialog' -Context @{ Title = $Title; Message = $Message } -ScriptBlock {
        # Define actions for the buttons. They must close the dialog first.
        $onYesClick = {
            Close-ActiveDialog
            & $OnConfirm
        }
        $onNoClick = {
            Close-ActiveDialog
            & $OnCancel
        }

        # Create UI components
        $messageLabel = New-HeliosLabel -Props @{
            Text   = $Message
            Width  = 50 # Let the panel manage this
            Height = 1
        }

        $yesButton = New-HeliosButton -Props @{
            Name    = 'ConfirmDialogYesButton'
            Text    = 'Yes'
            Width   = 7
            OnClick = $onYesClick
        }

        $noButton = New-HeliosButton -Props @{
            Name    = 'ConfirmDialogNoButton'
            Text    = 'No'
            Width   = 6
            OnClick = $onNoClick
        }

        $buttonPanel = New-HeliosStackPanel -Props @{
            Name                = 'ConfirmDialogButtonPanel'
            Orientation         = 'Horizontal'
            Spacing             = 2
            HorizontalAlignment = 'Center'
            Height              = 3
        }
        $buttonPanel.AddChild($yesButton)
        $buttonPanel.AddChild($noButton)

        $dialogPanel = New-HeliosStackPanel -Props @{
            Name       = 'ConfirmDialogPanel'
            Width      = 60
            Height     = 10
            ShowBorder = $true
            Title      = " $Title "
            Padding    = 1
            Spacing    = 2
        }
        $dialogPanel.AddChild($messageLabel)
        $dialogPanel.AddChild($buttonPanel)

        # Show the composed dialog
        Show-ActiveDialog -DialogPanel $dialogPanel
    }
}

function Show-AlertDialog {
    <#
    .SYNOPSIS
        Displays a modal alert dialog with a single 'OK' button.
    .PARAMETER Title
        The title to display in the dialog's border.
    .PARAMETER Message
        The alert message to display to the user.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$Title,

        [Parameter(Mandatory = $true)]
        [string]$Message
    )
    Invoke-WithErrorHandling -Component 'DialogSystem.ShowAlertDialog' -Context @{ Title = $Title; Message = $Message } -ScriptBlock {
        # The OK button simply closes the dialog.
        $onOkClick = { Close-ActiveDialog }

        # Create UI components
        $messageLabel = New-HeliosLabel -Props @{
            Text = $Message
        }

        $okButton = New-HeliosButton -Props @{
            Name    = 'AlertDialogOkButton'
            Text    = 'OK'
            Width   = 6
            OnClick = $onOkClick
        }

        $buttonPanel = New-HeliosStackPanel -Props @{
            Name                = 'AlertDialogButtonPanel'
            Orientation         = 'Horizontal'
            HorizontalAlignment = 'Center'
            Height              = 3
        }
        $buttonPanel.AddChild($okButton)

        $dialogPanel = New-HeliosStackPanel -Props @{
            Name       = 'AlertDialogPanel'
            Width      = 60
            Height     = 10
            ShowBorder = $true
            Title      = " $Title "
            Padding    = 1
            Spacing    = 2
        }
        $dialogPanel.AddChild($messageLabel)
        $dialogPanel.AddChild($buttonPanel)

        # Show the composed dialog
        Show-ActiveDialog -DialogPanel $dialogPanel
    }
}
#endregion

#region Engine Hooks
# ------------------------------------------------------------------------------
# Functions for the TUI Engine to call during its main loop.
# ------------------------------------------------------------------------------

function Get-ActiveDialog {
    <#
    .SYNOPSIS
        (Engine Hook) Gets the root component of the currently active dialog.
    .DESCRIPTION
        The TUI Engine calls this during each render pass. If a dialog is active,
        the engine will render its component tree on top of the current screen.
    .OUTPUTS
        [PSCustomObject] The root panel of the active dialog, or $null if none.
    #>
    [CmdletBinding()]
    [OutputType([PSCustomObject])]
    param()

    return $DialogSystem.CurrentDialog
}

function Handle-DialogInput {
    <#
    .SYNOPSIS
        (Engine Hook) Processes keyboard input if a dialog is active.
    .DESCRIPTION
        The TUI Engine calls this at the beginning of its input handling logic.
        If a dialog is active, this function consumes the input, handles focus
        navigation (Tab/Shift+Tab), and dispatches the key to the focused
        component within the dialog.
    .PARAMETER Key
        The [ConsoleKeyInfo] object representing the key press.
    .OUTPUTS
        [bool] Returns $true if the input was handled (i.e., a dialog was active),
               otherwise $false.
    #>
    [CmdletBinding()]
    [OutputType([bool])]
    param(
        [Parameter(Mandatory = $true)]
        [System.Management.Automation.Host.KeyInfo]$Key
    )

    if (-not $DialogSystem.CurrentDialog) {
        return $false
    }

    Invoke-WithErrorHandling -Component 'DialogSystem.HandleDialogInput' -Context @{ Key = $Key.Key } -ScriptBlock {
        # Handle Tab navigation within the dialog
        if ($Key.Key -eq [ConsoleKey]::Tab) {
            $tabOrder = $DialogSystem.DialogTabOrder
            if ($tabOrder.Count -gt 0) {
                $currentFocused = Get-FocusedComponent
                $currentIndex = if ($currentFocused) { $tabOrder.IndexOf($currentFocused) } else { -1 }

                $increment = if ($Key.Modifiers -band [ConsoleModifiers]::Shift) { -1 } else { 1 }
                $nextIndex = ($currentIndex + $increment + $tabOrder.Count) % $tabOrder.Count

                Request-Focus -Component $tabOrder[$nextIndex] -Reason 'DialogTabNavigation'
            }
            return # We handled it, so exit the scriptblock
        }

        # Dispatch input to the currently focused component within the dialog
        $focusedComponent = Get-FocusedComponent
        if ($focusedComponent -and $focusedComponent.PSObject.ScriptMethods['HandleInput']) {
            # If the component's HandleInput returns $true, it handled the key.
            if ($focusedComponent.HandleInput($Key)) {
                return
            }
        }
    }

    # Always return true to signify that the dialog system consumed the input,
    # preventing it from "leaking" to the underlying screen.
    return $true
}

#endregion

Export-ModuleMember -Function Show-ConfirmDialog, Show-AlertDialog, Get-ActiveDialog, Handle-DialogInput


####\modules\exceptions.psm1
#
# MODULE: exceptions.psm1
# PURPOSE: Provides custom exception types and a centralized error handling wrapper
# for the PMC Terminal application. This ensures all errors are consistently logged
# with rich contextual information.
#

# ------------------------------------------------------------------------------
# Module-Scoped State Variables
# ------------------------------------------------------------------------------

# A running history of the most recent errors encountered in the application.
$script:ErrorHistory = [System.Collections.Generic.List[object]]::new()
$script:MaxErrorHistory = 100 # Keep a reasonable number of recent errors.

# ------------------------------------------------------------------------------
# Custom Exception Type Definition
# ------------------------------------------------------------------------------

# Define custom exception types using C# via Add-Type. This provides strongly-typed
# exceptions that can be caught specifically throughout the application.
try {
    # Only add the type if it doesn't already exist to prevent errors on module re-import.
    if (-not ('Helios.HeliosException' -as [type])) {
        Add-Type -TypeDefinition @"
        using System;
        using System.Management.Automation;
        using System.Collections;

        namespace Helios {
            // Base exception for all custom application errors. Inherits from RuntimeException for better PowerShell integration.
            public class HeliosException : System.Management.Automation.RuntimeException {
                public Hashtable DetailedContext { get; set; }
                public string Component { get; set; }
                public DateTime Timestamp { get; set; }

                public HeliosException(string message, string component, Hashtable detailedContext, Exception innerException)
                    : base(message, innerException)
                {
                    this.Component = component ?? "Unknown";
                    this.DetailedContext = detailedContext ?? new Hashtable();
                    this.Timestamp = DateTime.Now;
                }
            }

            // Specific exception types for better categorization and targeted catch blocks.
            public class NavigationException : HeliosException { public NavigationException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class ServiceInitializationException : HeliosException { public ServiceInitializationException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class ComponentRenderException : HeliosException { public ComponentRenderException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class StateMutationException : HeliosException { public StateMutationException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class InputHandlingException : HeliosException { public InputHandlingException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class DataLoadException : HeliosException { public DataLoadException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
        }
"@ -ErrorAction Stop
        # This log message will only appear if the logger is already imported and the log level is appropriate.
        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            Write-Log -Level Debug -Message "Custom Helios exception types compiled successfully."
        }
    }
} catch {
    # If Add-Type fails, this is a critical environment issue. Log it prominently.
    # The application will fall back to using standard RuntimeExceptions.
    Write-Warning "CRITICAL: Failed to compile custom Helios exception types: $($_.Exception.Message). The application will lack detailed error information."
}


# ------------------------------------------------------------------------------
# Private Helper Functions
# ------------------------------------------------------------------------------

# Identifies the component/module where an error originated based on the call stack.
function _Identify-HeliosComponent {
    param(
        [System.Management.Automation.ErrorRecord]$ErrorRecord
    )
    try {
        $scriptName = $ErrorRecord.InvocationInfo.ScriptName
        if (-not $scriptName) {
            # Walk the call stack to find the first script file.
            $callStack = Get-PSCallStack
            foreach ($frame in $callStack) {
                if ($frame.ScriptName) {
                    $scriptName = $frame.ScriptName
                    break
                }
            }
        }

        if (-not $scriptName) { return "Interactive/Unknown" }

        $fileName = [System.IO.Path]::GetFileNameWithoutExtension($scriptName)

        # Map filenames to logical application components according to the new file structure.
        $componentMap = @{
            'tui-engine'        = 'TUI Engine'
            'navigation'        = 'Navigation Service'
            'keybindings'       = 'Keybinding Service'
            'task-service'      = 'Task Service'
            'helios-components' = 'Helios UI Components'
            'helios-panels'     = 'Helios UI Panels'
            'dashboard-screen'  = 'Dashboard Screen'
            'task-screen'       = 'Task Screen'
            'exceptions'        = 'Exception Module'
            'logger'            = 'Logger Module'
            'Start-PMCTerminal' = 'Application Entry'
        }

        foreach ($pattern in $componentMap.Keys) {
            if ($fileName -like "*$pattern*") {
                return $componentMap[$pattern]
            }
        }

        return "Unknown ($fileName)"

    } catch {
        return "Component Identification Failed"
    }
}

# Gathers extensive details about an error for logging and debugging.
function _Get-DetailedError {
    param(
        [System.Management.Automation.ErrorRecord]$ErrorRecord,
        [hashtable]$AdditionalContext = @{}
    )
    try {
        $errorInfo = [PSCustomObject]@{
            Timestamp         = Get-Date -Format "o"
            Summary           = $ErrorRecord.Exception.Message
            Type              = $ErrorRecord.Exception.GetType().FullName
            Category          = $ErrorRecord.CategoryInfo.Category.ToString()
            TargetObject      = $ErrorRecord.TargetObject
            ScriptName        = $ErrorRecord.InvocationInfo.ScriptName
            LineNumber        = $ErrorRecord.InvocationInfo.ScriptLineNumber
            Line              = $ErrorRecord.InvocationInfo.Line
            PositionMessage   = $ErrorRecord.InvocationInfo.PositionMessage
            StackTrace        = $ErrorRecord.Exception.StackTrace
            InnerExceptions   = @()
            AdditionalContext = $AdditionalContext
            SystemContext     = @{
                ProcessId         = $PID
                ThreadId          = [System.Threading.Thread]::CurrentThread.ManagedThreadId
                PowerShellVersion = $PSVersionTable.PSVersion.ToString()
                OS                = $PSVersionTable.OS
            }
        }

        $innerEx = $ErrorRecord.Exception.InnerException
        while ($innerEx) {
            $errorInfo.InnerExceptions += [PSCustomObject]@{
                Message    = $innerEx.Message
                Type       = $innerEx.GetType().FullName
                StackTrace = $innerEx.StackTrace
            }
            $innerEx = $innerEx.InnerException
        }

        return $errorInfo

    } catch {
        # Fallback if the error analysis itself fails.
        return [PSCustomObject]@{
            Timestamp     = Get-Date -Format "o"
            Summary       = "CRITICAL: Error analysis failed."
            OriginalError = $ErrorRecord.Exception.Message
            AnalysisError = $_.Exception.Message
            Type          = "ErrorAnalysisFailure"
        }
    }
}

# ------------------------------------------------------------------------------
# Public Functions
# ------------------------------------------------------------------------------

function Invoke-WithErrorHandling {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [scriptblock]$ScriptBlock,
        [Parameter(Mandatory)]
        [string]$Component,
        [Parameter(Mandatory)]
        [hashtable]$Context, # FIX: Changed from [string] to [hashtable]
        [hashtable]$AdditionalData = @{}
    )

    # Defensive checks
    if ($null -eq $ScriptBlock) {
        # This is a programming error, so we throw directly.
        throw "Invoke-WithErrorHandling: ScriptBlock parameter cannot be null."
    }
    if ([string]::IsNullOrWhiteSpace($Component)) {
        $Component = "Unknown Component"
    }
    # Note: No longer checking IsNullOrWhiteSpace for $Context here, as it's now a hashtable.
    # The caller is responsible for providing a meaningful hashtable.

    try {
        # Execute the provided scriptblock.
        return (& $ScriptBlock)
    }
    catch {
        # This block catches any terminating error from the ScriptBlock.
        $originalErrorRecord = $_

        # 1. Identify the component where the error occurred.
        $identifiedComponent = _Identify-HeliosComponent -ErrorRecord $originalErrorRecord
        $finalComponent = if ($Component -ne "Unknown Component") { $Component } else { $identifiedComponent }

        # 2. Gather all possible details about the error.
        # FIX: Clone the incoming Context hashtable to avoid modifying the original and to merge with AdditionalData
        $errorContext = $Context.Clone()
        # Merge additional data provided by the caller.
        $AdditionalData.GetEnumerator() | ForEach-Object { $errorContext[$_.Name] = $_.Value }
        $detailedError = _Get-DetailedError -ErrorRecord $originalErrorRecord -AdditionalContext $errorContext

        # 3. Log the error using the logger module.
        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            # FIX: Get a meaningful operation name from the Context hashtable
            $operationDescription = if ($Context.ContainsKey('Operation')) { $Context.Operation } else { $Context.ToString() }
            Write-Log -Level Error -Message "Error in '$finalComponent' during '$operationDescription': $($originalErrorRecord.Exception.Message)" -Data $detailedError
        }

        # 4. Add the detailed error to the in-memory history for debugging.
        [void]$script:ErrorHistory.Add($detailedError)
        if ($script:ErrorHistory.Count -gt $script:MaxErrorHistory) {
            $script:ErrorHistory.RemoveAt(0)
        }

        # 5. Create a new, rich, strongly-typed exception and throw it.
        # This allows upstream code to catch '[Helios.HeliosException]' specifically.
        $heliosException = New-Object Helios.HeliosException(
            $originalErrorRecord.Exception.Message,
            $finalComponent,
            $detailedError,
            $originalErrorRecord.Exception
        )
        
        # Re-throw the rich exception to allow for top-level handling.
        throw $heliosException
    }
}

function Get-ErrorHistory {
    [CmdletBinding()]
    param(
        [int]$Count = 25
    )
    
    $total = $script:ErrorHistory.Count
    if ($Count -ge $total) {
        return $script:ErrorHistory
    }

    $start = $total - $Count
    return $script:ErrorHistory.GetRange($start, $Count)
}


Export-ModuleMember -Function @(
    'Invoke-WithErrorHandling',
    'Get-ErrorHistory'
)

# NOTE: Custom types defined with Add-Type are automatically available to the session
# after the module is imported. They do not need to be explicitly exported.



####\modules\focus-manager.psm1
#
# MODULE: modules/focus-manager.psm1
#
# PURPOSE:
#   Provides the single source of truth for component focus. It manages the tab order
#   and handles the logic for moving focus between UI components.
#
# ARCHITECTURE:
#   - This module maintains its state in a private [PSCustomObject] called $FocusManager.
#   - It initializes by subscribing to the 'PMC.Navigation.ScreenPushed' engine event.
#   - When a new screen is displayed, it automatically traverses the screen's component
#     tree to build a list of all focusable components (the tab order).
#   - It provides public functions (Request-Focus, Move-Focus) for explicitly setting
#     or moving the focus.
#

using module "$PSScriptRoot/logger.psm1"
using module "$PSScriptRoot/exceptions.psm1"

#region Private State
# ------------------------------------------------------------------------------
# Private state for the Focus Manager. This is not exposed outside the module.
# ------------------------------------------------------------------------------

$FocusManager = [PSCustomObject]@{
    # The component that currently has focus.
    FocusedComponent = $null

    # A sorted list of all components on the current screen that are focusable.
    TabOrder = [System.Collections.Generic.List[object]]::new()

    # The event subscriber object for the Screen.Pushed event.
    EventSubscription = $null
}

#endregion

#region Private Functions
# ------------------------------------------------------------------------------
# Internal helper functions used by the Focus Manager.
# ------------------------------------------------------------------------------

function Find-FocusableComponents {
    param(
        [Parameter(Mandatory = $true)]
        [PSCustomObject]$RootComponent
    )

    $focusable = [System.Collections.Generic.List[object]]::new()
    $queue = [System.Collections.Generic.Queue[object]]::new()
    $queue.Enqueue($RootComponent)

    while ($queue.Count -gt 0) {
        $current = $queue.Dequeue()

        if (-not $current) { continue }

        # A component is focusable if it's visible and has the IsFocusable property set to true.
        if ($current.PSObject.Properties['IsFocusable'] -and $current.IsFocusable -and $current.PSObject.Properties['Visible'] -and $current.Visible) {
            $focusable.Add($current)
        }

        # Recurse into children. The Helios layout system uses a 'Children' property.
        if ($current.PSObject.Properties['Children']) {
            foreach ($child in $current.Children) {
                $queue.Enqueue($child)
            }
        }
    }

    return $focusable
}

function Update-TabOrderAndFocus {
    param(
        [Parameter(Mandatory = $true)]
        [PSCustomObject]$Screen
    )

    Invoke-WithErrorHandling -Component 'FocusManager.UpdateTabOrderAndFocus' -Context @{ ScreenName = $Screen.Name } -ScriptBlock {
        Write-Log -Level Trace -Message "Updating tab order for screen '$($Screen.Name)'"

        # Clear previous state
        $FocusManager.TabOrder.Clear()
        Request-Focus -Component $null -Reason 'ScreenChange'

        if (-not $Screen.RootPanel) {
            Write-Log -Level Warn -Message "Screen '$($Screen.Name)' has no RootPanel. Cannot establish focus."
            return
        }

        # Find all focusable components and establish the new tab order
        $focusableComponents = Find-FocusableComponents -RootComponent $Screen.RootPanel
        $FocusManager.TabOrder.AddRange($focusableComponents)

        Write-Log -Level Debug -Message "Found $($FocusManager.TabOrder.Count) focusable components on screen '$($Screen.Name)'"

        # Set focus to the first component in the new tab order
        if ($FocusManager.TabOrder.Count -gt 0) {
            Request-Focus -Component $FocusManager.TabOrder[0] -Reason 'InitialFocus'
        }
    }
}

#endregion

#region Public Functions
# ------------------------------------------------------------------------------
# Functions exported for use by other modules.
# ------------------------------------------------------------------------------

function Initialize-FocusManager {
    <#
    .SYNOPSIS
        Initializes the Focus Manager and subscribes to necessary application events.
    .DESCRIPTION
        This function must be called once at application startup. It registers an
        engine event handler for 'PMC.Navigation.ScreenPushed'. When this event is
        fired, the Focus Manager automatically rebuilds its tab order based on the
        new screen's components.
    #>
    [CmdletBinding()]
    param()

    Invoke-WithErrorHandling -Component 'FocusManager.Initialize' -Context @{} -ScriptBlock {
        Write-Log -Level Info -Message "Initializing Focus Manager..."

        # The Navigation service will broadcast this event when a screen is pushed.
        $sourceIdentifier = 'PMC.Navigation.ScreenPushed'

        # Unregister any previous subscription to prevent duplicates during development/reloading.
        if ($FocusManager.EventSubscription) {
            Unregister-Event -SubscriptionId $FocusManager.EventSubscription.Id
            Write-Log -Level Debug -Message "Unregistered existing Focus Manager event subscription."
        }

        # Create the handler scriptblock. It receives the event and updates the tab order.
        $handler = {
            param($Event)
            Invoke-WithErrorHandling -Component 'FocusManager.ScreenPushedHandler' -Context @{ EventData = $Event.MessageData } -ScriptBlock {
                $screen = $Event.MessageData.Screen
                if ($screen) {
                    Update-TabOrderAndFocus -Screen $screen
                }
                else {
                    Write-Log -Level Warn -Message 'Screen.Pushed event received without a screen object.'
                }
            }
        }

        # Register the event handler.
        $subscription = Register-EngineEvent -SourceIdentifier $sourceIdentifier -Action $handler
        $FocusManager.EventSubscription = $subscription

        Write-Log -Level Info -Message "Focus Manager initialized and subscribed to '$sourceIdentifier'."
    }
}

function Request-Focus {
    <#
    .SYNOPSIS
        Sets focus to a specific component.
    .DESCRIPTION
        This is the primary method for controlling focus. It handles blurring the
        previously focused component and focusing the new one, including calling
        their respective OnBlur and OnFocus methods.
    .PARAMETER Component
        The component to receive focus. If $null, focus is cleared.
    .PARAMETER Reason
        A string describing why the focus changed, for logging purposes.
    #>
    [CmdletBinding()]
    param(
        [AllowNull()]
        [PSCustomObject]$Component,

        [string]$Reason = 'DirectRequest'
    )

    Invoke-WithErrorHandling -Component 'FocusManager.RequestFocus' -Context @{ TargetComponent = $Component.Name; Reason = $Reason } -ScriptBlock {
        # Defensively check if the target component is actually focusable.
        if ($Component -and $Component.PSObject.Properties['IsFocusable'] -and -not $Component.IsFocusable) {
            Write-Log -Level Debug -Message "Request-Focus ignored for non-focusable component '$($Component.Name)'"
            return
        }

        $oldFocused = $FocusManager.FocusedComponent

        # If focus is not changing, do nothing.
        if ($oldFocused -is [PSCustomObject] -and $oldFocused.Id -eq $Component.Id) {
            return
        }

        # 1. Blur the previously focused component
        if ($oldFocused) {
            $oldFocused.IsFocused = $false
            if ($oldFocused.PSObject.ScriptMethods['OnBlur']) {
                try {
                    $oldFocused.OnBlur()
                    Write-Log -Level Trace -Message "Called OnBlur for component '$($oldFocused.Name)'"
                }
                catch {
                    Write-Log -Level Error -Message "Error in OnBlur for component '$($oldFocused.Name)': $_" -Data $_
                }
            }
        }

        # 2. Update the state to the new component
        $FocusManager.FocusedComponent = $Component
        Write-Log -Level Debug -Message "Focus changed from '$($oldFocused.Name)' to '$($Component.Name)' (Reason: $Reason)"

        # 3. Focus the new component
        if ($Component) {
            $Component.IsFocused = $true
            if ($Component.PSObject.ScriptMethods['OnFocus']) {
                try {
                    $Component.OnFocus()
                    Write-Log -Level Trace -Message "Called OnFocus for component '$($Component.Name)'"
                }
                catch {
                    Write-Log -Level Error -Message "Error in OnFocus for component '$($Component.Name)': $_" -Data $_
                }
            }
        }
    }
}

function Move-Focus {
    <#
    .SYNOPSIS
        Moves focus to the next or previous component in the tab order.
    .DESCRIPTION
        Typically called in response to Tab or Shift+Tab key presses. It cycles
        through the list of focusable components on the current screen.
    .PARAMETER Reverse
        If $true, moves to the previous component instead of the next.
    #>
    [CmdletBinding()]
    param(
        [switch]$Reverse
    )

    Invoke-WithErrorHandling -Component 'FocusManager.MoveFocus' -Context @{ Reverse = $Reverse.IsPresent } -ScriptBlock {
        $tabOrder = $FocusManager.TabOrder
        if ($tabOrder.Count -eq 0) {
            Write-Log -Level Debug -Message "Move-Focus called, but there are no focusable components."
            return
        }

        $currentFocused = $FocusManager.FocusedComponent
        $currentIndex = -1
        if ($currentFocused) {
            $currentIndex = $tabOrder.IndexOf($currentFocused)
        }

        $nextIndex = 0
        if ($currentIndex -eq -1) {
            # No component is currently focused, so focus the first (or last if reversing).
            $nextIndex = if ($Reverse) { $tabOrder.Count - 1 } else { 0 }
        }
        else {
            # Calculate the next index, wrapping around the list.
            $increment = if ($Reverse) { -1 } else { 1 }
            $nextIndex = ($currentIndex + $increment + $tabOrder.Count) % $tabOrder.Count
        }

        $nextComponent = $tabOrder[$nextIndex]
        Request-Focus -Component $nextComponent -Reason ('TabNavigation' + $(if ($Reverse) { 'Reverse' } else { '' }))
    }
}

function Get-FocusedComponent {
    <#
    .SYNOPSIS
        Gets the component that currently has focus.
    .OUTPUTS
        [PSCustomObject] The focused component, or $null if none.
    #>
    [CmdletBinding()]
    [OutputType([PSCustomObject])]
    param()

    return $FocusManager.FocusedComponent
}

#endregion

Export-ModuleMember -Function Initialize-FocusManager, Request-Focus, Move-Focus, Get-FocusedComponent


####\modules\logger.psm1
#
# MODULE: logger.psm1
# PURPOSE: Provides a robust, granular logging system for the PMC Terminal application.
# This module is self-contained and manages its own state for logging configuration and in-memory log queues.
#

# ------------------------------------------------------------------------------
# Module-Scoped State Variables
# ------------------------------------------------------------------------------

# NOTE: The use of '$script:' scope is intentional and correct for managing state
# internal to this module. It does not violate the project's scope purity rules,
# which are designed to prevent state sharing *between* modules.

$script:LogPath = $null
$script:LogLevel = "Info" # Default log level.
$script:LogQueue = [System.Collections.Generic.List[object]]::new() # Use a generic list for better performance over @()
$script:MaxLogSize = 5MB
$script:LogInitialized = $false
$script:CallDepth = 0
$script:TraceAllCalls = $false

# ------------------------------------------------------------------------------
# Private Helper Functions
# ------------------------------------------------------------------------------

# Internal helper to safely serialize objects for logging, preventing circular references or errors.
function ConvertTo-SerializableObject {
    param([object]$Object)

    if ($null -eq $Object) { return $null }

    # Use a set to track visited objects to prevent infinite recursion
    $visited = New-Object 'System.Collections.Generic.HashSet[object]'

    function Convert-Internal {
        param([object]$InputObject, [int]$Depth)

        if ($null -eq $InputObject -or $Depth -gt 5) { return $null }
        if ($InputObject -is [System.Management.Automation.ScriptBlock]) { return '<ScriptBlock>' }
        if ($visited.Contains($InputObject)) { return '<CircularReference>' }
        
        # For non-collection reference types, add to visited set
        if (-not $InputObject.GetType().IsValueType -and -not ($InputObject -is [string])) {
            [void]$visited.Add($InputObject)
        }

        switch ($InputObject.GetType().Name) {
            'Hashtable' {
                $result = @{}
                foreach ($key in $InputObject.Keys) {
                    try {
                        $result[$key] = Convert-Internal -InputObject $InputObject[$key] -Depth ($Depth + 1)
                    } catch {
                        $result[$key] = "<SerializationError: $($_.Exception.Message)>"
                    }
                }
                return $result
            }
            'PSCustomObject' {
                $result = @{}
                foreach ($prop in $InputObject.PSObject.Properties) {
                    try {
                        # Avoid serializing script methods
                        if ($prop.MemberType -ne 'ScriptMethod') {
                           $result[$prop.Name] = Convert-Internal -InputObject $prop.Value -Depth ($Depth + 1)
                        }
                    } catch {
                        $result[$prop.Name] = "<SerializationError: $($_.Exception.Message)>"
                    }
                }
                return $result
            }
            'Object[]' {
                $result = @()
                # Limit array size for performance
                for ($i = 0; $i -lt [Math]::Min($InputObject.Count, 10); $i++) {
                    try {
                        $result += Convert-Internal -InputObject $InputObject[$i] -Depth ($Depth + 1)
                    } catch {
                        $result += "<SerializationError: $($_.Exception.Message)>"
                    }
                }
                if ($InputObject.Count -gt 10) {
                    $result += "<... $($InputObject.Count - 10) more items>"
                }
                return $result
            }
            default {
                try {
                    # For simple types, return as-is or convert to string
                    if ($InputObject -is [string] -or $InputObject -is [int] -or $InputObject -is [bool] -or $InputObject -is [double] -or $InputObject -is [datetime] -or $InputObject -is [decimal]) {
                        return $InputObject
                    } else {
                        return $InputObject.ToString()
                    }
                } catch {
                    return "<ToString failed: $($_.Exception.Message)>"
                }
            }
        }
    }

    return Convert-Internal -InputObject $Object -Depth 0
}

# ------------------------------------------------------------------------------
# Public Functions
# ------------------------------------------------------------------------------

function Initialize-Logger {
    [CmdletBinding()]
    param(
        [string]$LogDirectory = (Join-Path $env:TEMP "PMCTerminal"),
        [string]$LogFileName = "pmc_terminal_{0:yyyy-MM-dd}.log" -f (Get-Date),
        [ValidateSet("Debug", "Verbose", "Info", "Warning", "Error", "Trace")]
        [string]$Level = "Debug"
    )

    # Defensive checks
    if ([string]::IsNullOrWhiteSpace($LogDirectory)) {
        Write-Warning "Initialize-Logger: LogDirectory parameter cannot be null or empty."
        return
    }
    if ([string]::IsNullOrWhiteSpace($LogFileName)) {
        Write-Warning "Initialize-Logger: LogFileName parameter cannot be null or empty."
        return
    }

    try {
        if (-not (Test-Path $LogDirectory)) {
            New-Item -ItemType Directory -Path $LogDirectory -Force -ErrorAction Stop | Out-Null
        }

        $script:LogPath = Join-Path $LogDirectory $LogFileName
        $script:LogLevel = $Level
        $script:LogInitialized = $true

        Write-Log -Level Info -Message "Logger initialized" -Data @{
            LogPath           = $script:LogPath
            PowerShellVersion = $PSVersionTable.PSVersion.ToString()
            OS                = $PSVersionTable.OS
            ProcessId         = $PID
            InitializedAt     = Get-Date -Format "yyyy-MM-dd HH:mm:ss.fff"
        } -Force # Force this initial message to be written

    } catch {
        Write-Warning "Failed to initialize logger: $_"
        $script:LogInitialized = $false
    }
}

function Write-Log {
    [CmdletBinding()]
    param(
        [ValidateSet("Debug", "Verbose", "Info", "Warning", "Error", "Trace")]
        [string]$Level = "Info",
        [Parameter(Mandatory)]
        [string]$Message,
        [object]$Data,
        [switch]$Force # Force logging even if level is below threshold
    )

    if (-not $script:LogInitialized -and -not $Force) { return }

    $levelPriority = @{
        Debug   = 0
        Trace   = 0
        Verbose = 1
        Info    = 2
        Warning = 3
        Error   = 4
    }

    if (-not $Force -and $levelPriority[$Level] -lt $levelPriority[$script:LogLevel]) { return }

    try {
        $callStack = Get-PSCallStack
        $caller = if ($callStack.Count -gt 1) { $callStack[1] } else { $callStack[0] }

        $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss.fff"
        $threadId = [System.Threading.Thread]::CurrentThread.ManagedThreadId

        $logContext = @{
            Timestamp     = $timestamp
            Level         = $Level
            ThreadId      = $threadId
            CallDepth     = $script:CallDepth
            Message       = $Message
            Caller        = @{
                Command      = $caller.Command
                Location     = $caller.Location
                ScriptName   = $caller.ScriptName
                LineNumber   = $caller.ScriptLineNumber
            }
        }

        if ($PSBoundParameters.ContainsKey('Data')) {
            $logContext.UserData = if ($Data -is [Exception]) {
                @{
                    Type           = "Exception"
                    Message        = $Data.Message
                    StackTrace     = $Data.StackTrace
                    InnerException = if ($Data.InnerException) { $Data.InnerException.Message } else { $null }
                }
            } else {
                ConvertTo-SerializableObject -Object $Data
            }
        }

        $indent = "  " * $script:CallDepth
        $callerInfo = if ($caller.ScriptName) {
            "$([System.IO.Path]::GetFileName($caller.ScriptName)):$($caller.ScriptLineNumber)"
        } else {
            $caller.Command
        }

        $logEntry = "$timestamp [$($Level.PadRight(7))] $indent [$callerInfo] $Message"

        if ($PSBoundParameters.ContainsKey('Data')) {
            $dataStr = if ($Data -is [Exception]) {
                "`n${indent}  Exception: $($Data.Message)`n${indent}  StackTrace: $($Data.StackTrace)"
            } else {
                try {
                    $json = ConvertTo-SerializableObject -Object $Data | ConvertTo-Json -Compress -Depth 4 -WarningAction SilentlyContinue
                    "`n${indent}  Data: $json"
                } catch {
                    "`n${indent}  Data: $($Data.ToString())"
                }
            }
            $logEntry += $dataStr
        }

        $script:LogQueue.Add($logContext)
        if ($script:LogQueue.Count -gt 2000) {
            $script:LogQueue.RemoveRange(0, $script:LogQueue.Count - 2000)
        }

        if ($script:LogPath) {
            try {
                if ((Test-Path $script:LogPath) -and (Get-Item $script:LogPath).Length -gt $script:MaxLogSize) {
                    $archivePath = $script:LogPath -replace '\.log$', "_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
                    Move-Item $script:LogPath $archivePath -Force
                }
                Add-Content -Path $script:LogPath -Value $logEntry -Encoding UTF8 -Force
            } catch {
                Write-Host "LOG WRITE FAILED: $logEntry" -ForegroundColor Yellow
                Write-Host "Error: $_" -ForegroundColor Red
            }
        }

        if ($Level -in @('Error', 'Warning')) {
            $color = if ($Level -eq 'Error') { 'Red' } else { 'Yellow' }
            Write-Host $logEntry -ForegroundColor $color
        }

    } catch {
        try {
            $errorEntry = "$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff') [LOGGER ERROR] Failed to log message '$Message': $_"
            if ($script:LogPath) {
                Add-Content -Path $script:LogPath -Value $errorEntry -Encoding UTF8
            }
            Write-Host $errorEntry -ForegroundColor Red
        } catch {
            Write-Host "CRITICAL: Logger completely failed: $_" -ForegroundColor Red
        }
    }
}

function Trace-FunctionEntry {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$FunctionName,
        [object]$Parameters
    )
    if (-not $script:TraceAllCalls) { return }
    $script:CallDepth++
    Write-Log -Level Trace -Message "ENTER: $FunctionName" -Data @{
        Parameters = $Parameters
        Action     = "FunctionEntry"
    }
}

function Trace-FunctionExit {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$FunctionName,
        [object]$ReturnValue,
        [switch]$WithError
    )
    if (-not $script:TraceAllCalls) { return }
    Write-Log -Level Trace -Message "EXIT: $FunctionName" -Data @{
        ReturnValue = $ReturnValue
        Action      = if ($WithError) { "FunctionExitWithError" } else { "FunctionExit" }
        HasError    = $WithError.IsPresent
    }
    $script:CallDepth--
    if ($script:CallDepth -lt 0) { $script:CallDepth = 0 }
}

function Trace-Step {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$StepName,
        [object]$StepData,
        [string]$Module
    )
    $caller = (Get-PSCallStack)[1]
    $moduleInfo = if ($Module) { $Module } elseif ($caller.ScriptName) { [System.IO.Path]::GetFileNameWithoutExtension($caller.ScriptName) } else { "Unknown" }

    Write-Log -Level Debug -Message "STEP: $StepName" -Data @{
        StepData = $StepData
        Module   = $moduleInfo
        Action   = "Step"
    }
}

function Trace-StateChange {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$StateType,
        [object]$OldValue,
        [object]$NewValue,
        [string]$PropertyPath
    )
    Write-Log -Level Debug -Message "STATE: $StateType changed" -Data @{
        StateType    = $StateType
        PropertyPath = $PropertyPath
        OldValue     = $OldValue
        NewValue     = $NewValue
        Action       = "StateChange"
    }
}

function Trace-ComponentLifecycle {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$ComponentType,
        [Parameter(Mandatory)]
        [string]$ComponentId,
        [Parameter(Mandatory)]
        [ValidateSet('Create', 'Initialize', 'Render', 'Update', 'Destroy')]
        [string]$Phase,
        [object]$ComponentData
    )
    Write-Log -Level Debug -Message "COMPONENT: $ComponentType [$ComponentId] $Phase" -Data @{
        ComponentType = $ComponentType
        ComponentId   = $ComponentId
        Phase         = $Phase
        ComponentData = $ComponentData
        Action        = "ComponentLifecycle"
    }
}

function Trace-ServiceCall {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$ServiceName,
        [Parameter(Mandatory)]
        [string]$MethodName,
        [object]$Parameters,
        [object]$Result,
        [switch]$IsError
    )
    $action = if ($IsError) { "ServiceCallError" } else { "ServiceCall" }
    Write-Log -Level Debug -Message "SERVICE: $ServiceName.$MethodName" -Data @{
        ServiceName = $ServiceName
        MethodName  = $MethodName
        Parameters  = $Parameters
        Result      = $Result
        Action      = $action
        IsError     = $IsError.IsPresent
    }
}

function Get-LogEntries {
    [CmdletBinding()]
    param(
        [int]$Count = 100,
        [string]$Level,
        [string]$Module,
        [string]$Action
    )
    try {
        $entries = $script:LogQueue.ToArray() # Work on a copy

        if ($Level) {
            $entries = $entries | Where-Object { $_.Level -eq $Level }
        }
        if ($Module) {
            $entries = $entries | Where-Object { $_.Caller.ScriptName -and ([System.IO.Path]::GetFileNameWithoutExtension($_.Caller.ScriptName) -like "*$Module*") }
        }
        if ($Action) {
            $entries = $entries | Where-Object { $_.UserData.Action -eq $Action }
        }

        return $entries | Select-Object -Last $Count
    } catch {
        Write-Warning "Error getting log entries: $_"
        return @()
    }
}

function Get-CallTrace {
    [CmdletBinding()]
    param([int]$Depth = 10)

    try {
        $callStack = Get-PSCallStack
        $trace = @()

        for ($i = 1; $i -lt [Math]::Min($callStack.Count, $Depth + 1); $i++) { # Skip self
            $call = $callStack[$i]
            $trace += @{
                Level      = $i - 1
                Command    = $call.Command
                Location   = $call.Location
                ScriptName = $call.ScriptName
                LineNumber = $call.ScriptLineNumber
            }
        }
        return $trace
    } catch {
        Write-Warning "Error getting call trace: $_"
        return @()
    }
}

function Clear-LogQueue {
    [CmdletBinding()]
    param()
    
    try {
        $script:LogQueue.Clear()
        Write-Log -Level Info -Message "In-memory log queue cleared"
    } catch {
        Write-Warning "Error clearing log queue: $_"
    }
}

function Set-LogLevel {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [ValidateSet("Debug", "Verbose", "Info", "Warning", "Error", "Trace")]
        [string]$Level
    )
    try {
        $oldLevel = $script:LogLevel
        $script:LogLevel = $Level
        Write-Log -Level Info -Message "Log level changed from '$oldLevel' to '$Level'" -Force
    } catch {
        Write-Warning "Error setting log level to '$Level': $_"
    }
}

function Enable-CallTracing {
    [CmdletBinding()]
    param()
    
    $script:TraceAllCalls = $true
    Write-Log -Level Info -Message "Call tracing enabled" -Force
}

function Disable-CallTracing {
    [CmdletBinding()]
    param()
    
    $script:TraceAllCalls = $false
    Write-Log -Level Info -Message "Call tracing disabled" -Force
}

function Get-LogPath {
    [CmdletBinding()]
    return $script:LogPath
}

function Get-LogStatistics {
    [CmdletBinding()]
    try {
        $stats = [PSCustomObject]@{
            TotalEntries       = $script:LogQueue.Count
            LogPath            = $script:LogPath
            LogLevel           = $script:LogLevel
            CallTracingEnabled = $script:TraceAllCalls
            LogFileSize        = if ($script:LogPath -and (Test-Path $script:LogPath)) { (Get-Item $script:LogPath).Length } else { 0 }
            EntriesByLevel     = @{}
            EntriesByModule    = @{}
            EntriesByAction    = @{}
        }

        foreach ($entry in $script:LogQueue) {
            $level = $entry.Level
            if (-not $stats.EntriesByLevel.ContainsKey($level)) { $stats.EntriesByLevel[$level] = 0 }
            $stats.EntriesByLevel[$level]++

            if ($entry.Caller.ScriptName) {
                $module = [System.IO.Path]::GetFileNameWithoutExtension($entry.Caller.ScriptName)
                if (-not $stats.EntriesByModule.ContainsKey($module)) { $stats.EntriesByModule[$module] = 0 }
                $stats.EntriesByModule[$module]++
            }

            if ($entry.UserData -and $entry.UserData.Action) {
                $action = $entry.UserData.Action
                if (-not $stats.EntriesByAction.ContainsKey($action)) { $stats.EntriesByAction[$action] = 0 }
                $stats.EntriesByAction[$action]++
            }
        }

        return $stats
    } catch {
        Write-Warning "Error getting log statistics: $_"
        return [PSCustomObject]@{}
    }
}

Export-ModuleMember -Function @(
    'Initialize-Logger',
    'Write-Log',
    'Trace-FunctionEntry',
    'Trace-FunctionExit',
    'Trace-Step',
    'Trace-StateChange',
    'Trace-ComponentLifecycle',
    'Trace-ServiceCall',
    'Get-LogEntries',
    'Get-CallTrace',
    'Clear-LogQueue',
    'Set-LogLevel',
    'Enable-CallTracing',
    'Disable-CallTracing',
    'Get-LogPath',
    'Get-LogStatistics'
)



####\modules\theme-support.psm1
#
# MODULE: theme-support.psm1
# PURPOSE: Provides minimal theme support for the PMC Terminal application
# This is a simplified version that follows PowerShell-First principles
#

# Module-scoped theme configuration
$script:CurrentTheme = @{
    Name = "Default"
    Colors = @{
        # Core colors
        Background = [ConsoleColor]::Black
        Primary = [ConsoleColor]::White
        Secondary = [ConsoleColor]::Gray
        Accent = [ConsoleColor]::Cyan
        
        # Semantic colors
        Success = [ConsoleColor]::Green
        Warning = [ConsoleColor]::Yellow
        Error = [ConsoleColor]::Red
        Info = [ConsoleColor]::Blue
        
        # UI element colors
        Border = [ConsoleColor]::DarkGray
        Header = [ConsoleColor]::Cyan
        Footer = [ConsoleColor]::DarkGray
        Subtle = [ConsoleColor]::DarkGray
        
        # Component-specific colors
        ButtonFocused = [ConsoleColor]::Cyan
        ButtonUnfocused = [ConsoleColor]::Gray
        InputFocused = [ConsoleColor]::White
        InputUnfocused = [ConsoleColor]::Gray
        TableHeader = [ConsoleColor]::Cyan
        TableRowSelected = [ConsoleColor]::Cyan
    }
}

function Get-ThemeColor {
    <#
    .SYNOPSIS
        Gets a color value from the current theme
    .PARAMETER ColorName
        The name of the color to retrieve
    .PARAMETER Default
        Default color to return if the requested color is not found
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$ColorName,
        
        [ConsoleColor]$Default = [ConsoleColor]::White
    )
    
    if ($script:CurrentTheme.Colors.ContainsKey($ColorName)) {
        return $script:CurrentTheme.Colors[$ColorName]
    }
    
    # Log warning for missing color (but don't fail)
    if (Get-Command -Name "Write-Log" -ErrorAction SilentlyContinue) {
        Write-Log -Level Debug -Message "Theme color '$ColorName' not found, using default: $Default"
    }
    
    return $Default
}

function Set-Theme {
    <#
    .SYNOPSIS
        Sets the current theme
    .PARAMETER ThemeName
        The name of the theme to set
    .PARAMETER Colors
        Hashtable of color overrides
    #>
    [CmdletBinding()]
    param(
        [string]$ThemeName = "Default",
        [hashtable]$Colors = @{}
    )
    
    $script:CurrentTheme.Name = $ThemeName
    
    # Apply color overrides
    foreach ($key in $Colors.Keys) {
        $script:CurrentTheme.Colors[$key] = $Colors[$key]
    }
    
    # Request TUI refresh if available
    if (Get-Command -Name "Request-TuiRefresh" -ErrorAction SilentlyContinue) {
        Request-TuiRefresh
    }
}

function Get-CurrentTheme {
    <#
    .SYNOPSIS
        Gets the current theme configuration
    #>
    [CmdletBinding()]
    param()
    
    # Return a copy to prevent direct modification
    return @{
        Name = $script:CurrentTheme.Name
        Colors = $script:CurrentTheme.Colors.Clone()
    }
}

# Export functions
Export-ModuleMember -Function @(
    'Get-ThemeColor',
    'Set-Theme',
    'Get-CurrentTheme'
)


####\modules\tui-engine.psm1
# modules/tui-engine.psm1
# PURPOSE: Core TUI rendering engine implementing the PowerShell-first architecture
# Provides screen management, input processing, and frame rendering with recursive component tree traversal

#region Module Dependencies
Import-Module "$PSScriptRoot\logger.psm1" -Force
Import-Module "$PSScriptRoot\exceptions.psm1" -Force
# NOTE: event-system removed - using PowerShell native eventing

#endregion

#region Core TUI State
# The only global variable allowed per architecture principles
$global:TuiState = [PSCustomObject]@{
    Running = $false
    BufferWidth = 0
    BufferHeight = 0
    FrontBuffer = $null
    BackBuffer = $null
    ScreenStack = New-Object System.Collections.Stack
    CurrentScreen = $null
    IsDirty = $true
    LastActivity = [DateTime]::Now
    LastRenderTime = [DateTime]::MinValue
    RenderStats = @{ 
        LastFrameTime = 0
        FrameCount = 0
        TotalTime = 0
        TargetFPS = 60
    }
    Components = @()
    FocusedComponent = $null
    InputQueue = $null
    InputRunspace = $null
    InputPowerShell = $null
    InputAsyncResult = $null
    CancellationTokenSource = $null
    EventHandlers = @{}
}
#endregion

#region Engine Initialization

function Initialize-TuiEngine {
    param(
        [int]$Width = [Console]::WindowWidth,
        [int]$Height = [Console]::WindowHeight - 1
    )

    Invoke-WithErrorHandling -Component "TuiEngine.Initialize" -Context @{ Operation = "Initialize"; Width = $Width; Height = $Height } -ScriptBlock {
        # Validate parameters
        if ($Width -le 0 -or $Height -le 0) {
            throw "Invalid console dimensions: ${Width}x${Height}"
        }

        Write-Log -Level Info -Message "Initializing TUI Engine: ${Width}x${Height}"

        $global:TuiState.BufferWidth = $Width
        $global:TuiState.BufferHeight = $Height

        # Create 2D arrays for double buffering
        $global:TuiState.FrontBuffer = New-Object 'object[,]' $Height, $Width
        $global:TuiState.BackBuffer = New-Object 'object[,]' $Height, $Width

        # Initialize buffers with empty cells
        for ($y = 0; $y -lt $Height; $y++) {
            for ($x = 0; $x -lt $Width; $x++) {
                $global:TuiState.FrontBuffer[$y, $x] = @{ 
                    Char = ' '
                    FG = [ConsoleColor]::White
                    BG = [ConsoleColor]::Black 
                }
                $global:TuiState.BackBuffer[$y, $x] = @{ 
                    Char = ' '
                    FG = [ConsoleColor]::White
                    BG = [ConsoleColor]::Black 
                }
            }
        }

        # Configure console
        [Console]::CursorVisible = $false
        [Console]::Clear()

        # Initialize input thread
        Initialize-InputThread

        # Register engine event source (using native PowerShell eventing)
        $ErrorActionPreference = 'SilentlyContinue'
        Unregister-Event -SourceIdentifier 'TuiEngine.System' -ErrorAction SilentlyContinue
        $ErrorActionPreference = 'Stop'
        Register-EngineEvent -SourceIdentifier 'TuiEngine.System' -SupportEvent
        
        # Announce initialization
        New-Event -SourceIdentifier 'TuiEngine.System' -EventArguments @{ 
            EventType = 'EngineInitialized'
            Width = $Width
            Height = $Height 
        }

        Write-Log -Level Info -Message "TUI Engine initialized successfully"

    } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "TUI Engine initialization failed" -Data $Exception
        throw [Helios.ServiceInitializationException]::new( # FIX: Specify full type for custom exception
            "Failed to initialize TUI Engine",
            @{
                OriginalException = $Exception.OriginalError # FIX: Access OriginalError from HeliosException
                Context = $Exception.Context
            },
            $Exception # FIX: Pass original exception as inner
        )
    }
}

function Initialize-InputThread {
    Invoke-WithErrorHandling -Component "TuiEngine.InitializeInput" -Context @{ Operation = "InitializeInputThread" } -ScriptBlock {
        Write-Log -Level Debug -Message "Initializing input thread"

        # Create thread-safe input queue
        try {
            $queueType = [System.Collections.Concurrent.ConcurrentQueue[System.ConsoleKeyInfo]]
            $global:TuiState.InputQueue = New-Object $queueType
        } catch {
            Write-Log -Level Warning -Message "Failed to create ConcurrentQueue, using ArrayList"
            $global:TuiState.InputQueue = [System.Collections.ArrayList]::Synchronized([System.Collections.ArrayList]::new())
        }

        # Create cancellation token for clean shutdown
        $global:TuiState.CancellationTokenSource = [System.Threading.CancellationTokenSource]::new()
        $token = $global:TuiState.CancellationTokenSource.Token

        # Create runspace for background input handling
        $runspace = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()
        $runspace.Open()
        $runspace.SessionStateProxy.SetVariable('InputQueue', $global:TuiState.InputQueue)
        $runspace.SessionStateProxy.SetVariable('token', $token)

        # Create PowerShell instance for the runspace
        $ps = [System.Management.Automation.PowerShell]::Create()
        $ps.Runspace = $runspace

        # Add input handling script
        $ps.AddScript({
            try {
                while (-not $token.IsCancellationRequested) {
                    if ([Console]::KeyAvailable) {
                        $keyInfo = [Console]::ReadKey($true)
                        
                        if ($InputQueue -is [System.Collections.Concurrent.ConcurrentQueue[System.ConsoleKeyInfo]]) {
                            if ($InputQueue.Count -lt 100) {
                                $InputQueue.Enqueue($keyInfo)
                            }
                        } elseif ($InputQueue -is [System.Collections.ArrayList]) {
                            if ($InputQueue.Count -lt 100) {
                                $InputQueue.Add($keyInfo) | Out-Null
                            }
                        }
                    } else {
                        Start-Sleep -Milliseconds 20
                    }
                }
            } catch [System.Management.Automation.PipelineStoppedException] {
                return
            } catch {
                Write-Warning "Input thread error: $_"
            }
        }) | Out-Null

        # Store references for cleanup
        $global:TuiState.InputRunspace = $runspace
        $global:TuiState.InputPowerShell = $ps
        $global:TuiState.InputAsyncResult = $ps.BeginInvoke()

        Write-Log -Level Debug -Message "Input thread initialized"

    } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to initialize input thread" -Data $Exception
        throw # Re-throw as a HeliosException already wrapped by Invoke-WithErrorHandling
    }
}

#endregion

#region Main Loop

function Start-TuiLoop {
    param([PSCustomObject]$InitialScreen = $null)

    Invoke-WithErrorHandling -Component "TuiEngine.MainLoop" -Context @{ InitialScreen = $InitialScreen?.Name } -ScriptBlock {
        # Initialize if not already done
        if (-not $global:TuiState.BufferWidth -or $global:TuiState.BufferWidth -eq 0) {
            Initialize-TuiEngine
        }

        if ($InitialScreen) {
            Push-Screen -Screen $InitialScreen
        }

        # Validate we have a screen to display
        if (-not $global:TuiState.CurrentScreen -and $global:TuiState.ScreenStack.Count -eq 0) {
            throw "No screen available to display"
        }

        $global:TuiState.Running = $true
        $frameTime = New-Object System.Diagnostics.Stopwatch
        $targetFrameTime = 1000.0 / $global:TuiState.RenderStats.TargetFPS

        Write-Log -Level Info -Message "Starting TUI main loop"

        while ($global:TuiState.Running) {
            try {
                $frameTime.Restart()

                # Process input
                $hadInput = Process-TuiInput

                # Update dialog system if available
                # NOTE: Update-DialogSystem is not defined in any provided module.
                # If this is intended functionality, it would need to be added
                # to the dialog-system.psm1 module. Commenting out for now to prevent CommandNotFound errors.
                # if (Get-Command -Name "Update-DialogSystem" -ErrorAction SilentlyContinue) {
                #     try { Update-DialogSystem } catch { Write-Log -Level Warning -Message "Dialog update error: $_" }
                # }

                # Render frame if needed
                if ($global:TuiState.IsDirty -or $hadInput) {
                    Render-Frame
                    $global:TuiState.IsDirty = $false
                }

                # Frame timing
                $elapsed = $frameTime.ElapsedMilliseconds
                if ($elapsed -lt $targetFrameTime) {
                    $sleepTime = [Math]::Max(1, $targetFrameTime - $elapsed)
                    Start-Sleep -Milliseconds $sleepTime
                }

            } catch [Helios.HeliosException] { # FIX: Use full exception type
                # Handle recoverable errors
                $exception = $_.Exception
                Write-Log -Level Error -Message "TUI Exception occurred: $($exception.Message)" -Data $exception.DetailedContext # FIX: Access DetailedContext
                
                if (Get-Command -Name "Show-AlertDialog" -ErrorAction SilentlyContinue) {
                    Show-AlertDialog -Title "Application Error" -Message "An operation failed: $($exception.Message)"
                }
                
                $global:TuiState.IsDirty = $true

            } catch {
                # Handle fatal errors (standard PowerShell errors not wrapped by Invoke-WithErrorHandling)
                Write-Log -Level Error -Message "Fatal TUI error: $($_.Exception.Message)" -Data $_ # Data includes ErrorRecord
                
                if (Get-Command -Name "Show-AlertDialog" -ErrorAction SilentlyContinue) {
                    Show-AlertDialog -Title "Fatal Error" -Message "A critical error occurred. The application will now close."
                }
                
                $global:TuiState.Running = $false
            }
        }

    } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Main loop error" -Data $Exception
        throw # Re-throw as a HeliosException already wrapped by Invoke-WithErrorHandling
    } -Finally {
        Cleanup-TuiEngine
    }
}

# FIX: Corrected and singular Process-TuiInput function
function Process-TuiInput {
    if (-not $global:TuiState.InputQueue) { return $false }

    $processedAny = $false
    
    Invoke-WithErrorHandling -Component "TuiEngine.ProcessInput" -Context @{ Operation = "ProcessInputQueue" } -ScriptBlock {
        Write-Log -Level Verbose -Message "Processing input queue"

        if ($global:TuiState.InputQueue -is [System.Collections.Concurrent.ConcurrentQueue[System.ConsoleKeyInfo]]) {
            $keyInfo = [System.ConsoleKeyInfo]::new([char]0, [System.ConsoleKey]::None, $false, $false, $false)
            # FIX: Removed [ref] keyword for TryDequeue - pass variable directly for 'out' parameter
            while ($global:TuiState.InputQueue.TryDequeue($keyInfo)) {
                $processedAny = $true
                $global:TuiState.LastActivity = [DateTime]::Now
                Process-SingleKeyInput -keyInfo $keyInfo
            }
        } elseif ($global:TuiState.InputQueue -is [System.Collections.ArrayList]) {
            while ($global:TuiState.InputQueue.Count -gt 0) {
                try {
                    $keyInfo = $global:TuiState.InputQueue[0]
                    $global:TuiState.InputQueue.RemoveAt(0)
                    $processedAny = $true
                    $global:TuiState.LastActivity = [DateTime]::Now
                    Process-SingleKeyInput -keyInfo $keyInfo
                } catch {
                    break
                }
            }
        }

    } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Error processing input" -Data $Exception
        Request-TuiRefresh
    }

    return $processedAny
}

function Process-SingleKeyInput {
    param($keyInfo)

    Invoke-WithErrorHandling -Component "TuiEngine.ProcessSingleKey" -Context @{ Key = $keyInfo.Key; Operation = "ProcessSingleKeyInput" } -ScriptBlock {
        # Handle Tab navigation
        if ($keyInfo.Key -eq [ConsoleKey]::Tab) {
            Handle-TabNavigation -Reverse ($keyInfo.Modifiers -band [ConsoleModifiers]::Shift)
            return
        }

        # Let dialog system handle input first
        if ((Get-Command -Name "Handle-DialogInput" -ErrorAction SilentlyContinue) -and 
            (Handle-DialogInput -Key $keyInfo)) {
            return
        }

        # Focused component gets next chance
        # Ensure HandleInput exists as a ScriptMethod (or other callable member type)
        if ($global:TuiState.FocusedComponent -and $global:TuiState.FocusedComponent.PSObject.ScriptMethods['HandleInput']) {
            if ($global:TuiState.FocusedComponent.HandleInput($keyInfo)) { # Direct call, no & needed for ScriptMethod
                return
            }
        }

        # Finally, the screen handles input
        # Ensure HandleInput exists as a ScriptMethod (or other callable member type)
        if ($global:TuiState.CurrentScreen -and $global:TuiState.CurrentScreen.PSObject.ScriptMethods['HandleInput']) {
            $result = $global:TuiState.CurrentScreen.HandleInput($keyInfo) # Direct call, no & needed for ScriptMethod
            switch ($result) {
                "Back" { Pop-Screen }
                "Quit" { 
                    $global:TuiState.Running = $false
                    if ($global:TuiState.CancellationTokenSource) {
                        $global:TuiState.CancellationTokenSource.Cancel()
                    }
                }
            }
        }

    } -ErrorHandler {
        param($Exception)
        Write-Log -Level Warning -Message "Input processing error" -Data $Exception
    }
}

#endregion

#region Frame Rendering - CRITICAL RECURSIVE IMPLEMENTATION

function Render-Frame {
    Invoke-WithErrorHandling -Component "TuiEngine.RenderFrame" -Context @{ Operation = "RenderFrame" } -ScriptBlock {
        Write-Log -Level Verbose -Message "Starting recursive frame render"

        # Get background color
        $bgColor = if (Get-Command -Name "Get-ThemeColor" -ErrorAction SilentlyContinue) {
            Get-ThemeColor "Background"
        } else {
            [ConsoleColor]::Black
        }

        # Clear the back buffer
        Clear-BackBuffer -BackgroundColor $bgColor

        # 1. Render screen chrome (header, footer, etc.)
        if ($global:TuiState.CurrentScreen -and $global:TuiState.CurrentScreen.PSObject.ScriptMethods['Render']) {
            $global:TuiState.CurrentScreen.Render() # Direct call, no & needed for ScriptMethod
        }

        # 2. COLLECT all visible components recursively
        $renderQueue = [System.Collections.Generic.List[PSCustomObject]]::new()

        # Define the recursive collection function
        $collectComponents = {
            param($component)
            
            if (-not $component -or $component.Visible -eq $false) { return }

            # Add component to render queue
            $renderQueue.Add($component)

            Write-Log -Level Debug -Message "Collected component: Type=$($component.Type), Name=$($component.Name), Pos=($($component.X),$($component.Y)), ZIndex=$($component.ZIndex), Children=$($component.Children.Count)"

            # Check if this is a panel and needs layout calculation
            # Ensure CalculateLayout exists as a ScriptMethod (or other callable member type)
            if ($component.PSObject.ScriptMethods['CalculateLayout']) {
                try {
                    Write-Log -Level Debug -Message "Calculating layout for panel: $($component.Name)"
                    [void]($component.CalculateLayout()) # Direct call, no & needed for ScriptMethod
                } catch {
                    Write-Log -Level Error -Message "Layout calculation failed for '$($component.Name)'" -Data $_
                }
            }

            # Recursively collect children
            if ($component.Children -and $component.Children.Count -gt 0) {
                foreach ($child in $component.Children) {
                    & $collectComponents $child
                }
            }
        }

        # Start collection from screen's children
        if ($global:TuiState.CurrentScreen -and $global:TuiState.CurrentScreen.Children) {
            Write-Log -Level Debug -Message "Starting collection from screen children: Count=$($global:TuiState.CurrentScreen.Children.Count)"
            foreach ($child in $global:TuiState.CurrentScreen.Children) {
                & $collectComponents $child
            }
        }

        # Also collect from any active dialogs
        # FIX: Changed Get-CurrentDialog to Get-ActiveDialog, as exported by dialog-system.psm1
        if (Get-Command -Name "Get-ActiveDialog" -ErrorAction SilentlyContinue) {
            $currentDialog = Get-ActiveDialog
            if ($currentDialog) {
                Write-Log -Level Debug -Message "Collecting dialog components"
                & $collectComponents $currentDialog
            }
        }

        # 3. SORT components by ZIndex
        $sortedComponents = $renderQueue | Sort-Object -Property @{
            Expression = { if ($null -ne $_.ZIndex) { $_.ZIndex } else { 0 } }
        }

        Write-Log -Level Debug -Message "Rendering $($sortedComponents.Count) components sorted by ZIndex"

        # 4. RENDER each component
        foreach ($component in $sortedComponents) {
            # Ensure Render exists as a ScriptMethod (or other callable member type)
            if ($component.PSObject.ScriptMethods['Render']) {
                Invoke-WithErrorHandling -Component "$($component.Name ?? $component.Type).Render" -Context @{ 
                    Operation = "RenderComponent";
                    ComponentType = $component.Type;
                    ComponentName = $component.Name
                } -ScriptBlock {
                    $component.Render() # Direct call, no & needed for ScriptMethod
                } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "Component render error" -Data $Exception
                    throw [Helios.ComponentRenderException]::new( # FIX: Specify full type for custom exception
                        "Failed to render component '$($Exception.Context.ComponentName ?? $Exception.Context.ComponentType)'",
                        @{
                            FailingComponent = $component
                            OriginalException = $Exception.OriginalError # FIX: Access OriginalError from HeliosException
                        },
                        $Exception # FIX: Pass original exception as inner
                    )
                }
            }
        }

        # 5. Swap buffers and display
        Render-BufferOptimized

        # Position cursor out of the way
        [Console]::SetCursorPosition($global:TuiState.BufferWidth - 1, $global:TuiState.BufferHeight - 1)

    } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Fatal frame render error" -Data $Exception
        throw # Re-throw as a HeliosException already wrapped by Invoke-WithErrorHandling
    }
}

function Render-BufferOptimized {
    $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()
    $outputBuilder = New-Object System.Text.StringBuilder -ArgumentList 20000
    $lastFG = -1
    $lastBG = -1
    
    $forceFullRender = $global:TuiState.RenderStats.FrameCount -eq 0
    
    Invoke-WithErrorHandling -Component "TuiEngine.RenderBuffer" -Context @{ Operation = "RenderBufferOptimized" } -ScriptBlock {
        # Build ANSI output with change detection
        for ($y = 0; $y -lt $global:TuiState.BufferHeight; $y++) {
            $outputBuilder.Append("$([char]27)[$($y + 1);1H") | Out-Null
            
            for ($x = 0; $x -lt $global:TuiState.BufferWidth; $x++) {
                $backCell = $global:TuiState.BackBuffer[$y, $x]
                $frontCell = $global:TuiState.FrontBuffer[$y, $x]
                
                # Skip unchanged cells unless forcing full render
                if (-not $forceFullRender -and
                    $backCell.Char -eq $frontCell.Char -and 
                    $backCell.FG -eq $frontCell.FG -and 
                    $backCell.BG -eq $frontCell.BG) {
                    continue
                }
                
                # Position cursor if we skipped cells
                if ($x -gt 0 -and $outputBuilder.Length -gt 0) {
                    $outputBuilder.Append("$([char]27)[$($y + 1);$($x + 1)H") | Out-Null
                }
                
                # Update colors if changed
                if ($backCell.FG -ne $lastFG -or $backCell.BG -ne $lastBG) {
                    $fgCode = Get-AnsiColorCode $backCell.FG
                    $bgCode = Get-AnsiColorCode $backCell.BG -IsBackground $true
                    $outputBuilder.Append("$([char]27)[${fgCode};${bgCode}m") | Out-Null
                    $lastFG = $backCell.FG
                    $lastBG = $backCell.BG
                }
                
                $outputBuilder.Append($backCell.Char) | Out-Null
                
                # Update front buffer
                $global:TuiState.FrontBuffer[$y, $x] = @{
                    Char = $backCell.Char
                    FG = $backCell.FG
                    BG = $backCell.BG
                }
            }
        }
        
        # Reset ANSI formatting
        $outputBuilder.Append("$([char]27)[0m") | Out-Null
        
        # Write to console
        if ($outputBuilder.Length -gt 0) {
            [Console]::Write($outputBuilder.ToString())
        }
        
    } -ErrorHandler {
        param($Exception)
        Write-Log -Level Warning -Message "Render buffer error" -Data $Exception
    }
    
    # Update stats
    $stopwatch.Stop()
    $global:TuiState.RenderStats.LastFrameTime = $stopwatch.ElapsedMilliseconds
    $global:TuiState.RenderStats.FrameCount++
    $global:TuiState.RenderStats.TotalTime += $stopwatch.ElapsedMilliseconds
}

#endregion

#region Screen Management

function Push-Screen {
    param([PSCustomObject]$Screen)
    
    if (-not $Screen) { return }
    
    Invoke-WithErrorHandling -Component "TuiEngine.PushScreen" -Context @{ Operation = "PushScreen"; ScreenName = $Screen.Name } -ScriptBlock {
        Write-Log -Level Debug -Message "Pushing screen: $($Screen.Name)"
        
        # Handle focus cleanup
        # Ensure OnBlur exists as a ScriptMethod (or other callable member type)
        if ($global:TuiState.FocusedComponent -and $global:TuiState.FocusedComponent.PSObject.ScriptMethods['OnBlur']) {
            $global:TuiState.FocusedComponent.OnBlur() # Direct call, no & needed for ScriptMethod
        }
        
        # Exit current screen
        if ($global:TuiState.CurrentScreen) {
            # Ensure OnExit exists as a ScriptMethod (or other callable member type)
            if ($global:TuiState.CurrentScreen.PSObject.ScriptMethods['OnExit']) {
                $global:TuiState.CurrentScreen.OnExit() # Direct call, no & needed for ScriptMethod
            }
            $global:TuiState.ScreenStack.Push($global:TuiState.CurrentScreen)
        }
        
        # Set new screen
        $global:TuiState.CurrentScreen = $Screen
        $global:TuiState.FocusedComponent = $null
        
        # Initialize new screen
        # Ensure Init exists as a ScriptMethod (or other callable member type)
        if ($Screen.PSObject.ScriptMethods['Init']) {
            if ($Screen._services) {
                $Screen.Init -services $Screen._services # Direct call, no & needed for ScriptMethod
            } else {
                $Screen.Init() # Direct call, no & needed for ScriptMethod
            }
        }
        
        Request-TuiRefresh
        
        # Publish event (using native PowerShell eventing)
        New-Event -SourceIdentifier 'TuiEngine.System' -EventArguments @{ 
            EventType = 'ScreenPushed'
            ScreenName = $Screen.Name 
        }
        
    } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to push screen" -Data $Exception
        throw [Helios.ServiceInitializationException]::new( # FIX: Specify full type for custom exception
            "Failed to initialize screen '$($Exception.Context.ScreenName)'",
            @{
                FailingScreen = $Screen
                OriginalException = $Exception.OriginalError # FIX: Access OriginalError from HeliosException
            },
            $Exception # FIX: Pass original exception as inner
        )
    }
}

function Pop-Screen {
    if ($global:TuiState.ScreenStack.Count -eq 0) { return $false }
    
    Invoke-WithErrorHandling -Component "TuiEngine.PopScreen" -Context @{ Operation = "PopScreen" } -ScriptBlock {
        Write-Log -Level Debug -Message "Popping screen"
        
        # Handle focus cleanup
        # Ensure OnBlur exists as a ScriptMethod (or other callable member type)
        if ($global:TuiState.FocusedComponent -and $global:TuiState.FocusedComponent.PSObject.ScriptMethods['OnBlur']) {
            $global:TuiState.FocusedComponent.OnBlur() # Direct call, no & needed for ScriptMethod
        }
        
        # Store screen to exit
        $screenToExit = $global:TuiState.CurrentScreen
        
        # Pop new screen from stack
        $global:TuiState.CurrentScreen = $global:TuiState.ScreenStack.Pop()
        $global:TuiState.FocusedComponent = $null
        
        # Call lifecycle hooks
        # Ensure OnExit exists as a ScriptMethod (or other callable member type)
        if ($screenToExit -and $screenToExit.PSObject.ScriptMethods['OnExit']) {
            $screenToExit.OnExit() # Direct call, no & needed for ScriptMethod
        }
        
        # Ensure OnResume exists as a ScriptMethod (or other callable member type)
        if ($global:TuiState.CurrentScreen -and $global:TuiState.CurrentScreen.PSObject.ScriptMethods['OnResume']) {
            $global:TuiState.CurrentScreen.OnResume() # Direct call, no & needed for ScriptMethod
        }
        
        # Restore focus if tracked (Note: Set-ComponentFocus is internal to TuiEngine)
        if ($global:TuiState.CurrentScreen.LastFocusedComponent) {
            Set-ComponentFocus -Component $global:TuiState.CurrentScreen.LastFocusedComponent
        }
        
        Request-TuiRefresh
        
        # Publish event (using native PowerShell eventing)
        New-Event -SourceIdentifier 'TuiEngine.System' -EventArguments @{ 
            EventType = 'ScreenPopped'
            ScreenName = $global:TuiState.CurrentScreen.Name 
        }
        
        return $true
        
    } -ErrorHandler {
        param($Exception)
        Write-Log -Level Warning -Message "Pop screen error" -Data $Exception
        return $false
    }
}

#endregion

#region Buffer Operations

function Clear-BackBuffer {
    param([ConsoleColor]$BackgroundColor = [ConsoleColor]::Black)
    
    # Clear entire back buffer
    for ($y = 0; $y -lt $global:TuiState.BufferHeight; $y++) {
        for ($x = 0; $x -lt $global:TuiState.BufferWidth; $x++) {
            $global:TuiState.BackBuffer[$y, $x] = @{ 
                Char = ' '
                FG = [ConsoleColor]::White
                BG = $BackgroundColor 
            }
        }
    }
}

function Write-BufferString {
    param(
        [int]$X, 
        [int]$Y, 
        [string]$Text, 
        [ConsoleColor]$ForegroundColor = [ConsoleColor]::White, 
        [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black
    )
    
    if ($Y -lt 0 -or $Y -ge $global:TuiState.BufferHeight) { return }
    if ([string]::IsNullOrEmpty($Text)) { return }
    
    $currentX = $X
    foreach ($char in $Text.ToCharArray()) {
        if ($currentX -ge $global:TuiState.BufferWidth) { break }

        if ($currentX -ge 0) {
            $global:TuiState.BackBuffer[$Y, $currentX] = @{ 
                Char = $char
                FG = $ForegroundColor
                BG = $BackgroundColor 
            }
        }
        
        # Handle wide characters
        # Check if the character is considered wide (e.g., East Asian width)
        # This regex broadly covers CJK Unified Ideographs, Hangul Syllables, etc.
        if ($char -match '[\u1100-\u11FF\u2E80-\uA4CF\uAC00-\uD7A3\uF900-\uFAFF\uFE30-\uFE4F\uFF00-\uFFEF]') {
            $currentX += 2
            if ($currentX -lt $global:TuiState.BufferWidth -and $currentX -gt 0) {
                # Ensure the space for wide characters is also filled with the background color
                $global:TuiState.BackBuffer[$Y, $currentX - 1] = @{ 
                    Char = ' '
                    FG = $ForegroundColor # Use the same FG/BG for the blank space
                    BG = $BackgroundColor 
                }
            }
        } else {
            $currentX++
        }
    }
}

function Write-BufferBox {
    param(
        [int]$X, 
        [int]$Y, 
        [int]$Width, 
        [int]$Height, 
        [string]$BorderStyle = "Single", 
        [ConsoleColor]$BorderColor = [ConsoleColor]::White, 
        [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black, 
        [string]$Title = ""
    )
    
    # Defensive checks for dimensions
    if ($Width -lt 2 -or $Height -lt 2) { return } # Minimum size for a box with borders
    
    $borders = Get-BorderChars -Style $BorderStyle
    
    # Calculate effective coordinates considering bounds
    $startX = [Math]::Max(0, $X)
    $startY = [Math]::Max(0, $Y)
    $endX = [Math]::Min($global:TuiState.BufferWidth - 1, $X + $Width - 1)
    $endY = [Math]::Min($global:TuiState.BufferHeight - 1, $Y + $Height - 1)
    
    $actualWidth = $endX - $startX + 1
    $actualHeight = $endY - $startY + 1
    
    if ($actualWidth -lt 2 -or $actualHeight -lt 2) { return } # Box too small after clipping

    # Fill background first within the actual bounds
    for ($row = $startY; $row -le $endY; $row++) {
        for ($col = $startX; $col -le $endX; $col++) {
            $global:TuiState.BackBuffer[$row, $col] = @{ 
                Char = ' '; FG = [ConsoleColor]::White; BG = $BackgroundColor 
            }
        }
    }

    # Top border
    if ($actualHeight -ge 1) { # Ensure there's space for a top border
        if ($startX -le $endX) {
            Write-BufferString -X $startX -Y $startY -Text $borders.TopLeft -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
        }
        if ($startX + 1 -le $endX - 1) {
            Write-BufferString -X ($startX + 1) -Y $startY -Text ($borders.Horizontal * ($actualWidth - 2)) -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
        }
        if ($startX -le $endX -1) {
            Write-BufferString -X $endX -Y $startY -Text $borders.TopRight -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
        }
    }
    
    # Title if provided
    if ($Title) {
        $titleText = " $Title "
        $displayTitleWidth = $actualWidth - 2 # Space inside borders
        
        if ($titleText.Length -gt $displayTitleWidth) {
            $maxLength = [Math]::Max(0, $displayTitleWidth - 3) # Account for "..."
            if ($maxLength -ge 0) {
                $titleText = $titleText.Substring(0, $maxLength) + "..."
            } else {
                $titleText = "" # Not enough space for "..."
            }
        }
        
        $titleX = $startX + [Math]::Floor(($actualWidth - $titleText.Length) / 2)
        # Ensure title starts and ends within horizontal border area
        $titleX = [Math]::Max($startX + 1, [Math]::Min($endX - $titleText.Length, $titleX))

        Write-BufferString -X $titleX -Y $startY -Text $titleText `
            -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    
    # Sides and fill (from second row to second-to-last row)
    for ($i = 1; $i -lt ($actualHeight - 1); $i++) {
        $currentRowY = $startY + $i
        if ($currentRowY -gt $endY) { break } # Should not happen if loop limits are correct
        
        # Left vertical border
        Write-BufferString -X $startX -Y $currentRowY -Text $borders.Vertical `
            -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
        
        # Fill inner content area
        if ($actualWidth - 2 -gt 0) {
            Write-BufferString -X ($startX + 1) -Y $currentRowY -Text (' ' * ($actualWidth - 2)) `
                -BackgroundColor $BackgroundColor
        }
        
        # Right vertical border
        Write-BufferString -X $endX -Y $currentRowY -Text $borders.Vertical `
            -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    
    # Bottom border
    if ($actualHeight -ge 1) { # Ensure there's space for a bottom border
        $bottomY = $endY
        if ($bottomY -ge $startY) { # Ensure bottomY is valid
            if ($startX -le $endX) {
                Write-BufferString -X $startX -Y $bottomY `
                    -Text $borders.BottomLeft -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
            }
            if ($startX + 1 -le $endX - 1) {
                Write-BufferString -X ($startX + 1) -Y $bottomY `
                    -Text ($borders.Horizontal * ($actualWidth - 2)) -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
            }
            if ($startX -le $endX -1) {
                Write-BufferString -X $endX -Y $bottomY `
                    -Text $borders.BottomRight -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
            }
        }
    }
}

#endregion

#region Component Focus Management

function Set-ComponentFocus {
    param([PSCustomObject]$Component)
    
    Invoke-WithErrorHandling -Component "TuiEngine.SetFocus" -Context @{ Operation = "SetComponentFocus"; ComponentName = $Component?.Name } -ScriptBlock {
        # Blur current focused component
        if ($global:TuiState.FocusedComponent -and 
            $global:TuiState.FocusedComponent -ne $Component) {
            $global:TuiState.FocusedComponent.IsFocused = $false
            # Ensure OnBlur exists as a ScriptMethod (or other callable member type)
            if ($global:TuiState.FocusedComponent.PSObject.ScriptMethods['OnBlur']) {
                $global:TuiState.FocusedComponent.OnBlur() # Direct call, no & needed for ScriptMethod
            }
        }

        # Clear focus if null component
        if ($null -eq $Component) {
            $global:TuiState.FocusedComponent = $null
            Request-TuiRefresh
            return
        }

        # Validate component can be focused
        if ($Component.PSObject.Properties['IsFocusable'] -and $Component.IsFocusable -ne $true -or 
            $Component.PSObject.Properties['Visible'] -and $Component.Visible -ne $true) {
            Write-Log -Level Debug -Message "Set-ComponentFocus ignored for non-focusable or invisible component '$($Component.Name)'"
            return
        }

        # Set new focus
        $global:TuiState.FocusedComponent = $Component
        $Component.IsFocused = $true
        
        # Ensure OnFocus exists as a ScriptMethod (or other callable member type)
        if ($Component.PSObject.ScriptMethods['OnFocus']) {
            $Component.OnFocus() # Direct call, no & needed for ScriptMethod
        }
        
        Request-TuiRefresh
        
    } -ErrorHandler {
        param($Exception)
        Write-Log -Level Warning -Message "Set focus error" -Data $Exception
    }
}

function Handle-TabNavigation {
    param([bool]$Reverse = $false)
    
    Invoke-WithErrorHandling -Component "TuiEngine.TabNavigation" -Context @{ Operation = "HandleTabNavigation"; Reverse = $Reverse } -ScriptBlock {
        $currentScreen = $global:TuiState.CurrentScreen
        if (-not $currentScreen) { return }

        $focusable = @() # Local variable for this function call
        
        $findFocusable = {
            param($component)
            # Ensure IsFocusable and Visible properties exist before checking them
            if ($component -and 
                $component.PSObject.Properties['IsFocusable'] -and $component.IsFocusable -eq $true -and 
                $component.PSObject.Properties['Visible'] -and $component.Visible -eq $true) {
                $focusable += $component 
            }
            if ($component -and $component.PSObject.Properties['Children'] -and $component.Children) {
                foreach ($child in $component.Children) {
                    & $findFocusable -component $child
                }
            }
        }
        
        # Start from screen's RootPanel (if available) or children directly
        # Changed logic to always start traversal from CurrentScreen.RootPanel, consistent with focus-manager and dialog-system
        if ($currentScreen.RootPanel) {
            & $findFocusable -component $currentScreen.RootPanel
        } elseif ($currentScreen.Children) { # Fallback for screens without a dedicated RootPanel
            foreach ($child in $currentScreen.Children) {
                & $findFocusable -component $child
            }
        }

        if ($focusable.Count -eq 0) {
            Write-Log -Level Debug -Message "No focusable components found on current screen for tab navigation."
            return
        }

        # Sort by Y then X for a natural tab order
        $sortedFocusable = $focusable | Sort-Object { $_.Y }, { $_.X }

        # Find current index
        $currentIndex = [array]::IndexOf($sortedFocusable, $global:TuiState.FocusedComponent)
        
        # Calculate next index
        $nextIndex = 0
        if ($currentIndex -ne -1) {
            $direction = if ($Reverse) { -1 } else { 1 }
            $nextIndex = ($currentIndex + $direction + $sortedFocusable.Count) % $sortedFocusable.Count
        } else {
            # If no component is currently focused, start from the beginning (or end if reversing)
            $nextIndex = if ($Reverse) { $sortedFocusable.Count - 1 } else { 0 }
        }

        Set-ComponentFocus -Component $sortedFocusable[$nextIndex]
        
    } -ErrorHandler {
        param($Exception)
        Write-Log -Level Warning -Message "Tab navigation error" -Data $Exception
    }
}

function Clear-ComponentFocus {
    Set-ComponentFocus -Component $null
}

#endregion

#region Utility Functions

function Request-TuiRefresh {
    $global:TuiState.IsDirty = $true
}

function Get-BorderChars {
    param([string]$Style)
    
    $styles = @{
        Single = @{
            TopLeft = ''; TopRight = ''
            BottomLeft = ''; BottomRight = ''
            Horizontal = ''; Vertical = ''
        }
        Double = @{
            TopLeft = ''; TopRight = ''
            BottomLeft = ''; BottomRight = ''
            Horizontal = ''; Vertical = ''
        }
        Rounded = @{
            TopLeft = ''; TopRight = ''
            BottomLeft = ''; BottomRight = ''
            Horizontal = ''; Vertical = ''
        }
    }
    
    if ($styles.ContainsKey($Style)) {
        return $styles[$Style]
    } else {
        return $styles.Single
    }
}

function Get-AnsiColorCode {
    param(
        [ConsoleColor]$Color,
        [bool]$IsBackground
    )
    
    $map = @{
        Black = 30; DarkBlue = 34; DarkGreen = 32; DarkCyan = 36
        DarkRed = 31; DarkMagenta = 35; DarkYellow = 33; Gray = 37
        DarkGray = 90; Blue = 94; Green = 92; Cyan = 96
        Red = 91; Magenta = 95; Yellow = 93; White = 97
    }
    
    $code = $map[$Color.ToString()]
    if ($IsBackground) {
        return $code + 10
    } else {
        return $code
    }
}

function Get-WordWrappedLines {
    param(
        [string]$Text,
        [int]$MaxWidth
    )
    
    if ([string]::IsNullOrEmpty($Text) -or $MaxWidth -le 0) { return @() }
    
    $lines = @()
    # Split by whitespace, but keep original spaces for reconstruction if possible
    # This regex splits by one or more whitespace characters, so original spacing is lost
    $words = $Text -split '\s+' | Where-Object { -not [string]::IsNullOrWhiteSpace($_) } # Remove empty strings from split
    
    $sb = New-Object System.Text.StringBuilder
    
    foreach ($word in $words) {
        if ($sb.Length -eq 0) {
            [void]$sb.Append($word)
        } elseif (($sb.Length + 1 + $word.Length) -le $MaxWidth) {
            [void]$sb.Append(' ')
            [void]$sb.Append($word)
        } else {
            # If adding the next word with a space exceeds max width
            $lines += $sb.ToString()
            [void]$sb.Clear()
            [void]$sb.Append($word)
        }
    }
    
    if ($sb.Length -gt 0) {
        $lines += $sb.ToString()
    }
    
    return $lines
}

#endregion

#region Cleanup

function Cleanup-TuiEngine {
    Invoke-WithErrorHandling -Component "TuiEngine.Cleanup" -Context @{ Operation = "Cleanup" } -ScriptBlock {
        Write-Log -Level Info -Message "Cleaning up TUI Engine"
        
        # Cancel input thread
        if ($global:TuiState.CancellationTokenSource) {
            try {
                if (-not $global:TuiState.CancellationTokenSource.IsCancellationRequested) {
                    $global:TuiState.CancellationTokenSource.Cancel()
                }
            } catch {}
        }

        # Clean up PowerShell instance
        if ($global:TuiState.InputPowerShell) {
            if ($global:TuiState.InputAsyncResult) {
                try { $global:TuiState.InputPowerShell.EndInvoke($global:TuiState.InputAsyncResult) } catch {}
            }
            try { $global:TuiState.InputPowerShell.Dispose() } catch {}
        }
        
        # Clean up runspace
        if ($global:TuiState.InputRunspace) {
            try { $global:TuiState.InputRunspace.Dispose() } catch {}
        }
        
        # Dispose cancellation token
        if ($global:TuiState.CancellationTokenSource) {
            try { $global:TuiState.CancellationTokenSource.Dispose() } catch {}
        }

        # Clean up event handlers
        Cleanup-EventHandlers
        
        # Reset console
        try {
            if ([System.Environment]::UserInteractive) {
                [Console]::Write("$([char]27)[0m")
                [Console]::CursorVisible = $true
                [Console]::Clear()
                [Console]::ResetColor()
            }
        } catch {}
        
    } -ErrorHandler {
        param($Exception)
        Write-Log -Level Warning -Message "Cleanup error" -Data $Exception
    }
}

function Cleanup-EventHandlers {
    if (-not $global:TuiState.EventHandlers) { return }

    foreach ($handlerId in $global:TuiState.EventHandlers.Values) {
        try { 
            Unregister-Event -SubscriptionId $handlerId -ErrorAction SilentlyContinue
        } catch {}
    }
    
    $global:TuiState.EventHandlers.Clear()
}

#endregion

# Export functions
Export-ModuleMember -Function @(
    'Initialize-TuiEngine',
    'Start-TuiLoop',
    'Request-TuiRefresh',
    'Push-Screen',
    'Pop-Screen',
    'Write-BufferString',
    'Write-BufferBox',
    'Clear-BackBuffer',
    'Set-ComponentFocus',
    'Clear-ComponentFocus',
    'Handle-TabNavigation',
    'Get-BorderChars',
    'Get-AnsiColorCode',
    'Get-WordWrappedLines',
    'Render-Frame',
    'Cleanup-TuiEngine'
) -Variable @('TuiState')


####\screens\dashboard-screen.psm1
####\screens\dashboard-screen.psm1
# FILE: screens/dashboard-screen.psm1
# PURPOSE: Provides the main dashboard screen for PMC Terminal v5.
#          This screen offers navigation to other parts of the application
#          using a simple menu of Helios buttons. It adheres to the PowerShell-First
#          architectural principles, using PSCustomObject for the screen and
#          direct service method calls for interactions.

using module "$PSScriptRoot/../modules/logger.psm1"
using module "$PSScriptRoot/../modules/exceptions.psm1"
using module "$PSScriptRoot/../ui/helios-components.psm1"
using module "$PSScriptRoot/../ui/helios-panels.psm1"
# Assuming tui-engine provides Get-ThemeColor, Request-TuiRefresh, Request-Focus
# and other core TUI functions.

function Get-HeliosDashboardScreen {
    <#
    .SYNOPSIS
        Creates a new Dashboard screen object for PMC Terminal v5.
    .DESCRIPTION
        This factory function constructs a [PSCustomObject] representing the dashboard screen.
        It sets up the UI layout using Helios panels and components, defines event handlers
        for user interactions (button clicks, key presses), and manages navigation via
        the NavigationService. It's designed to be minimal, focusing on navigation
        to other primary screens like Task Management.
    .PARAMETER Services
        A PSCustomObject containing references to all initialized application services
        (e.g., Task, Navigation, Keybindings). This is crucial for dependency injection.
    .OUTPUTS
        [PSCustomObject] The initialized screen object.
    #>
    [CmdletBinding()]
    [OutputType([PSCustomObject])]
    param(
        [Parameter(Mandatory = $true)]
        [PSCustomObject]$Services # Expecting a PSCustomObject for services
    )

    Invoke-WithErrorHandling -Component "Get-HeliosDashboardScreen" -Context @{} -ScriptBlock {
        Write-Log -Level Trace -Message "Creating Helios Dashboard Screen object."

        # Defensive: Ensure Services object is valid and contains required services
        if (-not $Services) {
            throw "Services object must be provided to Get-HeliosDashboardScreen."
        }
        if (-not $Services.Navigation) {
            throw "NavigationService is missing from the provided Services object."
        }
        if (-not $Services.Keybindings) {
            throw "KeybindingService is missing from the provided Services object."
        }

        $screen = [PSCustomObject]@{
            Name                  = "HeliosDashboardScreen"
            _services             = $Services # Store the services for later use
            _eventSubscriptions   = [System.Collections.ArrayList]::new() # For future event cleanup
            _rootPanel            = $null
            _menuButtons          = [System.Collections.ArrayList]::new() # To manage focus
            _focusedButtonIndex   = 0
            Visible               = $true
            ZIndex                = 0
        }

        #region Private Helper Methods (attached to $screen)

        $buildUiScript = {
            Invoke-WithErrorHandling -Component "$($this.Name)._BuildUI" -Context @{} -ScriptBlock {
                Write-Log -Level Debug -Message "Building UI for Dashboard Screen."

                # Define menu items with their paths and display text
                # Only /task is functional for now, others are placeholders
                $menuItems = @(
                    @{ Text = "1. View Tasks"; Path = "/task"; Enabled = $true }
                    @{ Text = "2. New Time Entry"; Path = "/time-entry"; Enabled = $false }
                    @{ Text = "3. Start Timer"; Path = "/timer-start"; Enabled = $false }
                    @{ Text = "4. View Projects"; Path = "/project"; Enabled = $false }
                    @{ Text = "5. Reports"; Path = "/reports"; Enabled = $false }
                    @{ Text = "6. Settings"; Path = "/settings"; Enabled = $false }
                    @{ Text = "0. Exit Terminal"; Path = "/exit"; Enabled = $true }
                )

                # Create the main root panel for the screen
                $this._rootPanel = New-HeliosStackPanel -Props @{
                    Name        = "DashboardRootPanel"
                    X           = 2
                    Y           = 2
                    Width       = [Math]::Max(60, ($global:TuiState.BufferWidth - 4))
                    Height      = [Math]::Max(20, ($global:TuiState.BufferHeight - 4))
                    ShowBorder  = $true
                    Title       = " PMC Terminal v5 - Main Menu "
                    Orientation = "Vertical"
                    Spacing     = 1
                    Padding     = 2
                    BackgroundColor = (Get-ThemeColor "Background")
                }
                if (-not $this._rootPanel) { throw "Failed to create DashboardRootPanel." }

                # Add an instruction label
                $instructionLabel = New-HeliosLabel -Props @{
                    Name = "InstructionLabel"
                    Text = "Use Arrow Keys, Number Keys, or Enter to Navigate"
                    Width = 60
                    Height = 1
                    ForegroundColor = (Get-ThemeColor "Subtle")
                }
                $this._rootPanel.AddChild($instructionLabel)

                # Create a panel for the menu buttons
                $menuPanel = New-HeliosStackPanel -Props @{
                    Name        = "MenuButtonPanel"
                    Orientation = "Vertical"
                    Spacing     = 1
                    Padding     = 1
                    Width       = $this._rootPanel.Width - 4 # Adjust width for padding
                    Height      = ($menuItems.Count * 3) + 2 # Estimate height (3 lines per button + padding)
                }
                $this._rootPanel.AddChild($menuPanel)

                # Create buttons for each menu item
                foreach ($item in $menuItems) {
                    $buttonText = $item.Text
                    $buttonPath = $item.Path
                    $buttonName = "MenuButton_" + ($buttonPath -replace '[^a-zA-Z0-9]', '')
                    $buttonEnabled = $item.Enabled ?? $true # Default to enabled

                    # Capture $this and $item for the scriptblock closure
                    $currentScreen = $this
                    $currentItem = $item

                    $button = New-HeliosButton -Props @{
                        Name        = $buttonName
                        Text        = $buttonText
                        Width       = $menuPanel.Width - 2 # Button width within menu panel
                        Height      = 3
                        IsFocusable = $buttonEnabled # Only focusable if enabled
                        OnClick     = {
                            Invoke-WithErrorHandling -Component "$($currentScreen.Name).MenuButton.OnClick" -Context @{ Path = $currentItem.Path } -ScriptBlock {
                                if (-not $buttonEnabled) {
                                    Write-Log -Level Info -Message "Attempted to click disabled button: $($currentItem.Path)"
                                    # No notification needed as per requirements
                                    return
                                }
                                Write-Log -Level Info -Message "Dashboard button clicked: $($currentItem.Path)"
                                if ($currentItem.Path -eq "/exit") {
                                    Write-Log -Level Info -Message "Exit requested from Dashboard."
                                    # Assuming Stop-TuiEngine function is available globally for application shutdown
                                    if (Get-Command Stop-TuiEngine -ErrorAction SilentlyContinue) {
                                        Stop-TuiEngine
                                    }
                                } else {
                                    # Direct method call to NavigationService
                                    $currentScreen._services.Navigation.GoTo($currentItem.Path, $currentScreen._services)
                                }
                            }
                        }
                    }
                    $menuPanel.AddChild($button)
                    [void]$this._menuButtons.Add($button) # Add to list for focus management
                }

                # Add a status label at the bottom
                $statusLabel = New-HeliosLabel -Props @{
                    Name = "StatusLabel"
                    Text = "Press ESC to return to this menu from any screen"
                    Width = 60
                    Height = 1
                    ForegroundColor = (Get-ThemeColor "Subtle")
                }
                $this._rootPanel.AddChild($statusLabel)

                Write-Log -Level Debug -Message "Dashboard UI built successfully."
            }
        }
        $screen | Add-Member -MemberType ScriptMethod -Name _BuildUI -Value $buildUiScript

        $setFocusToButton = {
            param([int]$deltaIndex) # deltaIndex: +1 for next, -1 for previous
            Invoke-WithErrorHandling -Component "$($this.Name)._SetFocusToButton" -Context @{ DeltaIndex = $deltaIndex } -ScriptBlock {
                if ($this._menuButtons.Count -eq 0) { return }

                # Get only the currently focusable buttons
                # Using Where-Object and Select-Object to ensure we work with an array of focusable buttons
                $focusableButtons = ($this._menuButtons | Where-Object { $_.IsFocusable }).ToArray()
                if ($focusableButtons.Count -eq 0) {
                    Write-Log -Level Warn -Message "No focusable buttons found on dashboard."
                    return
                }

                # Find the current focused button's index within the *focusable* list
                $currentFocusedButton = if ($this._focusedButtonIndex -ge 0 -and $this._focusedButtonIndex -lt $this._menuButtons.Count) { $this._menuButtons[$this._focusedButtonIndex] } else { $null }
                $currentFocusableIndex = -1
                for ($i = 0; $i -lt $focusableButtons.Count; $i++) {
                    if ($focusableButtons[$i] -eq $currentFocusedButton) {
                        $currentFocusableIndex = $i
                        break
                    }
                }
                
                # If no button was previously focused or the focused one is no longer focusable, default to first focusable
                if ($currentFocusableIndex -eq -1) {
                    $currentFocusableIndex = 0
                }

                # Calculate new focusable index, wrapping around
                $newFocusableIndex = ($currentFocusableIndex + $deltaIndex + $focusableButtons.Count) % $focusableButtons.Count

                # Get the actual button object to focus
                $newButton = $focusableButtons[$newFocusableIndex]

                # If the new button is the same as the old, no change needed
                if ($newButton -eq $currentFocusedButton) { return }

                # Remove focus from old button
                if ($currentFocusedButton -and $currentFocusedButton.PSObject.Properties.Contains('IsFocused')) {
                    $currentFocusedButton.IsFocused = $false
                }

                # Set focus to new button
                if ($newButton -and $newButton.PSObject.Properties.Contains('IsFocused')) {
                    $newButton.IsFocused = $true
                    # Inform TUI engine about new focus via Request-Focus
                    # Request-Focus is provided by focus-manager.psm1, imported by dialog-system.psm1 (which is imported by Start-PMCTerminal)
                    # and also by tui-engine.psm1 directly, so it should be available.
                    Request-Focus -Component $newButton -Reason 'DashboardMenuNavigation'
                    
                    # Update _focusedButtonIndex to the index of the actual button in the _menuButtons list
                    # This ensures _focusedButtonIndex always refers to the correct item in the full list,
                    # even if some items are not focusable.
                    $this._focusedButtonIndex = $this._menuButtons.IndexOf($newButton)
                    Write-Log -Level Trace -Message "Focus set to button index $($this._focusedButtonIndex): $($newButton.Name)"
                }
                Request-TuiRefresh
            }
        }
        $screen | Add-Member -MemberType ScriptMethod -Name _SetFocusToButton -Value $setFocusToButton

        #endregion

        #region Public Methods (Screen Lifecycle)

        $initScript = {
            param(
                [Parameter(Mandatory = $true)]
                [PSCustomObject]$services # Services are passed during screen creation, not Init
            )
            Invoke-WithErrorHandling -Component "$($this.Name).Init" -Context @{} -ScriptBlock {
                Write-Log -Level Info -Message "Initializing Dashboard Screen."
                
                # Services are already set in the factory. This Init method is called by TUI Engine
                # when the screen is pushed. Use it for any logic that needs to run just as the screen becomes active.
                
                # No specific data to refresh for this minimal dashboard, but keep the pattern
                # $this._RefreshData() 
                
                Write-Log -Level Info -Message "Dashboard Screen initialized successfully."
            }
        }
        $screen | Add-Member -MemberType ScriptMethod -Name Init -Value $initScript

        $onEnterScript = {
            Invoke-WithErrorHandling -Component "$($this.Name).OnEnter" -Context @{} -ScriptBlock {
                Write-Log -Level Info -Message "Dashboard OnEnter: Setting initial focus."
                # Set focus to the first focusable button (delta 0 from current, effectively first)
                $this._SetFocusToButton(0) 
                Request-TuiRefresh
            }
        }
        $screen | Add-Member -MemberType ScriptMethod -Name OnEnter -Value $onEnterScript

        $onExitScript = {
            Invoke-WithErrorHandling -Component "$($this.Name).OnExit" -Context @{} -ScriptBlock {
                Write-Log -Level Info -Message "Exiting Dashboard Screen. Cleaning up subscriptions."
                # Clean up any event subscriptions (pattern, even if none for this minimal screen)
                foreach ($sub in $this._eventSubscriptions) {
                    try {
                        Unregister-Event -SubscriptionId $sub.Id
                        Write-Log -Level Debug -Message "Unregistered event subscription: $($sub.Id)"
                    } catch {
                        Write-Log -Level Warn -Message "Failed to unregister event subscription $($sub.Id): $($_.Exception.Message)"
                    }
                }
                $this._eventSubscriptions.Clear()
                Write-Log -Level Info -Message "Dashboard Screen OnExit completed."
            }
        }
        $screen | Add-Member -MemberType ScriptMethod -Name OnExit -Value $onExitScript

        $handleInputScript = {
            param(
                [Parameter(Mandatory = $true)]
                [System.Management.Automation.Host.KeyInfo]$Key
            )
            Invoke-WithErrorHandling -Component "$($this.Name).HandleInput" -Context @{ Key = $Key.Key } -ScriptBlock {
                $keybindingSvc = $this._services.Keybindings
                $handled = $false

                # Handle navigation keys for menu buttons
                if ($keybindingSvc.IsAction('nav.down', $Key)) {
                    $this._SetFocusToButton(1) # Move to next focusable button
                    $handled = $true
                } elseif ($keybindingSvc.IsAction('nav.up', $Key)) {
                    $this._SetFocusToButton(-1) # Move to previous focusable button
                    $handled = $true
                } elseif ($keybindingSvc.IsAction('form.submit', $Key)) { # Enter key
                    # Trigger OnClick for the focused button
                    $focusedButton = $this._menuButtons[$this._focusedButtonIndex]
                    if ($focusedButton -and $focusedButton.OnClick) {
                        # Buttons handle their own OnClick via their internal HandleInput on Enter/Space
                        # So, just calling the OnClick here might be redundant if the button is focused.
                        # However, for consistency with number key handling, we can call it.
                        $focusedButton.OnClick()
                        $handled = $true
                    }
                } elseif ($Key.Character -match '^[0-9]$') {
                    # Handle number key shortcuts
                    $numericInput = [int]$Key.Character.ToString()
                    $targetButton = $null

                    # Find the button by its number prefix (e.g., "1. View Tasks")
                    foreach ($button in $this._menuButtons) {
                        if ($button.IsFocusable -and $button.Text -like "$numericInput.*") {
                            $targetButton = $button
                            break
                        }
                    }

                    if ($targetButton -and $targetButton.OnClick) {
                        # Directly call the OnClick of the target button
                        $targetButton.OnClick()
                        $handled = $true
                    }
                }
                
                # Note: The TUI engine handles global keys like ESC (app.back) for navigation.
                # The dashboard, being a root screen, doesn't necessarily need to pop itself.
                # If it were a sub-screen, it would use $this._services.Navigation.Back() here.

                return $handled
            } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "Dashboard HandleInput error: $($Exception.Message)" -Data $Exception.Context
                return $false
            }
        }
        $screen | Add-Member -MemberType ScriptMethod -Name HandleInput -Value $handleInputScript

        $renderScript = {
            Invoke-WithErrorHandling -Component "$($this.Name).Render" -Context @{} -ScriptBlock {
                if ($this._rootPanel -and $this._rootPanel.PSObject.Methods.Contains('Render')) {
                    $this._rootPanel.Render()
                } else {
                    Write-Log -Level Warn -Message "Dashboard Render: Root panel not found or missing Render method."
                }
            } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "Dashboard Render error: $($Exception.Message)" -Data $Exception.Context
            }
        }
        $screen | Add-Member -MemberType ScriptMethod -Name Render -Value $renderScript

        #endregion

        # Build the UI components immediately when the screen object is created
        # This ensures _rootPanel is populated before the screen object is returned,
        # making the RootPanel property available to the TUI engine and focus manager.
        $screen._BuildUI()

        # Expose the root panel for the TUI engine and focus manager as a NoteProperty.
        # Now that _BuildUI has been called, $screen._rootPanel will be a valid object.
        $screen.PSObject.Properties.Add([psnoteproperty]::new('RootPanel', $screen._rootPanel))

        return $screen
    } -ErrorHandler {
        param($Exception)
        Write-Log -Level Fatal -Message "Failed to create Helios Dashboard Screen: $($Exception.Message)" -Data $Exception.Context
        throw # Re-throw to main application error handler
    }
}

Export-ModuleMember -Function Get-HeliosDashboardScreen


####\screens\task-screen.psm1
#
# MODULE: screens/task-screen.psm1
#
# PURPOSE:
#   Provides the user interface for managing tasks. This screen allows users to
#   view a list of all tasks, create new tasks, and edit existing tasks. It follows
#   a two-panel design, switching between a task list view and a task entry form.
#   It interacts directly with the TaskService to manage state and subscribes to
#   service events to automatically refresh its display.
#

using module "$PSScriptRoot/../modules/logger.psm1"
using module "$PSScriptRoot/../modules/exceptions.psm1"
using module "$PSScriptRoot/../ui/helios-components.psm1"
using module "$PSScriptRoot/../ui/helios-panels.psm1"
# NOTE: The 'New-HeliosDataTable' component is assumed to exist in the component library
# with the following API:
# - Props: Columns (array), Data (array), OnAction (scriptblock)
# - Properties: SelectedItem
# - Methods: UpdateData([array]$newData)

#region Factory Function

function Get-HeliosTaskScreen {
    <#
    .SYNOPSIS
        Creates a new Task Management screen object.
    .DESCRIPTION
        This factory function builds and returns a PSCustomObject representing the task screen,
        complete with its UI layout, methods, and internal state, ready to be pushed
        onto the TUI engine's screen stack.
    .OUTPUTS
        [PSCustomObject] The initialized screen object.
    #>
    [CmdletBinding()]
    [OutputType([PSCustomObject])]
    param()

    Write-Log -Level Trace -Message "Creating Helios Task Screen object."

    $screen = [PSCustomObject]@{
        Name                  = "HeliosTaskScreen"
        _services             = $null
        _eventSubscriptions   = [System.Collections.ArrayList]@()
        _rootPanel            = $null
        _listPanel            = $null
        _formPanel            = $null
        _dataTable            = $null
        _formFields           = @{}
        _editingTask          = $null # Stores the task being edited, or $null for a new task
    }

    #================================================================================
    # Private Methods
    #================================================================================

    $buildUiScript = {
        Write-Log -Level Debug -Message "Building UI for Task Screen."

        # --- List Panel (Visible by default) ---
        $this._dataTable = New-HeliosDataTable -Props @{
            Name    = "TaskDataTable"
            Columns = @(
                @{ Name = "Title";       Expression = { $_.title };       Width = 40 },
                @{ Name = "Status";      Expression = { if ($_.completed) { "Done" } else { "Pending" } }; Width = 10 },
                @{ Name = "Priority";    Expression = { $_.priority };    Width = 10 },
                @{ Name = "Due Date";    Expression = { if ($_.due_date) { Get-Date($_.due_date) -format 'yyyy-MM-dd' } else { 'N/A' } }; Width = 12 }
            )
            # The 'OnAction' handler is triggered by keys like Enter, 'e', 'd' within the component
            OnAction = {
                param($action, $item)
                switch ($action) {
                    'select' { $this._EditTask($item) }
                    'delete' { $this._DeleteTask($item) }
                }
            }
        }

        $listFooter = New-HeliosLabel -Props @{
            Name = "TaskListFooter"
            Text = "N: New | E: Edit | Del: Delete | Esc: Back"
        }

        $this._listPanel = New-HeliosStackPanel -Props @{
            Name        = "TaskListPanel"
            Orientation = 'Vertical'
            Spacing     = 1
        }
        $this._listPanel.AddChild($this._dataTable, @{ 'Grid.Row' = 0 })
        $this._listPanel.AddChild($listFooter, @{ 'Grid.Row' = 1 })


        # --- Form Panel (Hidden by default) ---
        $formTitleLabel = New-HeliosLabel -Props @{ Text = "Title:" }
        $formTitleBox = New-HeliosTextBox -Props @{ Name = "TaskFormTitle"; Width = 50 }
        $this._formFields.Title = $formTitleBox

        $formDescLabel = New-HeliosLabel -Props @{ Text = "Description:" }
        $formDescBox = New-HeliosTextArea -Props @{ Name = "TaskFormDescription"; Width = 50; Height = 5 }
        $this._formFields.Description = $formDescBox

        $saveButton = New-HeliosButton -Props @{
            Name    = "TaskFormSaveButton"
            Text    = "Save"
            Width   = 8
            OnClick = { $this._SaveTask() }
        }
        $cancelButton = New-HeliosButton -Props @{
            Name    = "TaskFormCancelButton"
            Text    = "Cancel"
            Width   = 10
            OnClick = { $this._ShowListPanel() }
        }
        $buttonPanel = New-HeliosStackPanel -Props @{
            Orientation         = 'Horizontal'
            Spacing             = 2
            HorizontalAlignment = 'Left'
        }
        $buttonPanel.AddChild($saveButton)
        $buttonPanel.AddChild($cancelButton)

        $this._formPanel = New-HeliosStackPanel -Props @{
            Name       = "TaskFormPanel"
            Spacing    = 1
            Visible    = $false
            ShowBorder = $true
            Title      = " Edit Task "
            Padding    = 1
        }
        $this._formPanel.AddChild($formTitleLabel)
        $this._formPanel.AddChild($formTitleBox)
        $this._formPanel.AddChild($formDescLabel)
        $this._formPanel.AddChild($formDescBox)
        $this._formPanel.AddChild($buttonPanel)


        # --- Root Panel ---
        $this._rootPanel = New-HeliosGridPanel -Props @{
            Name              = "TaskScreenRoot"
            Width             = $global:TuiState.BufferWidth
            Height            = $global:TuiState.BufferHeight
            RowDefinitions    = @("1*", "Auto") # DataTable gets remaining space, footer is auto-sized
            ColumnDefinitions = @("1*")
            Padding           = 1
        }
        # Add both panels to the root. Their visibility will determine which is shown.
        $this._rootPanel.AddChild($this._listPanel)
        $this._rootPanel.AddChild($this._formPanel)
    }
    $screen | Add-Member -MemberType ScriptMethod -Name _BuildUI -Value $buildUiScript

    $refreshTaskListScript = {
        Invoke-WithErrorHandling -Component "$($this.Name)._RefreshTaskList" -Context @{} -ScriptBlock {
            Write-Log -Level Debug -Message "Refreshing task list data on screen."
            $tasks = $this._services.Task.GetTasks()
            $this._dataTable.UpdateData($tasks)
            Request-TuiRefresh
        }
    }
    $screen | Add-Member -MemberType ScriptMethod -Name _RefreshTaskList -Value $refreshTaskListScript

    $showListPanelScript = {
        Invoke-WithErrorHandling -Component "$($this.Name)._ShowListPanel" -Context @{} -ScriptBlock {
            Write-Log -Level Debug -Message "Switching to Task List Panel."
            $this._formPanel.Hide()
            $this._listPanel.Show()
            Request-Focus -Component $this._dataTable
            Request-TuiRefresh
        }
    }
    $screen | Add-Member -MemberType ScriptMethod -Name _ShowListPanel -Value $showListPanelScript

    $showFormPanelScript = {
        Invoke-WithErrorHandling -Component "$($this.Name)._ShowFormPanel" -Context @{} -ScriptBlock {
            Write-Log -Level Debug -Message "Switching to Task Form Panel."
            $this._listPanel.Hide()
            $this._formPanel.Show()

            # Populate form based on whether we are editing or creating a new task
            if ($this._editingTask) {
                $this._formPanel.Title = " Edit Task "
                $this._formFields.Title.Text = $this._editingTask.title
                $this._formFields.Description.Text = $this._editingTask.description
            }
            else {
                $this._formPanel.Title = " New Task "
                $this._formFields.Title.Text = ""
                $this._formFields.Description.Text = ""
            }
            # The description is a multi-line text area, we need to update its internal lines as well.
            $this._formFields.Description.Lines = $this._formFields.Description.Text -split "`n"

            Request-Focus -Component $this._formFields.Title
            Request-TuiRefresh
        }
    }
    $screen | Add-Member -MemberType ScriptMethod -Name _ShowFormPanel -Value $showFormPanelScript

    $newTaskScript = {
        Invoke-WithErrorHandling -Component "$($this.Name)._NewTask" -Context @{} -ScriptBlock {
            Write-Log -Level Info -Message "User initiated new task entry."
            $this._editingTask = $null
            $this._ShowFormPanel()
        }
    }
    $screen | Add-Member -MemberType ScriptMethod -Name _NewTask -Value $newTaskScript

    $editTaskScript = {
        param([hashtable]$Task)
        Invoke-WithErrorHandling -Component "$($this.Name)._EditTask" -Context @{ TaskId = $Task.id } -ScriptBlock {
            $taskToEdit = $Task
            if (-not $taskToEdit) {
                $taskToEdit = $this._dataTable.SelectedItem
            }
            if (-not $taskToEdit) {
                Write-Log -Level Warn -Message "Edit action triggered, but no task is selected."
                # Optionally show an alert dialog here
                return
            }
            Write-Log -Level Info -Message "User initiated edit for task: $($taskToEdit.id)"
            $this._editingTask = $taskToEdit
            $this._ShowFormPanel()
        }
    }
    $screen | Add-Member -MemberType ScriptMethod -Name _EditTask -Value $editTaskScript

    $deleteTaskScript = {
        param([hashtable]$Task)
        Invoke-WithErrorHandling -Component "$($this.Name)._DeleteTask" -Context @{ TaskId = $Task.id } -ScriptBlock {
            $taskToDelete = $Task
            if (-not $taskToDelete) {
                $taskToDelete = $this._dataTable.SelectedItem
            }
            if (-not $taskToDelete) {
                Write-Log -Level Warn -Message "Delete action triggered, but no task is selected."
                return
            }

            Show-ConfirmDialog -Title "Delete Task" `
                -Message "Are you sure you want to delete task '$($taskToDelete.title)'?" `
                -OnConfirm {
                    Write-Log -Level Info -Message "User confirmed deletion of task: $($taskToDelete.id)"
                    $this._services.Task.DeleteTask($taskToDelete.id)
                    # The UI will refresh automatically via the Tasks.Changed event
                }
        }
    }
    $screen | Add-Member -MemberType ScriptMethod -Name _DeleteTask -Value $deleteTaskScript

    $saveTaskScript = {
        Invoke-WithErrorHandling -Component "$($this.Name)._SaveTask" -Context @{ IsEditing = ($null -ne $this._editingTask) } -ScriptBlock {
            $updates = @{
                Title       = $this._formFields.Title.Text
                Description = $this._formFields.Description.Text
            }

            if ($this._editingTask) {
                # Update existing task
                Write-Log -Level Info -Message "Saving updates for task: $($this._editingTask.id)"
                $this._services.Task.UpdateTask($this._editingTask.id, $updates)
            }
            else {
                # Add new task
                Write-Log -Level Info -Message "Saving new task with title: $($updates.Title)"
                $this._services.Task.AddTask($updates)
            }
            # The UI will refresh automatically via the Tasks.Changed event.
            # We just need to switch back to the list view.
            $this._ShowListPanel()
        }
    }
    $screen | Add-Member -MemberType ScriptMethod -Name _SaveTask -Value $saveTaskScript

    #================================================================================
    # Public Methods (Screen Lifecycle)
    #================================================================================

    $initScript = {
        param(
            [Parameter(Mandatory = $true)]
            [hashtable]$services
        )
        Invoke-WithErrorHandling -Component "$($this.Name).Init" -Context @{} -ScriptBlock {
            Write-Log -Level Info -Message "Initializing Task Screen."
            # Defensive programming: ensure required services are provided
            if (-not $services) { throw "Services hashtable cannot be null." }
            if (-not $services.Task) { throw "TaskService is missing from services." }
            if (-not $services.Keybinding) { throw "KeybindingService is missing from services." }

            $this._services = $services

            # Build the entire UI component tree for the screen
            $this._BuildUI()

            # Subscribe to TaskService events to keep the UI in sync with the state
            $eventHandler = {
                # This scriptblock runs when the 'Tasks.Changed' event is fired
                Write-Log -Level Trace -Message "TaskScreen received 'Tasks.Changed' event."
                $this._RefreshTaskList()
            }
            $subscription = Register-EngineEvent -SourceIdentifier 'TaskService' -EventIdentifier 'Tasks.Changed' -Action $eventHandler
            [void]$this._eventSubscriptions.Add($subscription)
            Write-Log -Level Debug -Message "TaskScreen subscribed to 'TaskService.Tasks.Changed' event."

            # Perform initial data load
            $this._RefreshTaskList()
        }
    }
    $screen | Add-Member -MemberType ScriptMethod -Name Init -Value $initScript

    $onExitScript = {
        Invoke-WithErrorHandling -Component "$($this.Name).OnExit" -Context @{} -ScriptBlock {
            Write-Log -Level Info -Message "Exiting Task Screen, unregistering event subscriptions."
            # CRITICAL: Clean up event subscriptions to prevent memory leaks
            foreach ($sub in $this._eventSubscriptions) {
                try {
                    Unregister-Event -SubscriptionId $sub.Id
                }
                catch {
                    Write-Log -Level Warn -Message "Failed to unregister event subscription $($sub.Id): $_"
                }
            }
            $this._eventSubscriptions.Clear()
        }
    }
    $screen | Add-Member -MemberType ScriptMethod -Name OnExit -Value $onExitScript

    $handleInputScript = {
        param(
            [Parameter(Mandatory = $true)]
            [System.Management.Automation.Host.KeyInfo]$Key
        )

        # Input is only handled at the screen level if the list panel is visible.
        # When the form panel is visible, its components (TextBox, Button) handle input.
        if (-not $this._listPanel.Visible) {
            return $false
        }

        Invoke-WithErrorHandling -Component "$($this.Name).HandleInput" -Context @{ Key = $Key.Key } -ScriptBlock {
            $keybindingSvc = $this._services.Keybinding
            if ($keybindingSvc.IsAction('list.new', $Key))    { $this._NewTask(); return $true }
            if ($keybindingSvc.IsAction('list.edit', $Key))   { $this._EditTask($null); return $true }
            if ($keybindingSvc.IsAction('list.delete', $Key)) { $this._DeleteTask($null); return $true }
            if ($keybindingSvc.IsAction('app.back', $Key))    { $this._services.Navigation.Back(); return $true }
        }
        return $false
    }
    $screen | Add-Member -MemberType ScriptMethod -Name HandleInput -Value $handleInputScript

    # The Render method for a screen is simple: it just renders its root panel.
    # The TUI engine will then recursively render the children of the root panel.
    $renderScript = {
        if ($this._rootPanel -and $this._rootPanel.PSObject.Methods['Render']) {
            $this._rootPanel.Render()
        }
    }
    $screen | Add-Member -MemberType ScriptMethod -Name Render -Value $renderScript

    # Expose the root panel for the TUI engine and focus manager
    $screen.PSObject.Properties.Add([psnoteproperty]::new('RootPanel', $screen._rootPanel))

    return $screen
}

Export-ModuleMember -Function Get-HeliosTaskScreen

#endregion


####\services\keybindings.psm1
# FILE: services/keybindings.psm1
# PURPOSE: Provides a centralized service for managing application keybindings.
# This service abstracts raw key presses into named actions, allowing for easy
# configuration and preventing hard-coded keys in UI components.

function Initialize-KeybindingService {
    [CmdletBinding()]
    [OutputType([pscustomobject])]
    param()

    Write-Log -Level Debug -Message "Initializing KeybindingService..."

    # The _keyMap defines all application-wide actions and their corresponding keys.
    # Action names are lowercase for case-insensitive lookups.
    # 'Key' can be a character or a [System.ConsoleKey] enum.
    # 'Modifiers' is an array containing 'Ctrl', 'Alt', or 'Shift'.
    $keyMap = @{
        # Application-level
        "app.quit"        = @{ Key = 'q'; Modifiers = @('Ctrl') }
        "app.back"        = @{ Key = [System.ConsoleKey]::Escape; Modifiers = @() }
        "app.refresh"     = @{ Key = 'r'; Modifiers = @('Ctrl') }
        "app.debuglog"    = @{ Key = [System.ConsoleKey]::F12; Modifiers = @() }
        "app.help"        = @{ Key = [System.ConsoleKey]::F1; Modifiers = @() }

        # List operations
        "list.new"        = @{ Key = 'n'; Modifiers = @() }
        "list.edit"       = @{ Key = 'e'; Modifiers = @() }
        "list.delete"     = @{ Key = [System.ConsoleKey]::Delete; Modifiers = @() }
        "list.toggle"     = @{ Key = [System.ConsoleKey]::Spacebar; Modifiers = @() }
        "list.selectall"  = @{ Key = 'a'; Modifiers = @('Ctrl') }

        # Navigation
        "nav.up"          = @{ Key = [System.ConsoleKey]::UpArrow; Modifiers = @() }
        "nav.down"        = @{ Key = [System.ConsoleKey]::DownArrow; Modifiers = @() }
        "nav.left"        = @{ Key = [System.ConsoleKey]::LeftArrow; Modifiers = @() }
        "nav.right"       = @{ Key = [System.ConsoleKey]::RightArrow; Modifiers = @() }
        "nav.pageup"      = @{ Key = [System.ConsoleKey]::PageUp; Modifiers = @() }
        "nav.pagedown"    = @{ Key = [System.ConsoleKey]::PageDown; Modifiers = @() }
        "nav.home"        = @{ Key = [System.ConsoleKey]::Home; Modifiers = @() }
        "nav.end"         = @{ Key = [System.ConsoleKey]::End; Modifiers = @() }

        # Quick navigation (number keys)
        "quicknav.1"      = @{ Key = '1'; Modifiers = @() }
        "quicknav.2"      = @{ Key = '2'; Modifiers = @() }
        "quicknav.3"      = @{ Key = '3'; Modifiers = @() }
        "quicknav.4"      = @{ Key = '4'; Modifiers = @() }
        "quicknav.5"      = @{ Key = '5'; Modifiers = @() }
        "quicknav.6"      = @{ Key = '6'; Modifiers = @() }
        "quicknav.7"      = @{ Key = '7'; Modifiers = @() }
        "quicknav.8"      = @{ Key = '8'; Modifiers = @() }
        "quicknav.9"      = @{ Key = '9'; Modifiers = @() }

        # Form operations
        "form.submit"     = @{ Key = [System.ConsoleKey]::Enter; Modifiers = @() }
        "form.cancel"     = @{ Key = [System.ConsoleKey]::Escape; Modifiers = @() }

        # Text editing
        "edit.cut"        = @{ Key = 'x'; Modifiers = @('Ctrl') }
        "edit.copy"       = @{ Key = 'c'; Modifiers = @('Ctrl') }
        "edit.paste"      = @{ Key = 'v'; Modifiers = @('Ctrl') }
        "edit.undo"       = @{ Key = 'z'; Modifiers = @('Ctrl') }
        "edit.redo"       = @{ Key = 'y'; Modifiers = @('Ctrl') }
    }

    # The service object is a PSCustomObject, encapsulating its own state.
    $service = [PSCustomObject]@{
        Name    = "KeybindingService"
        _keyMap = $keyMap
    }

    # The primary method for UI components to check if a key press matches a named action.
    $service | Add-Member -MemberType ScriptMethod -Name IsAction -Value {
        param(
            [Parameter(Mandatory)]
            [string]$ActionName,

            [Parameter(Mandatory)]
            [System.ConsoleKeyInfo]$KeyInfo
        )

        return Invoke-WithErrorHandling -Component "$($this.Name).IsAction" -ScriptBlock {
            # Defensive programming: Ensure parameters are valid.
            if ([string]::IsNullOrWhiteSpace($ActionName) -or $null -eq $KeyInfo) {
                return $false
            }

            $lookupAction = $ActionName.ToLower()
            if (-not $this._keyMap.ContainsKey($lookupAction)) {
                Write-Log -Level Trace -Message "Action '$lookupAction' not found in key map."
                return $false
            }

            $binding = $this._keyMap[$lookupAction]

            # 1. Match the key itself (character or special key)
            $keyMatches = $false
            if ($binding.Key -is [System.ConsoleKey]) {
                $keyMatches = ($KeyInfo.Key -eq $binding.Key)
            }
            elseif ($binding.Key -is [string] -and $binding.Key.Length -eq 1) {
                # Case-insensitive comparison for character keys
                $keyMatches = $KeyInfo.KeyChar.ToString().Equals($binding.Key, [System.StringComparison]::InvariantCultureIgnoreCase)
            }

            if (-not $keyMatches) {
                return $false
            }

            # 2. Match modifiers EXACTLY. The pressed state must equal the required state.
            $requiredModifiers = [System.Collections.ArrayList]($binding.Modifiers ?? @())
            $hasCtrl = ($KeyInfo.Modifiers -band [System.ConsoleModifiers]::Control) -ne 0
            $hasAlt = ($KeyInfo.Modifiers -band [System.ConsoleModifiers]::Alt) -ne 0
            $hasShift = ($KeyInfo.Modifiers -band [System.ConsoleModifiers]::Shift) -ne 0

            $ctrlRequired = $requiredModifiers.Contains('Ctrl')
            $altRequired = $requiredModifiers.Contains('Alt')
            $shiftRequired = $requiredModifiers.Contains('Shift')

            if (($hasCtrl -ne $ctrlRequired) -or ($hasAlt -ne $altRequired) -or ($hasShift -ne $shiftRequired)) {
                return $false
            }

            # If both key and modifiers match, the action is confirmed.
            Write-Log -Level Trace -Message "Key press matched action '$lookupAction'."
            return $true

        } -Context @{ ActionName = $ActionName; Key = $KeyInfo.Key; Modifiers = $KeyInfo.Modifiers } -ErrorHandler {
            param($Exception)
            Write-Log -Level Error -Message "Error in IsAction: $($Exception.Message)" -Data $Exception.Context
            return $false # Ensure a boolean is always returned
        }
    }

    Write-Log -Level Debug -Message "KeybindingService initialized with $($service._keyMap.Count) actions."

    return $service
}

Export-ModuleMember -Function "Initialize-KeybindingService"


####\services\navigation.psm1
# FILE: services/navigation.psm1
# PURPOSE: Provides a centralized service for managing screen navigation and routing.
# This service encapsulates all logic related to moving between different views in the application.

function Initialize-NavigationService {
    [CmdletBinding()]
    [OutputType([pscustomobject])]
    param()

    Write-Log -Level Debug -Message "Initializing NavigationService..."

    # The service object is a PSCustomObject, encapsulating its own state.
    # _routes: A hashtable mapping URL-like paths to screen factory scriptblocks.
    # _history: A stack to maintain the navigation history for the Back() method.
    $service = [PSCustomObject]@{
        Name     = "NavigationService"
        _routes  = @{}
        _history = [System.Collections.Generic.Stack[string]]::new()
    }

    # Method to register a screen factory for a given path.
    # This allows for a declarative mapping of routes to screens.
    $service | Add-Member -MemberType ScriptMethod -Name RegisterRoute -Value {
        param(
            [Parameter(Mandatory)]
            [string]$Path,

            [Parameter(Mandatory)]
            [scriptblock]$Factory
        )

        Invoke-WithErrorHandling -Component "$($this.Name).RegisterRoute" -ScriptBlock {
            # Defensive programming: Ensure parameters are valid.
            if ([string]::IsNullOrWhiteSpace($Path)) { throw "Route path cannot be null or empty." }
            if ($null -eq $Factory) { throw "Screen factory scriptblock cannot be null." }

            Write-Log -Level Trace -Message "Registering route: $Path"
            $this._routes[$Path.ToLower()] = $Factory
        } -Context @{ Operation = "RegisterRoute"; Path = $Path } -ErrorHandler { # FIX: Changed Context to hashtable
            param($Exception)
            Write-Log -Level Error -Message "Failed to register route '$Path': $($Exception.Message)" -Data $Exception.Context
        }
    }

    # Method to navigate to a registered path. This is the primary way to change screens.
    $service | Add-Member -MemberType ScriptMethod -Name GoTo -Value {
        param(
            [Parameter(Mandatory)]
            [string]$Path,

            [Parameter(Mandatory)]
            [hashtable]$Services
        )

        Invoke-WithErrorHandling -Component "$($this.Name).GoTo" -ScriptBlock {
            # Defensive programming: Ensure parameters are valid.
            if ([string]::IsNullOrWhiteSpace($Path)) { throw "Navigation path cannot be null or empty." }
            if ($null -eq $Services) { throw "Services object cannot be null." }
            if (-not (Get-Command 'Push-Screen' -ErrorAction SilentlyContinue)) {
                throw "TUI Engine function 'Push-Screen' is not available. Ensure tui-engine.psm1 is loaded before services."
            }

            $lookupPath = $Path.ToLower()
            if (-not $this._routes.ContainsKey($lookupPath)) {
                throw "Route not found: '$Path'. Ensure it has been registered."
            }

            Write-Log -Level Info -Message "Navigating to path: $Path"

            # Get the factory scriptblock for the route.
            $factory = $this._routes[$lookupPath]

            # Execute the factory to create the new screen instance, injecting dependencies.
            $screen = & $factory $Services
            if ($null -eq $screen) {
                throw "The screen factory for path '$Path' did not return a valid screen object."
            }

            # Push the new screen onto the TUI engine's screen stack.
            Push-Screen -Screen $screen

            # Add the path to our internal history stack.
            $this._history.Push($Path)
            Write-Log -Level Trace -Message "Navigation history depth: $($this._history.Count)"

        } -Context @{ Operation = "GoTo"; Path = $Path; ServiceCount = $Services.Keys.Count } -ErrorHandler { # FIX: Changed Context to hashtable
            param($Exception)
            Write-Log -Level Error -Message "Navigation failed for path '$Path': $($Exception.Message)" -Data $Exception.Context
            # In a full implementation, this could trigger a user-facing dialog.
        }
    }

    # Method to navigate to the previous screen in the history.
    $service | Add-Member -MemberType ScriptMethod -Name Back -Value {
        Invoke-WithErrorHandling -Component "$($this.Name).Back" -ScriptBlock {
            if (-not (Get-Command 'Pop-Screen' -ErrorAction SilentlyContinue)) {
                throw "TUI Engine function 'Pop-Screen' is not available. Ensure tui-engine.psm1 is loaded before services."
            }

            # Can only go back if there is more than one screen in the stack.
            if ($this._history.Count -le 1) {
                Write-Log -Level Debug -Message "Back navigation requested, but no history to go back to."
                return
            }

            Write-Log -Level Info -Message "Navigating back."

            # Pop the current screen from the TUI engine's stack.
            Pop-Screen

            # Pop the path from our internal history to keep it synchronized.
            [void]$this._history.Pop()
            Write-Log -Level Trace -Message "Navigation history depth: $($this._history.Count)"

        } -Context @{ Operation = "Back" } -ErrorHandler { # FIX: Changed Context to hashtable
            param($Exception)
            Write-Log -Level Error -Message "Back navigation failed: $($Exception.Message)" -Data $Exception.Context
        }
    }

    # FIX: Added IsValidRoute method
    # Method to check if a route is valid.
    $service | Add-Member -MemberType ScriptMethod -Name IsValidRoute -Value {
        param(
            [Parameter(Mandatory)]
            [string]$Path
        )
        Invoke-WithErrorHandling -Component "$($this.Name).IsValidRoute" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($Path)) { return $false }
            return $this._routes.ContainsKey($Path.ToLower())
        } -Context @{ Operation = "IsValidRoute"; Path = $Path } -ErrorHandler { # FIX: Changed Context to hashtable
            param($Exception)
            Write-Log -Level Error -Message "Error in IsValidRoute: $($Exception.Message)" -Data $Exception.Context
            return $false
        }
    }


    # --- Pre-register all known application routes ---
    # This centralizes route definitions within the navigation service itself,
    # making it the single source of truth for application navigation paths.
    # The scriptblocks are the "factories" that create screen objects.

    $service.RegisterRoute("/dashboard", {
        param($services)
        Get-HeliosDashboardScreen -Services $services # FIX: Changed function name
    })

    $service.RegisterRoute("/task", {
        param($services)
        Get-HeliosTaskScreen -Services $services # FIX: Changed function name
    })

    $service.RegisterRoute("/time-entry", {
        param($services)
        # Assuming other Helios screens follow the Get-Helios<ScreenName>Screen convention
        Get-HeliosTimeEntryScreen -Services $services # FIX: Changed function name (assuming convention)
    })

    $service.RegisterRoute("/timer-start", {
        param($services)
        Get-HeliosTimerStartScreen -Services $services # FIX: Changed function name (assuming convention)
    })

    $service.RegisterRoute("/project", {
        param($services)
        Get-HeliosProjectManagementScreen -Services $services # FIX: Changed function name (assuming convention)
    })

    $service.RegisterRoute("/reports", {
        param($services)
        Get-HeliosReportsScreen -Services $services # FIX: Changed function name (assuming convention)
    })

    $service.RegisterRoute("/settings", {
        param($services)
        Get-HeliosSettingsScreen -Services $services # FIX: Changed function name (assuming convention)
    })

    Write-Log -Level Debug -Message "NavigationService initialized with $($service._routes.Count) routes."

    return $service
}

Export-ModuleMember -Function "Initialize-NavigationService"


####\services\task-service.psm1
#
# services/task-service.psm1
#
# Purpose:
#   Manages the state and business logic for all tasks in the application.
#   This service is responsible for creating, reading, updating, and deleting tasks.
#   It also handles its own data persistence to a JSON file and announces
#   state changes using the native PowerShell eventing engine.
#

# Using a generic List for more efficient Add/Remove operations internally.
using namespace System.Collections.Generic

# Disable event registration errors on module reload in interactive sessions.
$ErrorActionPreference = 'SilentlyContinue'
Unregister-Event -SourceIdentifier 'TaskService'
$ErrorActionPreference = 'Stop'


# Register the event source that this service will use to broadcast changes.
# Screens can subscribe to this to know when to refresh their data.
Register-EngineEvent -SourceIdentifier 'TaskService' -SupportEvent


function Initialize-TaskService {
    <#
    .SYNOPSIS
        Creates and initializes a new Task Service instance.
    .DESCRIPTION
        This function constructs the Task Service object, complete with its internal state
        and methods for managing tasks. It loads existing tasks from disk upon creation.
    .OUTPUTS
        [PSCustomObject] The fully initialized Task Service object.
    #>
    [CmdletBinding()]
    param()

    Write-Log -Level Trace -Message 'Initializing Task Service...'

    $service = [PSCustomObject]@{
        _tasks           = [List[hashtable]]::new()
        _persistencePath = Join-Path ([Environment]::GetFolderPath('LocalApplicationData')) 'PMCTerminal' 'tasks.json'
    }

    #================================================================================
    # Private Methods
    #================================================================================

    # Method to broadcast that the task list has changed.
    $announceChangeScript = {
        # FIX: Changed Context from string to hashtable
        Invoke-WithErrorHandling -Component 'TaskService' -Context @{ Operation = 'AnnounceChange' } -ScriptBlock {
            Write-Log -Level Trace -Message "Broadcasting 'Tasks.Changed' event from SourceIdentifier 'TaskService'."
            New-Event -SourceIdentifier 'TaskService' -EventIdentifier 'Tasks.Changed'
        }
    }
    $service | Add-Member -MemberType ScriptMethod -Name '_AnnounceChange' -Value $announceChangeScript -Force

    # Method to save the current list of tasks to the JSON file.
    $saveTasksScript = {
        # FIX: Changed Context from string to hashtable
        Invoke-WithErrorHandling -Component 'TaskService' -Context @{ Operation = 'SaveTasks' } -ScriptBlock {
            Write-Log -Level Trace -Message "Saving $($this._tasks.Count) tasks to $($this._persistencePath)"
            $directory = Split-Path -Path $this._persistencePath -Parent
            if (-not (Test-Path $directory)) {
                New-Item -ItemType Directory -Path $directory -Force | Out-Null
            }

            # Convert the generic List to a standard array for robust serialization.
            $jsonContent = @($this._tasks) | ConvertTo-Json -Depth 10 -Compress
            Set-Content -Path $this._persistencePath -Value $jsonContent -Encoding UTF8
            Write-Log -Level Info -Message "Successfully saved tasks."
        }
    }
    $service | Add-Member -MemberType ScriptMethod -Name '_SaveTasks' -Value $saveTasksScript -Force

    # Method to load tasks from the JSON file.
    $loadTasksScript = {
        # FIX: Changed Context from string to hashtable
        Invoke-WithErrorHandling -Component 'TaskService' -Context @{ Operation = 'LoadTasks' } -ScriptBlock {
            Write-Log -Level Trace -Message "Attempting to load tasks from $($this._persistencePath)"
            if (Test-Path $this._persistencePath) {
                $jsonContent = Get-Content -Path $this._persistencePath -Raw -ErrorAction SilentlyContinue
                if (-not [string]::IsNullOrWhiteSpace($jsonContent)) {
                    try {
                        $loadedTasks = $jsonContent | ConvertFrom-Json -AsHashtable -ErrorAction Stop
                        # Ensure the loaded data is an array (or can be treated as one).
                        if ($loadedTasks -is [array]) {
                            $this._tasks.Clear()
                            $this._tasks.AddRange($loadedTasks)
                            Write-Log -Level Info -Message "Successfully loaded $($this._tasks.Count) tasks."
                        }
                        else {
                            Write-Log -Level Warning -Message 'tasks.json does not contain a valid JSON array. Starting with an empty task list.'
                            $this._tasks.Clear()
                        }
                    }
                    catch {
                        Write-Log -Level Error -Message 'Failed to parse tasks.json. File might be corrupt. Starting with an empty task list.' -Data @{ Exception = $_ }
                        $this._tasks.Clear()
                    }
                }
                else {
                    Write-Log -Level Info -Message 'tasks.json is empty. Initializing empty task list.'
                    $this._tasks.Clear()
                }
            }
            else {
                Write-Log -Level Info -Message 'tasks.json not found. Initializing with an empty task list.'
            }
        }
    }
    $service | Add-Member -MemberType ScriptMethod -Name '_LoadTasks' -Value $loadTasksScript -Force

    #================================================================================
    # Public Methods
    #================================================================================

    $getTasksScript = {
        # Return a copy of the array so the internal state cannot be modified directly.
        return @($this._tasks)
    }
    $service | Add-Member -MemberType ScriptMethod -Name 'GetTasks' -Value $getTasksScript -Force

    $getTaskByIdScript = {
        param(
            [Parameter(Mandatory)]
            [string]$TaskId
        )
        # FIX: Changed Context from string to hashtable, added relevant data
        Invoke-WithErrorHandling -Component 'TaskService' -Context @{ Operation = 'GetTaskById'; TaskId = $TaskId } -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($TaskId)) { throw "TaskId cannot be empty." }

            $task = $this._tasks.Where({ $_.id -eq $TaskId }, 'First')
            # Return a clone of the hashtable to prevent direct modification of the state object.
            if ($task) {
                return $task.Clone()
            }
            return $null
        }
    }
    $service | Add-Member -MemberType ScriptMethod -Name 'GetTaskById' -Value $getTaskByIdScript -Force

    $addTaskScript = {
        param(
            [Parameter(Mandatory)]
            [hashtable]$TaskData
        )
        # FIX: Changed Context from string to hashtable, added relevant data
        Invoke-WithErrorHandling -Component 'TaskService' -Context @{ Operation = 'AddTask'; Title = $TaskData.Title } -ScriptBlock {
            if (-not $TaskData.ContainsKey('Title') -or [string]::IsNullOrWhiteSpace($TaskData.Title)) {
                throw "Task 'Title' is a required property and cannot be empty."
            }

            Write-Log -Level Info -Message "Creating new task with title: $($TaskData.Title)"

            $newTask = @{
                id          = [Guid]::NewGuid().ToString()
                title       = $TaskData.Title.Trim()
                description = if ($TaskData.ContainsKey('Description')) { $TaskData.Description } else { '' }
                completed   = $false
                priority    = if ($TaskData.ContainsKey('Priority')) { $TaskData.Priority } else { 'medium' }
                project     = if ($TaskData.ContainsKey('Category')) { $TaskData.Category } else { 'General' }
                due_date    = if ($TaskData.ContainsKey('DueDate')) { $TaskData.DueDate } else { $null }
                created_at  = (Get-Date).ToString('o')
                updated_at  = (Get-Date).ToString('o')
            }

            $this._tasks.Add($newTask)
            $this._SaveTasks()
            $this._AnnounceChange()

            Write-Log -Level Info -Message "Task created successfully with ID: $($newTask.id)"
            return $newTask
        }
    }
    $service | Add-Member -MemberType ScriptMethod -Name 'AddTask' -Value $addTaskScript -Force

    $updateTaskScript = {
        param(
            [Parameter(Mandatory)]
            [string]$TaskId,
            [Parameter(Mandatory)]
            [hashtable]$Updates
        )
        # FIX: Changed Context from string to hashtable, added relevant data
        Invoke-WithErrorHandling -Component 'TaskService' -Context @{ Operation = 'UpdateTask'; TaskId = $TaskId; UpdatesKeys = $Updates.Keys } -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($TaskId)) { throw 'TaskId cannot be empty.' }
            if ($Updates.Count -eq 0) {
                Write-Log -Level Warning -Message "UpdateTask called with no updates for TaskId $TaskId"
                return $null
            }

            $taskToUpdate = $this._tasks.Where({ $_.id -eq $TaskId }, 'First')
            if (-not $taskToUpdate) {
                Write-Log -Level Warning -Message "UpdateTask failed: Task with ID '$TaskId' not found."
                return $null
            }

            Write-Log -Level Info -Message "Updating task with ID: $TaskId"

            # Dynamically apply updates from the hashtable
            foreach ($key in $Updates.Keys) {
                $value = $Updates[$key]
                switch ($key) {
                    'Title'       { $taskToUpdate.title = $value.Trim() }
                    'Description' { $taskToUpdate.description = $value }
                    'Priority'    { $taskToUpdate.priority = $value }
                    'Category'    { $taskToUpdate.project = $value } # Map 'Category' to internal 'project' field
                    'DueDate'     { $taskToUpdate.due_date = $value }
                    'Completed'   { $taskToUpdate.completed = [bool]$value }
                }
            }
            $taskToUpdate.updated_at = (Get-Date).ToString('o')

            $this._SaveTasks()
            $this._AnnounceChange()

            Write-Log -Level Info -Message "Task '$TaskId' updated successfully."
            return $taskToUpdate
        }
    }
    $service | Add-Member -MemberType ScriptMethod -Name 'UpdateTask' -Value $updateTaskScript -Force

    $deleteTaskScript = {
        param(
            [Parameter(Mandatory)]
            [string]$TaskId
        )
        # FIX: Changed Context from string to hashtable, added relevant data
        Invoke-WithErrorHandling -Component 'TaskService' -Context @{ Operation = 'DeleteTask'; TaskId = $TaskId } -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($TaskId)) { throw 'TaskId cannot be empty.' }

            $taskToRemove = $this._tasks.Where({ $_.id -eq $TaskId }, 'First')
            if ($taskToRemove) {
                Write-Log -Level Info -Message "Deleting task with ID: $TaskId"
                $wasRemoved = $this._tasks.Remove($taskToRemove)

                if ($wasRemoved) {
                    $this._SaveTasks()
                    $this._AnnounceChange()
                    Write-Log -Level Info -Message "Task '$TaskId' deleted successfully."
                    return $true
                }
                # This case is rare but indicates an internal issue.
                Write-Log -Level Error -Message "Found task '$TaskId' but failed to remove it from the list."
                return $false
            }

            Write-Log -Level Warning -Message "DeleteTask failed: Task with ID '$TaskId' not found."
            return $false
        }
    }
    $service | Add-Member -MemberType ScriptMethod -Name 'DeleteTask' -Value $deleteTaskScript -Force


    # Load initial data from disk
    $service._LoadTasks()

    Write-Log -Level Info -Message "Task Service initialized with $($service.GetTasks().Count) tasks."
    return $service
}

Export-ModuleMember -Function 'Initialize-TaskService'


####\ui\helios-components.psm1
# Helios Component Library
# Unified UI component library following PowerShell-first architecture
# All components return PSCustomObject with methods attached via Add-Member

#region Basic Components

function global:New-HeliosLabel {
    param([hashtable]$Props = @{})
    
    # Create PSCustomObject
    $component = [PSCustomObject]@{
        # Metadata
        Type = "Label"
        IsFocusable = $false
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 10 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 1 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Text = if ($null -ne $Props.Text) { $Props.Text } else { "" }
        ForegroundColor = $Props.ForegroundColor
        Name = $Props.Name
    }
    
    # Add Render method
    $component | Add-Member -MemberType ScriptMethod -Name "Render" -Value {
        param()
        Invoke-WithErrorHandling -Component "$($this.Name).Render" -ScriptBlock {
            if (-not $this.Visible) { return }
            
            $fg = if ($this.ForegroundColor) { $this.ForegroundColor } else { Get-ThemeColor "Primary" -Default ([ConsoleColor]::White) }
            Write-BufferString -X $this.X -Y $this.Y -Text $this.Text -ForegroundColor $fg
        } -Context @{ Component = $this.Name } -ErrorHandler {
            param($Exception)
            Write-Log -Level Error -Message "Label Render error: $($Exception.Message)" -Data $Exception.Context
        }
    }
    
    # Add HandleInput method
    $component | Add-Member -MemberType ScriptMethod -Name "HandleInput" -Value {
        param($Key)
        return $false
    }
    
    return $component
}

function global:New-HeliosButton {
    param([hashtable]$Props = @{})
    
    # Create PSCustomObject
    $component = [PSCustomObject]@{
        # Metadata
        Type = "Button"
        IsFocusable = $true
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 10 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 3 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Text = if ($null -ne $Props.Text) { $Props.Text } else { "Button" }
        Name = $Props.Name
        
        # Internal State
        IsPressed = $false
        IsFocused = $false
        
        # Event Handlers (from Props)
        OnClick = $Props.OnClick
    }
    
    # Add Render method
    $component | Add-Member -MemberType ScriptMethod -Name "Render" -Value {
        param()
        Invoke-WithErrorHandling -Component "$($this.Name).Render" -ScriptBlock {
            if (-not $this.Visible) { return }
            
            $borderColor = if ($this.IsFocused) { 
                Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
            } else { 
                Get-ThemeColor "Primary" -Default ([ConsoleColor]::White)
            }
            $bgColor = if ($this.IsPressed) { 
                Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
            } else { 
                Get-ThemeColor "Background" -Default ([ConsoleColor]::Black)
            }
            $fgColor = if ($this.IsPressed) { 
                Get-ThemeColor "Background" -Default ([ConsoleColor]::Black)
            } else { 
                $borderColor 
            }
            
            Write-BufferBox -X $this.X -Y $this.Y -Width $this.Width -Height $this.Height `
                -BorderColor $borderColor -BackgroundColor $bgColor
                
            $textX = $this.X + [Math]::Floor(($this.Width - $this.Text.Length) / 2)
            Write-BufferString -X $textX -Y ($this.Y + 1) -Text $this.Text `
                -ForegroundColor $fgColor -BackgroundColor $bgColor
        } -Context @{ Component = $this.Name } -ErrorHandler {
            param($Exception)
            Write-Log -Level Error -Message "Button Render error: $($Exception.Message)" -Data $Exception.Context
        }
    }
    
    # Add HandleInput method
    $component | Add-Member -MemberType ScriptMethod -Name "HandleInput" -Value {
        param($Key)
        Invoke-WithErrorHandling -Component "$($this.Name).HandleInput" -ScriptBlock {
            if ($Key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                if ($this.OnClick) {
                    Invoke-WithErrorHandling -Component "$($this.Name).OnClick" -ScriptBlock {
                        & $this.OnClick
                    } -Context @{ Component = $this.Name; Key = $Key } -ErrorHandler {
                        param($Exception)
                        Write-Log -Level Error -Message "Button OnClick error: $($Exception.Message)" -Data $Exception.Context
                    }
                }
                Request-TuiRefresh
                return $true
            }
            return $false
        } -Context @{ Component = $this.Name; Key = $Key } -ErrorHandler {
            param($Exception)
            Write-Log -Level Error -Message "Button HandleInput error: $($Exception.Message)" -Data $Exception.Context
            return $false
        }
    }
    
    return $component
}

function global:New-HeliosTextBox {
    param([hashtable]$Props = @{})
    
    # Create PSCustomObject
    $component = [PSCustomObject]@{
        # Metadata
        Type = "TextBox"
        IsFocusable = $true
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 20 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 3 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Text = if ($null -ne $Props.Text) { $Props.Text } else { "" }
        Placeholder = if ($null -ne $Props.Placeholder) { $Props.Placeholder } else { "" }
        MaxLength = if ($null -ne $Props.MaxLength) { $Props.MaxLength } else { 100 }
        Name = $Props.Name
        
        # Internal State
        CursorPosition = if ($null -ne $Props.CursorPosition) { $Props.CursorPosition } else { 0 }
        IsFocused = $false
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
    }
    
    # Add Render method
    $component | Add-Member -MemberType ScriptMethod -Name "Render" -Value {
        param()
        Invoke-WithErrorHandling -Component "$($this.Name).Render" -ScriptBlock {
            if (-not $this.Visible) { return }
            
            $borderColor = if ($this.IsFocused) { 
                Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
            } else { 
                Get-ThemeColor "Secondary" -Default ([ConsoleColor]::DarkGray)
            }
            Write-BufferBox -X $this.X -Y $this.Y -Width $this.Width -Height 3 -BorderColor $borderColor
            
            $displayText = if ($this.Text) { $this.Text } else { "" }
            if ([string]::IsNullOrEmpty($displayText) -and -not $this.IsFocused) { 
                $displayText = if ($this.Placeholder) { $this.Placeholder } else { "" }
            }
            
            $maxDisplayLength = $this.Width - 4
            if ($displayText.Length -gt $maxDisplayLength) {
                $displayText = $displayText.Substring(0, $maxDisplayLength)
            }
            
            Write-BufferString -X ($this.X + 2) -Y ($this.Y + 1) -Text $displayText
            
            if ($this.IsFocused -and $this.CursorPosition -le $displayText.Length) {
                $cursorX = $this.X + 2 + $this.CursorPosition
                Write-BufferString -X $cursorX -Y ($this.Y + 1) -Text "_" `
                    -BackgroundColor (Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan))
            }
        } -Context @{ Component = $this.Name } -ErrorHandler {
            param($Exception)
            Write-Log -Level Error -Message "TextBox Render error: $($Exception.Message)" -Data $Exception.Context
        }
    }
    
    # Add HandleInput method
    $component | Add-Member -MemberType ScriptMethod -Name "HandleInput" -Value {
        param($Key)
        Invoke-WithErrorHandling -Component "$($this.Name).HandleInput" -ScriptBlock {
            $text = if ($this.Text) { $this.Text } else { "" }
            $cursorPos = if ($null -ne $this.CursorPosition) { $this.CursorPosition } else { 0 }
            $oldText = $text
            
            switch ($Key.Key) {
                ([ConsoleKey]::Backspace) { 
                    if ($cursorPos -gt 0) { 
                        $text = $text.Remove($cursorPos - 1, 1)
                        $cursorPos-- 
                    }
                }
                ([ConsoleKey]::Delete) { 
                    if ($cursorPos -lt $text.Length) { 
                        $text = $text.Remove($cursorPos, 1) 
                    }
                }
                ([ConsoleKey]::LeftArrow) { 
                    if ($cursorPos -gt 0) { $cursorPos-- }
                }
                ([ConsoleKey]::RightArrow) { 
                    if ($cursorPos -lt $text.Length) { $cursorPos++ }
                }
                ([ConsoleKey]::Home) { $cursorPos = 0 }
                ([ConsoleKey]::End) { $cursorPos = $text.Length }
                ([ConsoleKey]::V) {
                    # Handle Ctrl+V (paste)
                    if ($Key.Modifiers -band [ConsoleModifiers]::Control) {
                        try {
                            # Get clipboard text (Windows only)
                            $clipboardText = if (Get-Command Get-Clipboard -ErrorAction SilentlyContinue) {
                                Get-Clipboard -Format Text -ErrorAction SilentlyContinue
                            } else {
                                $null
                            }
                            
                            if ($clipboardText) {
                                # Remove newlines for single-line textbox
                                $clipboardText = $clipboardText -replace '[\r\n]+', ' '
                                
                                # Insert as much as will fit
                                $remainingSpace = $this.MaxLength - $text.Length
                                if ($remainingSpace -gt 0) {
                                    $toInsert = if ($clipboardText.Length -gt $remainingSpace) {
                                        $clipboardText.Substring(0, $remainingSpace)
                                    } else {
                                        $clipboardText
                                    }
                                    
                                    $text = $text.Insert($cursorPos, $toInsert)
                                    $cursorPos += $toInsert.Length
                                }
                            }
                        } catch {
                            # Silently ignore clipboard errors
                            Write-Log -Level Warning -Message "TextBox clipboard paste error: $_" -Data @{ Component = $this.Name }
                        }
                    } else {
                        # Regular 'V' key
                        if (-not [char]::IsControl($Key.KeyChar) -and $text.Length -lt $this.MaxLength) {
                            $text = $text.Insert($cursorPos, $Key.KeyChar)
                            $cursorPos++
                        } else {
                            return $false
                        }
                    }
                }
                default {
                    if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar) -and $text.Length -lt $this.MaxLength) {
                        $text = $text.Insert($cursorPos, $Key.KeyChar)
                        $cursorPos++
                    } else { 
                        return $false 
                    }
                }
            }
            
            if ($text -ne $oldText -or $cursorPos -ne $this.CursorPosition) {
                $this.Text = $text
                $this.CursorPosition = $cursorPos
                
                if ($this.OnChange) { 
                    Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock {
                        & $this.OnChange -NewValue $text
                    } -Context @{ Component = $this.Name; NewValue = $text } -ErrorHandler {
                        param($Exception)
                        Write-Log -Level Error -Message "TextBox OnChange error: $($Exception.Message)" -Data $Exception.Context
                    }
                }
                Request-TuiRefresh
            }
            return $true
        } -Context @{ Component = $this.Name; Key = $Key } -ErrorHandler {
            param($Exception)
            Write-Log -Level Error -Message "TextBox HandleInput error: $($Exception.Message)" -Data $Exception.Context
            return $false
        }
    }
    
    return $component
}

function global:New-HeliosCheckBox {
    param([hashtable]$Props = @{})
    
    # Create PSCustomObject
    $component = [PSCustomObject]@{
        # Metadata
        Type = "CheckBox"
        IsFocusable = $true
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 20 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 1 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Text = if ($null -ne $Props.Text) { $Props.Text } else { "Checkbox" }
        Checked = if ($null -ne $Props.Checked) { $Props.Checked } else { $false }
        Name = $Props.Name
        
        # Internal State
        IsFocused = $false
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
    }
    
    # Add Render method
    $component | Add-Member -MemberType ScriptMethod -Name "Render" -Value {
        param()
        Invoke-WithErrorHandling -Component "$($this.Name).Render" -ScriptBlock {
            if (-not $this.Visible) { return }
            
            $fg = if ($this.IsFocused) { 
                Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
            } else { 
                Get-ThemeColor "Primary" -Default ([ConsoleColor]::White)
            }
            $checkbox = if ($this.Checked) { "[X]" } else { "[ ]" }
            Write-BufferString -X $this.X -Y $this.Y -Text "$checkbox $($this.Text)" -ForegroundColor $fg
        } -Context @{ Component = $this.Name } -ErrorHandler {
            param($Exception)
            Write-Log -Level Error -Message "CheckBox Render error: $($Exception.Message)" -Data $Exception.Context
        }
    }
    
    # Add HandleInput method
    $component | Add-Member -MemberType ScriptMethod -Name "HandleInput" -Value {
        param($Key)
        Invoke-WithErrorHandling -Component "$($this.Name).HandleInput" -ScriptBlock {
            if ($Key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                $this.Checked = -not $this.Checked
                
                if ($this.OnChange) { 
                    Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock {
                        & $this.OnChange -NewValue $this.Checked 
                    } -Context @{ Component = $this.Name; NewValue = $this.Checked } -ErrorHandler {
                        param($Exception)
                        Write-Log -Level Error -Message "CheckBox OnChange error: $($Exception.Message)" -Data $Exception.Context
                    }
                }
                Request-TuiRefresh
                return $true
            }
            return $false
        } -Context @{ Component = $this.Name; Key = $Key } -ErrorHandler {
            param($Exception)
            Write-Log -Level Error -Message "CheckBox HandleInput error: $($Exception.Message)" -Data $Exception.Context
            return $false
        }
    }
    
    return $component
}

function global:New-HeliosProgressBar {
    param([hashtable]$Props = @{})
    
    # Create PSCustomObject
    $component = [PSCustomObject]@{
        # Metadata
        Type = "ProgressBar"
        IsFocusable = $false
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 20 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 1 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Value = if ($null -ne $Props.Value) { $Props.Value } else { 0 }
        Max = if ($null -ne $Props.Max) { $Props.Max } else { 100 }
        ShowPercent = if ($null -ne $Props.ShowPercent) { $Props.ShowPercent } else { $false }
        Name = $Props.Name
    }
    
    # Add Render method
    $component | Add-Member -MemberType ScriptMethod -Name "Render" -Value {
        param()
        Invoke-WithErrorHandling -Component "$($this.Name).Render" -ScriptBlock {
            if (-not $this.Visible) { return }
            
            $percent = [Math]::Min(100, [Math]::Max(0, ($this.Value / $this.Max) * 100))
            $filled = [Math]::Floor(($this.Width - 2) * ($percent / 100))
            $empty = ($this.Width - 2) - $filled
            
            $bar = "" * $filled + "" * $empty
            Write-BufferString -X $this.X -Y $this.Y -Text "[$bar]" -ForegroundColor (Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan))
            
            if ($this.ShowPercent) {
                $percentText = "$([Math]::Round($percent))%"
                $textX = $this.X + [Math]::Floor(($this.Width - $percentText.Length) / 2)
                Write-BufferString -X $textX -Y $this.Y -Text $percentText -ForegroundColor (Get-ThemeColor "Primary" -Default ([ConsoleColor]::White))
            }
        } -Context @{ Component = $this.Name } -ErrorHandler {
            param($Exception)
            Write-Log -Level Error -Message "ProgressBar Render error: $($Exception.Message)" -Data $Exception.Context
        }
    }
    
    # Add HandleInput method
    $component | Add-Member -MemberType ScriptMethod -Name "HandleInput" -Value {
        param($Key)
        return $false
    }
    
    return $component
}

function global:New-HeliosTextArea {
    param([hashtable]$Props = @{})
    
    # Create PSCustomObject
    $component = [PSCustomObject]@{
        # Metadata
        Type = "TextArea"
        IsFocusable = $true
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 40 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 6 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Text = if ($null -ne $Props.Text) { $Props.Text } else { "" }
        Placeholder = if ($null -ne $Props.Placeholder) { $Props.Placeholder } else { "Enter text..." }
        WrapText = if ($null -ne $Props.WrapText) { $Props.WrapText } else { $true }
        Name = $Props.Name
        
        # Internal State
        Lines = @((if ($null -ne $Props.Text) { $Props.Text } else { "" }) -split "`n")
        CursorX = 0
        CursorY = 0
        ScrollOffset = 0
        IsFocused = $false
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
    }
    
    # Add Render method
    $component | Add-Member -MemberType ScriptMethod -Name "Render" -Value {
        param()
        Invoke-WithErrorHandling -Component "$($this.Name).Render" -ScriptBlock {
            if (-not $this.Visible) { return }
            
            $borderColor = if ($this.IsFocused) { 
                Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
            } else { 
                Get-ThemeColor "Secondary" -Default ([ConsoleColor]::DarkGray)
            }
            Write-BufferBox -X $this.X -Y $this.Y -Width $this.Width -Height $this.Height -BorderColor $borderColor
            
            $innerWidth = $this.Width - 4
            $innerHeight = $this.Height - 2
            $displayLines = @()
            if ($this.Lines.Count -eq 0) { $this.Lines = @("") }
            
            foreach ($line in $this.Lines) {
                if ($this.WrapText -and $line.Length -gt $innerWidth) {
                    for ($i = 0; $i -lt $line.Length; $i += $innerWidth) {
                        $displayLines += $line.Substring($i, [Math]::Min($innerWidth, $line.Length - $i))
                    }
                } else { 
                    $displayLines += $line 
                }
            }
            
            if ($displayLines.Count -eq 1 -and $displayLines[0] -eq "" -and -not $this.IsFocused) {
                Write-BufferString -X ($this.X + 2) -Y ($this.Y + 1) -Text $this.Placeholder
                return
            }
            
            $startLine = $this.ScrollOffset
            $endLine = [Math]::Min($displayLines.Count - 1, $startLine + $innerHeight - 1)
            
            for ($i = $startLine; $i -le $endLine; $i++) {
                $y = $this.Y + 1 + ($i - $startLine)
                $line = $displayLines[$i]
                Write-BufferString -X ($this.X + 2) -Y $y -Text $line
            }
            
            if ($this.IsFocused -and $this.CursorY -ge $startLine -and $this.CursorY -le $endLine) {
                $cursorScreenY = $this.Y + 1 + ($this.CursorY - $startLine)
                $cursorX = [Math]::Min($this.CursorX, $displayLines[$this.CursorY].Length)
                Write-BufferString -X ($this.X + 2 + $cursorX) -Y $cursorScreenY -Text "_" `
                    -BackgroundColor (Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan))
            }
            
            if ($displayLines.Count -gt $innerHeight) {
                $scrollbarHeight = $innerHeight
                $scrollPosition = [Math]::Floor(($this.ScrollOffset / ($displayLines.Count - $innerHeight)) * ($scrollbarHeight - 1))
                for ($i = 0; $i -lt $scrollbarHeight; $i++) {
                    $char = if ($i -eq $scrollPosition) { "" } else { "" }
                    $color = if ($i -eq $scrollPosition) { 
                        Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
                    } else { 
                        Get-ThemeColor "Subtle" -Default ([ConsoleColor]::DarkGray)
                    }
                    Write-BufferString -X ($this.X + $this.Width - 2) -Y ($this.Y + 1 + $i) -Text $char -ForegroundColor $color
                }
            }
        } -Context @{ Component = $this.Name } -ErrorHandler {
            param($Exception)
            Write-Log -Level Error -Message "TextArea Render error: $($Exception.Message)" -Data $Exception.Context
        }
    }
    
    # Add HandleInput method
    $component | Add-Member -MemberType ScriptMethod -Name "HandleInput" -Value {
        param($Key)
        Invoke-WithErrorHandling -Component "$($this.Name).HandleInput" -ScriptBlock {
            $lines = $this.Lines
            $cursorY = $this.CursorY
            $cursorX = $this.CursorX
            $innerHeight = $this.Height - 2
            
            switch ($Key.Key) {
                ([ConsoleKey]::UpArrow) {
                    if ($cursorY -gt 0) {
                        $cursorY--
                        $cursorX = [Math]::Min($cursorX, $lines[$cursorY].Length)
                        if ($cursorY -lt $this.ScrollOffset) { 
                            $this.ScrollOffset = $cursorY 
                        }
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    if ($cursorY -lt $lines.Count - 1) {
                        $cursorY++
                        $cursorX = [Math]::Min($cursorX, $lines[$cursorY].Length)
                        if ($cursorY -ge $this.ScrollOffset + $innerHeight) { 
                            $this.ScrollOffset = $cursorY - $innerHeight + 1 
                        }
                    }
                }
                ([ConsoleKey]::LeftArrow) {
                    if ($cursorX -gt 0) { 
                        $cursorX-- 
                    } elseif ($cursorY -gt 0) { 
                        $cursorY--
                        $cursorX = $lines[$cursorY].Length 
                    }
                }
                ([ConsoleKey]::RightArrow) {
                    if ($cursorX -lt $lines[$cursorY].Length) { 
                        $cursorX++ 
                    } elseif ($cursorY -lt $lines.Count - 1) { 
                        $cursorY++
                        $cursorX = 0 
                    }
                }
                ([ConsoleKey]::Home) { $cursorX = 0 }
                ([ConsoleKey]::End) { $cursorX = $lines[$cursorY].Length }
                ([ConsoleKey]::Enter) {
                    $currentLine = $lines[$cursorY]
                    $beforeCursor = $currentLine.Substring(0, $cursorX)
                    $afterCursor = $currentLine.Substring($cursorX)
                    $lines[$cursorY] = $beforeCursor
                    $lines = @($lines[0..$cursorY]) + @($afterCursor) + @($lines[($cursorY + 1)..($lines.Count - 1)])
                    $cursorY++
                    $cursorX = 0
                    if ($cursorY -ge $this.ScrollOffset + $innerHeight) { 
                        $this.ScrollOffset = $cursorY - $innerHeight + 1 
                    }
                }
                ([ConsoleKey]::Backspace) {
                    if ($cursorX -gt 0) { 
                        $lines[$cursorY] = $lines[$cursorY].Remove($cursorX - 1, 1)
                        $cursorX-- 
                    } elseif ($cursorY -gt 0) {
                        $prevLineLength = $lines[$cursorY - 1].Length
                        $lines[$cursorY - 1] += $lines[$cursorY]
                        $newLines = @()
                        for ($i = 0; $i -lt $lines.Count; $i++) { 
                            if ($i -ne $cursorY) { $newLines += $lines[$i] } 
                        }
                        $lines = $newLines
                        $cursorY--
                        $cursorX = $prevLineLength
                    }
                }
                ([ConsoleKey]::Delete) {
                    if ($cursorX -lt $lines[$cursorY].Length) { 
                        $lines[$cursorY] = $lines[$cursorY].Remove($cursorX, 1) 
                    } elseif ($cursorY -lt $lines.Count - 1) {
                        $lines[$cursorY] += $lines[$cursorY + 1]
                        $newLines = @()
                        for ($i = 0; $i -lt $lines.Count; $i++) { 
                            if ($i -ne ($cursorY + 1)) { $newLines += $lines[$i] } 
                        }
                        $lines = $newLines
                    }
                }
                ([ConsoleKey]::V) {
                    # Handle Ctrl+V (paste)
                    if ($Key.Modifiers -band [ConsoleModifiers]::Control) {
                        try {
                            # Get clipboard text (Windows only)
                            $clipboardText = if (Get-Command Get-Clipboard -ErrorAction SilentlyContinue) {
                                Get-Clipboard -Format Text -ErrorAction SilentlyContinue
                            } else {
                                $null
                            }
                            
                            if ($clipboardText) {
                                # Split clipboard text into lines
                                $clipboardLines = $clipboardText -split '[\r\n]+'
                                
                                if ($clipboardLines.Count -eq 1) {
                                    # Single line paste - insert at cursor
                                    $lines[$cursorY] = $lines[$cursorY].Insert($cursorX, $clipboardLines[0])
                                    $cursorX += $clipboardLines[0].Length
                                } else {
                                    # Multi-line paste
                                    $currentLine = $lines[$cursorY]
                                    $beforeCursor = $currentLine.Substring(0, $cursorX)
                                    $afterCursor = $currentLine.Substring($cursorX)
                                    
                                    # First line
                                    $lines[$cursorY] = $beforeCursor + $clipboardLines[0]
                                    
                                    # Insert middle lines
                                    $insertLines = @()
                                    for ($i = 1; $i -lt $clipboardLines.Count - 1; $i++) {
                                        $insertLines += $clipboardLines[$i]
                                    }
                                    
                                    # Last line
                                    $lastLine = $clipboardLines[-1] + $afterCursor
                                    $insertLines += $lastLine
                                    
                                    # Insert all new lines
                                    $newLines = @()
                                    for ($i = 0; $i -le $cursorY; $i++) {
                                        $newLines += $lines[$i]
                                    }
                                    $newLines += $insertLines
                                    for ($i = $cursorY + 1; $i -lt $lines.Count; $i++) {
                                        $newLines += $lines[$i]
                                    }
                                    
                                    $lines = $newLines
                                    $cursorY += $clipboardLines.Count - 1
                                    $cursorX = $clipboardLines[-1].Length
                                }
                                
                                # Adjust scroll if needed
                                $innerHeight = $this.Height - 2
                                if ($cursorY -ge $this.ScrollOffset + $innerHeight) { 
                                    $this.ScrollOffset = $cursorY - $innerHeight + 1 
                                }
                            }
                        } catch {
                            # Silently ignore clipboard errors
                            Write-Log -Level Warning -Message "TextArea clipboard paste error: $_" -Data @{ Component = $this.Name }
                        }
                    } else {
                        # Regular 'V' key
                        if (-not [char]::IsControl($Key.KeyChar)) {
                            $lines[$cursorY] = $lines[$cursorY].Insert($cursorX, $Key.KeyChar)
                            $cursorX++
                        } else {
                            return $false
                        }
                    }
                }
                default {
                    if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar)) {
                        $lines[$cursorY] = $lines[$cursorY].Insert($cursorX, $Key.KeyChar)
                        $cursorX++
                    } else { 
                        return $false 
                    }
                }
            }
            
            $this.Lines = $lines
            $this.CursorX = $cursorX
            $this.CursorY = $cursorY
            $this.Text = $lines -join "`n"
            
            if ($this.OnChange) { 
                Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock {
                    & $this.OnChange -NewValue $this.Text 
                } -Context @{ Component = $this.Name; NewValue = $this.Text } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "TextArea OnChange error: $($Exception.Message)" -Data $Exception.Context
                }
            }
            Request-TuiRefresh
            return $true
        } -Context @{ Component = $this.Name; Key = $Key } -ErrorHandler {
            param($Exception)
            Write-Log -Level Error -Message "TextArea HandleInput error: $($Exception.Message)" -Data $Exception.Context
            return $false
        }
    }
    
    return $component
}

#endregion

#region DateTime Components

function global:New-HeliosCalendarPicker {
    param([hashtable]$Props = @{})
    
    # Create PSCustomObject
    $component = [PSCustomObject]@{
        Type = "CalendarPicker"
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 30 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 10 }
        Value = if ($null -ne $Props.Value) { $Props.Value } else { (Get-Date) }
        Mode = if ($null -ne $Props.Mode) { $Props.Mode } else { "Date" } # Date, DateTime, Time
        IsFocusable = $true
        IsFocused = $false
        CurrentView = "Day"  # Day, Month, Year
        SelectedDate = if ($null -ne $Props.Value) { $Props.Value } else { (Get-Date) }
        ViewDate = if ($null -ne $Props.Value) { $Props.Value } else { (Get-Date) }
        Name = $Props.Name
        OnChange = $Props.OnChange
        OnSelect = $Props.OnSelect
    }
    
    # Add Render method
    $component | Add-Member -MemberType ScriptMethod -Name "Render" -Value {
        param()
        Invoke-WithErrorHandling -Component "$($this.Name).Render" -ScriptBlock {
            $borderColor = if ($this.IsFocused) { 
                Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
            } else { 
                Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
            }
            
            # Main container
            Write-BufferBox -X $this.X -Y $this.Y -Width $this.Width -Height $this.Height `
                -BorderColor $borderColor -Title " Calendar "
            
            # Header with navigation
            $headerY = $this.Y + 1
            $monthYear = $this.ViewDate.ToString("MMMM yyyy")
            $headerX = $this.X + [Math]::Floor(($this.Width - $monthYear.Length) / 2)
            
            Write-BufferString -X ($this.X + 2) -Y $headerY -Text "" -ForegroundColor $borderColor
            Write-BufferString -X $headerX -Y $headerY -Text $monthYear -ForegroundColor (Get-ThemeColor "Header" -Default ([ConsoleColor]::Cyan))
            Write-BufferString -X ($this.X + $this.Width - 3) -Y $headerY -Text "" -ForegroundColor $borderColor
            
            # Day headers
            $dayHeaderY = $headerY + 2
            $days = @("Su", "Mo", "Tu", "We", "Th", "Fr", "Sa")
            $dayWidth = 4
            $startX = $this.X + 2
            
            for ($i = 0; $i -lt $days.Count; $i++) {
                Write-BufferString -X ($startX + ($i * $dayWidth)) -Y $dayHeaderY `
                    -Text $days[$i] -ForegroundColor (Get-ThemeColor "Subtle" -Default ([ConsoleColor]::DarkGray))
            }
            
            # Calendar grid
            $firstDay = Get-Date -Year $this.ViewDate.Year -Month $this.ViewDate.Month -Day 1
            $startDayOfWeek = [int]$firstDay.DayOfWeek
            $daysInMonth = [DateTime]::DaysInMonth($this.ViewDate.Year, $this.ViewDate.Month)
            
            $currentDay = 1
            $calendarY = $dayHeaderY + 1
            
            for ($week = 0; $week -lt 6; $week++) {
                if ($currentDay -gt $daysInMonth) { break }
                
                for ($dayOfWeek = 0; $dayOfWeek -lt 7; $dayOfWeek++) {
                    $x = $startX + ($dayOfWeek * $dayWidth)
                    
                    if ($week -eq 0 -and $dayOfWeek -lt $startDayOfWeek) {
                        continue
                    }
                    
                    if ($currentDay -le $daysInMonth) {
                        $isSelected = ($currentDay -eq $this.SelectedDate.Day -and 
                                     $this.ViewDate.Month -eq $this.SelectedDate.Month -and 
                                     $this.ViewDate.Year -eq $this.SelectedDate.Year)
                        
                        $isToday = ($currentDay -eq (Get-Date).Day -and 
                                  $this.ViewDate.Month -eq (Get-Date).Month -and 
                                  $this.ViewDate.Year -eq (Get-Date).Year)
                        
                        $fg = if ($isSelected) { 
                            Get-ThemeColor "Background" -Default ([ConsoleColor]::Black)
                        } elseif ($isToday) { 
                            Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
                        } else { 
                            Get-ThemeColor "Primary" -Default ([ConsoleColor]::White)
                        }
                        
                        $bg = if ($isSelected) { 
                            Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
                        } else { 
                            Get-ThemeColor "Background" -Default ([ConsoleColor]::Black)
                        }
                        
                        $dayText = $currentDay.ToString().PadLeft(2)
                        Write-BufferString -X $x -Y ($calendarY + $week) -Text $dayText `
                            -ForegroundColor $fg -BackgroundColor $bg
                        
                        $currentDay++
                    }
                }
            }
            
            # Time picker if in DateTime mode
            if ($this.Mode -eq "DateTime") {
                $timeY = $this.Y + $this.Height - 2
                $timeStr = $this.SelectedDate.ToString("HH:mm")
                Write-BufferString -X ($this.X + 2) -Y $timeY -Text "Time: $timeStr" `
                    -ForegroundColor (Get-ThemeColor "Primary" -Default ([ConsoleColor]::White))
            }
        } -Context @{ Component = $this.Name } -ErrorHandler {
            param($Exception)
            Write-Log -Level Error -Message "CalendarPicker Render error: $($Exception.Message)" -Data $Exception.Context
        }
    }
    
    # Add HandleInput method
    $component | Add-Member -MemberType ScriptMethod -Name "HandleInput" -Value {
        param($Key)
        Invoke-WithErrorHandling -Component "$($this.Name).HandleInput" -ScriptBlock {
            $handled = $true
            $date = $this.SelectedDate
            $viewDate = $this.ViewDate
            
            switch ($Key.Key) {
                ([ConsoleKey]::LeftArrow) {
                    if ($Key.Modifiers -band [ConsoleModifiers]::Control) {
                        # Previous month
                        $this.ViewDate = $viewDate.AddMonths(-1)
                    } else {
                        # Previous day
                        $date = $date.AddDays(-1)
                        if ($date.Month -ne $viewDate.Month) {
                            $this.ViewDate = $date
                        }
                    }
                }
                ([ConsoleKey]::RightArrow) {
                    if ($Key.Modifiers -band [ConsoleModifiers]::Control) {
                        # Next month
                        $this.ViewDate = $viewDate.AddMonths(1)
                    } else {
                        # Next day
                        $date = $date.AddDays(1)
                        if ($date.Month -ne $viewDate.Month) {
                            $this.ViewDate = $date
                        }
                    }
                }
                ([ConsoleKey]::UpArrow) {
                    $date = $date.AddDays(-7)
                    if ($date.Month -ne $viewDate.Month) {
                        $this.ViewDate = $date
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    $date = $date.AddDays(7)
                    if ($date.Month -ne $viewDate.Month) {
                        $this.ViewDate = $date
                    }
                }
                ([ConsoleKey]::PageUp) {
                    $this.ViewDate = $viewDate.AddMonths(-1)
                    $date = Get-Date -Year $this.ViewDate.Year -Month $this.ViewDate.Month `
                        -Day ([Math]::Min($date.Day, [DateTime]::DaysInMonth($this.ViewDate.Year, $this.ViewDate.Month)))
                }
                ([ConsoleKey]::PageDown) {
                    $this.ViewDate = $viewDate.AddMonths(1)
                    $date = Get-Date -Year $this.ViewDate.Year -Month $this.ViewDate.Month `
                        -Day ([Math]::Min($date.Day, [DateTime]::DaysInMonth($this.ViewDate.Year, $this.ViewDate.Month)))
                }
                ([ConsoleKey]::Home) {
                    $date = Get-Date
                    $this.ViewDate = $date
                }
                ([ConsoleKey]::Enter) {
                    if ($this.OnSelect) {
                        Invoke-WithErrorHandling -Component "$($this.Name).OnSelect" -ScriptBlock {
                            & $this.OnSelect -Date $date
                        } -Context @{ Component = $this.Name; SelectedDate = $date } -ErrorHandler {
                            param($Exception)
                            Write-Log -Level Error -Message "CalendarPicker OnSelect error: $($Exception.Message)" -Data $Exception.Context
                        }
                    }
                }
                default {
                    $handled = $false
                }
            }
            
            if ($handled) {
                $this.SelectedDate = $date
                if ($this.OnChange) {
                    Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock {
                        & $this.OnChange -NewValue $date
                    } -Context @{ Component = $this.Name; NewValue = $date } -ErrorHandler {
                        param($Exception)
                        Write-Log -Level Error -Message "CalendarPicker OnChange error: $($Exception.Message)" -Data $Exception.Context
                    }
                }
                Request-TuiRefresh
            }
            
            return $handled
        } -Context @{ Component = $this.Name; Key = $Key } -ErrorHandler {
            param($Exception)
            Write-Log -Level Error -Message "CalendarPicker HandleInput error: $($Exception.Message)" -Data $Exception.Context
            return $false
        }
    }
    
    return $component
}

function global:New-HeliosTimePicker {
    param([hashtable]$Props = @{})
    
    # Create PSCustomObject
    $component = [PSCustomObject]@{
        # Metadata
        Type = "TimePicker"
        IsFocusable = $true
        IsFocused = $false
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 15 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 3 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Hour = if ($null -ne $Props.Hour) { $Props.Hour } else { 0 }
        Minute = if ($null -ne $Props.Minute) { $Props.Minute } else { 0 }
        Format24H = if ($null -ne $Props.Format24H) { $Props.Format24H } else { $true }
        Name = $Props.Name
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
    }
    
    # Add Render method
    $component | Add-Member -MemberType ScriptMethod -Name "Render" -Value {
        param()
        Invoke-WithErrorHandling -Component "$($this.Name).Render" -ScriptBlock {
            if (-not $this.Visible) { return }
            
            $borderColor = if ($this.IsFocused) { 
                Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
            } else { 
                Get-ThemeColor "Secondary" -Default ([ConsoleColor]::DarkGray)
            }
            Write-BufferBox -X $this.X -Y $this.Y -Width $this.Width -Height 3 -BorderColor $borderColor
            
            if ($this.Format24H) { 
                $timeStr = "{0:D2}:{1:D2}" -f $this.Hour, $this.Minute 
            } else {
                $displayHour = if ($this.Hour -eq 0) { 12 } elseif ($this.Hour -gt 12) { $this.Hour - 12 } else { $this.Hour }
                $ampm = if ($this.Hour -lt 12) { "AM" } else { "PM" }
                $timeStr = "{0:D2}:{1:D2} {2}" -f $displayHour, $this.Minute, $ampm
            }
            
            # Truncate time string if too long
            $maxLength = $this.Width - 6
            if ($timeStr.Length -gt $maxLength) {
                $timeStr = $timeStr.Substring(0, $maxLength)
            }
            
            Write-BufferString -X ($this.X + 2) -Y ($this.Y + 1) -Text $timeStr
            if ($this.IsFocused -and $this.Width -ge 6) { 
                Write-BufferString -X ($this.X + $this.Width - 4) -Y ($this.Y + 1) -Text "" -ForegroundColor $borderColor 
            }
        } -Context @{ Component = $this.Name } -ErrorHandler {
            param($Exception)
            Write-Log -Level Error -Message "TimePicker Render error: $($Exception.Message)" -Data $Exception.Context
        }
    }
    
    # Add HandleInput method
    $component | Add-Member -MemberType ScriptMethod -Name "HandleInput" -Value {
        param($Key)
        Invoke-WithErrorHandling -Component "$($this.Name).HandleInput" -ScriptBlock {
            $handled = $true
            $hour = $this.Hour
            $minute = $this.Minute
            
            switch ($Key.Key) {
                ([ConsoleKey]::UpArrow) { 
                    $minute = ($minute + 15) % 60
                    if ($minute -eq 0) { $hour = ($hour + 1) % 24 } 
                }
                ([ConsoleKey]::DownArrow) { 
                    $minute = ($minute - 15 + 60) % 60
                    if ($minute -eq 45) { $hour = ($hour - 1 + 24) % 24 } 
                }
                ([ConsoleKey]::LeftArrow)  { $hour = ($hour - 1 + 24) % 24 }
                ([ConsoleKey]::RightArrow) { $hour = ($hour + 1) % 24 }
                default { $handled = $false }
            }
            
            if ($handled) {
                $this.Hour = $hour
                $this.Minute = $minute
                
                if ($this.OnChange) { 
                    Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock {
                        & $this.OnChange -NewHour $hour -NewMinute $minute 
                    } -Context @{ Component = $this.Name; NewHour = $hour; NewMinute = $minute } -ErrorHandler {
                        param($Exception)
                        Write-Log -Level Error -Message "TimePicker OnChange error: $($Exception.Message)" -Data $Exception.Context
                    }
                }
                Request-TuiRefresh
            }
            return $handled
        } -Context @{ Component = $this.Name; Key = $Key } -ErrorHandler {
            param($Exception)
            Write-Log -Level Error -Message "TimePicker HandleInput error: $($Exception.Message)" -Data $Exception.Context
            return $false
        }
    }
    
    return $component
}

#endregion



####\ui\helios-panels.psm1
# FILE: ui/helios-panels.psm1
# PURPOSE: Provides a suite of declarative layout panels for UI construction,
# refactored to use a PowerShell-idiomatic PSCustomObject model.

#region Internal Functions

# Internal helper function to create the base panel object with common properties and methods.
# Not exported.
function New-HeliosBasePanel {
    param(
        [hashtable]$Props
    )

    # All panels are PSCustomObjects. Properties are initialized with defaults
    # using the null-coalescing operator for conciseness.
    $panel = [PSCustomObject]@{
        Type            = "Panel"
        Name            = $Props.Name ?? "Panel_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
        X               = $Props.X ?? 0
        Y               = $Props.Y ?? 0
        Width           = $Props.Width ?? 40
        Height          = $Props.Height ?? 20
        Visible         = $Props.Visible ?? $true
        IsFocusable     = $Props.IsFocusable ?? $false
        ZIndex          = $Props.ZIndex ?? 0
        Children        = [System.Collections.ArrayList]@() # Use ArrayList for efficient Add/Remove
        Parent          = $null
        LayoutProps     = $Props.LayoutProps ?? @{}
        ShowBorder      = $Props.ShowBorder ?? $false
        BorderStyle     = $Props.BorderStyle ?? "Single"  # Single, Double, Rounded
        BorderColor     = $Props.BorderColor ?? "Border" # Theme color name
        Title           = $Props.Title
        Padding         = $Props.Padding ?? 0
        Margin          = $Props.Margin ?? 0
        BackgroundColor = $Props.BackgroundColor
        ForegroundColor = $Props.ForegroundColor
        _isDirty        = $true
        _cachedLayout   = $null
    }

    # Add methods using Add-Member for discoverability and clean $object.Method() syntax.
    # The automatic $this variable refers to the panel object itself.

    $panel | Add-Member -MemberType ScriptMethod -Name AddChild -Value {
        param($Child, [hashtable]$LayoutProps = @{})
        Invoke-WithErrorHandling -Component "$($this.Name).AddChild" -ScriptBlock {
            if (-not $Child) { throw "Cannot add a null or empty child to a panel." }

            $Child.Parent = $this
            $Child.LayoutProps = $LayoutProps
            [void]$this.Children.Add($Child)
            $this.InvalidateLayout()

            # Propagate visibility from parent
            if (-not $this.Visible) {
                $Child.Visible = $false
            }
        } -Context @{ Parent = $this.Name; ChildType = $Child.Type; ChildName = $Child.Name } -ErrorHandler {
            param($Exception)
            Write-Log -Level Error -Message "Panel AddChild error: $($Exception.Message)" -Data $Exception.Context
        }
    }

    $panel | Add-Member -MemberType ScriptMethod -Name RemoveChild -Value {
        param($Child)
        Invoke-WithErrorHandling -Component "$($this.Name).RemoveChild" -ScriptBlock {
            $this.Children.Remove($Child)
            if ($Child.Parent -eq $this) {
                $Child.Parent = $null
            }
            $this.InvalidateLayout()
        } -Context @{ Parent = $this.Name; ChildType = $Child.Type; ChildName = $Child.Name } -ErrorHandler {
            param($Exception)
            Write-Log -Level Error -Message "Panel RemoveChild error: $($Exception.Message)" -Data $Exception.Context
        }
    }

    $panel | Add-Member -MemberType ScriptMethod -Name ClearChildren -Value {
        Invoke-WithErrorHandling -Component "$($this.Name).ClearChildren" -ScriptBlock {
            foreach ($child in $this.Children) {
                $child.Parent = $null
            }
            $this.Children.Clear()
            $this.InvalidateLayout()
        } -Context @{ Parent = $this.Name } -ErrorHandler {
            param($Exception)
            Write-Log -Level Error -Message "Panel ClearChildren error: $($Exception.Message)" -Data $Exception.Context
        }
    }

    $panel | Add-Member -MemberType ScriptMethod -Name Show -Value {
        Invoke-WithErrorHandling -Component "$($this.Name).Show" -ScriptBlock {
            if ($this.Visible) { return }
            $this.Visible = $true
            foreach ($child in $this.Children) {
                if ($child.PSObject.Methods['Show']) { $child.Show() } else { $child.Visible = $true }
            }
            $this.InvalidateLayout() # Visibility change affects layout
        } -Context @{ Panel = $this.Name } -ErrorHandler {
            param($Exception)
            Write-Log -Level Error -Message "Panel Show error: $($Exception.Message)" -Data $Exception.Context
        }
    }

    $panel | Add-Member -MemberType ScriptMethod -Name Hide -Value {
        Invoke-WithErrorHandling -Component "$($this.Name).Hide" -ScriptBlock {
            if (-not $this.Visible) { return }
            $this.Visible = $false
            foreach ($child in $this.Children) {
                if ($child.PSObject.Methods['Hide']) { $child.Hide() } else { $child.Visible = $false }
            }
            $this.InvalidateLayout() # Visibility change affects layout
        } -Context @{ Panel = $this.Name } -ErrorHandler {
            param($Exception)
            Write-Log -Level Error -Message "Panel Hide error: $($Exception.Message)" -Data $Exception.Context
        }
    }

    $panel | Add-Member -MemberType ScriptMethod -Name HandleInput -Value {
        param($Key)
        # Panels typically don't handle input directly but delegate to children.
        # This can be overridden for special behavior.
        return $false
    }

    $panel | Add-Member -MemberType ScriptMethod -Name GetContentBounds -Value {
        Invoke-WithErrorHandling -Component "$($this.Name).GetContentBounds" -ScriptBlock {
            $borderOffset = if ($this.ShowBorder) { 1 } else { 0 }
            $totalMargin = $this.Margin * 2
            $totalPadding = $this.Padding * 2
            $totalBorder = $borderOffset * 2

            return [PSCustomObject]@{
                X      = $this.X + $this.Margin + $this.Padding + $borderOffset
                Y      = $this.Y + $this.Margin + $this.Padding + $borderOffset
                Width  = $this.Width - $totalMargin - $totalPadding - $totalBorder
                Height = $this.Height - $totalMargin - $totalPadding - $totalBorder
            }
        } -Context @{ Panel = $this.Name } -ErrorHandler {
            param($Exception)
            Write-Log -Level Error -Message "Panel GetContentBounds error: $($Exception.Message)" -Data $Exception.Context
            return [PSCustomObject]@{ X = $this.X; Y = $this.Y; Width = $this.Width; Height = $this.Height } # Fallback
        }
    }

    $panel | Add-Member -MemberType ScriptMethod -Name InvalidateLayout -Value {
        Invoke-WithErrorHandling -Component "$($this.Name).InvalidateLayout" -ScriptBlock {
            $this._isDirty = $true
            # Propagate invalidation up the visual tree to the root
            if ($this.Parent -and $this.Parent.PSObject.Methods['InvalidateLayout']) {
                $this.Parent.InvalidateLayout()
            }
        } -Context @{ Panel = $this.Name } -ErrorHandler {
            param($Exception)
            Write-Log -Level Error -Message "Panel InvalidateLayout error: $($Exception.Message)" -Data $Exception.Context
        }
    }

    return $panel
}

#endregion

#region Public Panel Factories

function New-HeliosStackPanel {
    [CmdletBinding()]
    param(
        [hashtable]$Props = @{}
    )

    $panel = New-HeliosBasePanel -Props $Props
    $panel.Type = "StackPanel"
    $panel.PSObject.Properties.Add([psnoteproperty]::new('Orientation', ($Props.Orientation ?? 'Vertical')))
    $panel.PSObject.Properties.Add([psnoteproperty]::new('Spacing', ($Props.Spacing ?? 1)))
    $panel.PSObject.Properties.Add([psnoteproperty]::new('HorizontalAlignment', ($Props.HorizontalAlignment ?? 'Stretch'))) # Left, Center, Right, Stretch
    $panel.PSObject.Properties.Add([psnoteproperty]::new('VerticalAlignment', ($Props.VerticalAlignment ?? 'Stretch')))     # Top, Middle, Bottom, Stretch

    $panel | Add-Member -MemberType ScriptMethod -Name CalculateLayout -Value {
        Invoke-WithErrorHandling -Component "$($this.Name).CalculateLayout" -ScriptBlock {
            $bounds = $this.GetContentBounds()
            $layout = @{ Children = [System.Collections.ArrayList]@() }
            $visibleChildren = $this.Children | Where-Object { $_.Visible }
            if ($visibleChildren.Count -eq 0) {
                $this._isDirty = $false
                return $layout
            }

            $currentX = $bounds.X
            $currentY = $bounds.Y
            $totalChildWidth = 0
            $totalChildHeight = 0

            # Calculate total size needed
            foreach ($child in $visibleChildren) {
                if ($this.Orientation -eq 'Vertical') {
                    $totalChildHeight += $child.Height
                    $totalChildWidth = [Math]::Max($totalChildWidth, $child.Width)
                }
                else {
                    $totalChildWidth += $child.Width
                    $totalChildHeight = [Math]::Max($totalChildHeight, $child.Height)
                }
            }

            # Add spacing
            $totalSpacing = ($visibleChildren.Count - 1) * $this.Spacing
            if ($this.Orientation -eq 'Vertical') { $totalChildHeight += $totalSpacing } else { $totalChildWidth += $totalSpacing }

            # Calculate starting position based on alignment
            if ($this.Orientation -eq 'Vertical') {
                switch ($this.VerticalAlignment) {
                    'Top'    { $currentY = $bounds.Y }
                    'Middle' { $currentY = $bounds.Y + [Math]::Floor(($bounds.Height - $totalChildHeight) / 2) }
                    'Bottom' { $currentY = $bounds.Y + $bounds.Height - $totalChildHeight }
                }
            }
            else {
                switch ($this.HorizontalAlignment) {
                    'Left'   { $currentX = $bounds.X }
                    'Center' { $currentX = $bounds.X + [Math]::Floor(($bounds.Width - $totalChildWidth) / 2) }
                    'Right'  { $currentX = $bounds.X + $bounds.Width - $totalChildWidth }
                }
            }

            # Layout children
            foreach ($child in $visibleChildren) {
                $childX = $currentX
                $childY = $currentY
                $childWidth = $child.Width
                $childHeight = $child.Height

                # Apply stretch and alignment
                if ($this.Orientation -eq 'Vertical') {
                    switch ($this.HorizontalAlignment) {
                        'Stretch' { $childWidth = $bounds.Width; $childX = $bounds.X }
                        'Center'  { $childX = $bounds.X + [Math]::Floor(($bounds.Width - $childWidth) / 2) }
                        'Right'   { $childX = $bounds.X + $bounds.Width - $childWidth }
                    }
                }
                else { # Horizontal
                    switch ($this.VerticalAlignment) {
                        'Stretch' { $childHeight = $bounds.Height; $childY = $bounds.Y }
                        'Middle'  { $childY = $bounds.Y + [Math]::Floor(($bounds.Height - $childHeight) / 2) }
                        'Bottom'  { $childY = $bounds.Y + $bounds.Height - $childHeight }
                    }
                }

                # CRITICAL: Apply calculated positions and sizes back to the child component
                $child.X = $childX
                $child.Y = $childY
                if ($child.PSObject.Properties['Width'] -and $child.Width -ne $childWidth) { $child.Width = $childWidth }
                if ($child.PSObject.Properties['Height'] -and $child.Height -ne $childHeight) { $child.Height = $childHeight }

                [void]$layout.Children.Add(@{ Component = $child; X = $childX; Y = $childY; Width = $childWidth; Height = $childHeight })

                # Move to next position
                if ($this.Orientation -eq 'Vertical') { $currentY += $childHeight + $this.Spacing } else { $currentX += $childWidth + $this.Spacing }
            }

            $this._cachedLayout = $layout
            $this._isDirty = $false
            return $layout
        } -Context @{ Panel = $this.Name; Orientation = $this.Orientation } -ErrorHandler {
            param($Exception)
            Write-Log -Level Error -Message "StackPanel CalculateLayout error: $($Exception.Message)" -Data $Exception.Context
            return @{ Children = [System.Collections.ArrayList]@() } # Return empty layout on error
        }
    }

    $panel | Add-Member -MemberType ScriptMethod -Name Render -Value {
        Invoke-WithErrorHandling -Component "$($this.Name).Render" -ScriptBlock {
            if (-not $this.Visible) { return }

            $bgColor = if ($this.BackgroundColor) { $this.BackgroundColor } else { Get-ThemeColor "Background" }
            for ($y = $this.Y; $y -lt ($this.Y + $this.Height); $y++) {
                Write-BufferString -X $this.X -Y $y -Text (' ' * $this.Width) -BackgroundColor $bgColor
            }

            if ($this.ShowBorder) {
                $borderColor = if ($this.BorderColor) { Get-ThemeColor $this.BorderColor } else { Get-ThemeColor "Border" }
                Write-BufferBox -X $this.X -Y $this.Y -Width $this.Width -Height $this.Height -BorderColor $borderColor -BackgroundColor $bgColor -BorderStyle $this.BorderStyle -Title $this.Title
            }

            # Ensure layout is calculated before the TUI Engine renders the children.
            if ($this._isDirty) {
                [void]$this.CalculateLayout()
            }
        } -Context @{ Panel = $this.Name } -ErrorHandler {
            param($Exception)
            Write-Log -Level Error -Message "StackPanel Render error: $($Exception.Message)" -Data $Exception.Context
        }
    }

    return $panel
}

function New-HeliosGridPanel {
    [CmdletBinding()]
    param(
        [hashtable]$Props = @{}
    )

    $panel = New-HeliosBasePanel -Props $Props
    $panel.Type = "GridPanel"
    $panel.PSObject.Properties.Add([psnoteproperty]::new('RowDefinitions', ($Props.RowDefinitions ?? @("1*"))))
    $panel.PSObject.Properties.Add([psnoteproperty]::new('ColumnDefinitions', ($Props.ColumnDefinitions ?? @("1*"))))
    $panel.PSObject.Properties.Add([psnoteproperty]::new('ShowGridLines', ($Props.ShowGridLines ?? $false)))
    $panel.PSObject.Properties.Add([psnoteproperty]::new('GridLineColor', ($Props.GridLineColor ?? (Get-ThemeColor "BorderDim"))))

    # Private helper method to parse row/column definitions
    $panel | Add-Member -MemberType ScriptMethod -Name _CalculateGridSizes -Value {
        param($definitions, $totalSize)
        Invoke-WithErrorHandling -Component "$($this.Name)._CalculateGridSizes" -ScriptBlock {
            $parsedDefs = [System.Collections.ArrayList]@()
            $totalFixed = 0
            $totalStars = 0.0

            foreach ($def in $definitions) {
                if ($def -match '^(\d+)$') {
                    [void]$parsedDefs.Add(@{ Type = 'Fixed'; Value = [int]$Matches[1] })
                    $totalFixed += [int]$Matches[1]
                }
                elseif ($def -match '^(\d*\.?\d*)\*$') {
                    $stars = if ($Matches[1]) { [double]$Matches[1] } else { 1.0 }
                    [void]$parsedDefs.Add(@{ Type = 'Star'; Value = $stars })
                    $totalStars += $stars
                }
                else { throw "Invalid grid definition: $def" }
            }

            $remainingSize = [Math]::Max(0, $totalSize - $totalFixed)
            $sizes = [System.Collections.ArrayList]@()
            foreach ($def in $parsedDefs) {
                if ($def.Type -eq 'Fixed') {
                    [void]$sizes.Add($def.Value)
                }
                else {
                    $size = if ($totalStars -gt 0) { [Math]::Floor($remainingSize * ($def.Value / $totalStars)) } else { 0 }
                    [void]$sizes.Add($size)
                }
            }

            # Distribute rounding errors to the last star-sized cell
            $totalAllocated = ($sizes | Measure-Object -Sum).Sum
            if ($totalAllocated -ne $totalSize -and $totalStars -gt 0) {
                $lastStarIndex = $parsedDefs.FindLastIndex({ param($d) $d.Type -eq 'Star' })
                if ($lastStarIndex -ne -1) {
                    $sizes[$lastStarIndex] += ($totalSize - $totalAllocated)
                }
            }
            return $sizes
        } -Context @{ Panel = $this.Name; Definitions = $definitions; TotalSize = $totalSize } -ErrorHandler {
            param($Exception)
            Write-Log -Level Error -Message "GridPanel _CalculateGridSizes error: $($Exception.Message)" -Data $Exception.Context
            return @()
        }
    }

    $panel | Add-Member -MemberType ScriptMethod -Name CalculateLayout -Value {
        Invoke-WithErrorHandling -Component "$($this.Name).CalculateLayout" -ScriptBlock {
            $bounds = $this.GetContentBounds()
            $rowHeights = $this._CalculateGridSizes($this.RowDefinitions, $bounds.Height)
            $colWidths = $this._CalculateGridSizes($this.ColumnDefinitions, $bounds.Width)

            $rowOffsets = @(0); for ($i = 0; $i -lt $rowHeights.Count - 1; $i++) { $rowOffsets += ($rowOffsets[-1] + $rowHeights[$i]) }
            $colOffsets = @(0); for ($i = 0; $i -lt $colWidths.Count - 1; $i++) { $colOffsets += ($colOffsets[-1] + $colWidths[$i]) }

            $layout = @{ Children = [System.Collections.ArrayList]@(); Rows = $rowHeights; Columns = $colWidths; RowOffsets = $rowOffsets; ColumnOffsets = $colOffsets }

            foreach ($child in $this.Children | Where-Object { $_.Visible }) {
                $gridRow = [int]($child.LayoutProps.'Grid.Row' ?? 0)
                $gridCol = [int]($child.LayoutProps.'Grid.Column' ?? 0)
                $gridRowSpan = [int]($child.LayoutProps.'Grid.RowSpan' ?? 1)
                $gridColSpan = [int]($child.LayoutProps.'Grid.ColumnSpan' ?? 1)

                $row = [Math]::Max(0, [Math]::Min($rowHeights.Count - 1, $gridRow))
                $col = [Math]::Max(0, [Math]::Min($colWidths.Count - 1, $gridCol))
                $rowSpan = [Math]::Max(1, [Math]::Min($rowHeights.Count - $row, $gridRowSpan))
                $colSpan = [Math]::Max(1, [Math]::Min($colWidths.Count - $col, $gridColSpan))

                $cellX = $bounds.X + $colOffsets[$col]; $cellY = $bounds.Y + $rowOffsets[$row]
                $cellWidth = ($colWidths[$col..($col + $colSpan - 1)] | Measure-Object -Sum).Sum
                $cellHeight = ($rowHeights[$row..($row + $rowSpan - 1)] | Measure-Object -Sum).Sum

                $childX = $cellX; $childY = $cellY
                $childWidth = $child.Width; $childHeight = $child.Height

                switch ($child.LayoutProps.'Grid.HorizontalAlignment' ?? 'Stretch') {
                    "Center"  { $childX = $cellX + [Math]::Floor(($cellWidth - $childWidth) / 2) }
                    "Right"   { $childX = $cellX + $cellWidth - $childWidth }
                    "Stretch" { $childWidth = $cellWidth }
                }
                switch ($child.LayoutProps.'Grid.VerticalAlignment' ?? 'Stretch') {
                    "Middle"  { $childY = $cellY + [Math]::Floor(($cellHeight - $childHeight) / 2) }
                    "Bottom"  { $childY = $cellY + $cellHeight - $childHeight }
                    "Stretch" { $childHeight = $cellHeight }
                }

                # CRITICAL: Apply calculated positions and sizes back to the child component
                $child.X = $childX
                $child.Y = $childY
                if ($child.PSObject.Properties['Width'] -and $child.Width -ne $childWidth) { $child.Width = $childWidth }
                if ($child.PSObject.Properties['Height'] -and $child.Height -ne $childHeight) { $child.Height = $childHeight }

                [void]$layout.Children.Add(@{ Component = $child; X = $childX; Y = $childY; Width = $childWidth; Height = $childHeight })
            }

            $this._cachedLayout = $layout
            $this._isDirty = $false
            return $layout
        } -Context @{ Panel = $this.Name; RowDefs = $this.RowDefinitions; ColDefs = $this.ColumnDefinitions } -ErrorHandler {
            param($Exception)
            Write-Log -Level Error -Message "GridPanel CalculateLayout error: $($Exception.Message)" -Data $Exception.Context
            return @{ Children = [System.Collections.ArrayList]@() }
        }
    }

    $panel | Add-Member -MemberType ScriptMethod -Name Render -Value {
        Invoke-WithErrorHandling -Component "$($this.Name).Render" -ScriptBlock {
            if (-not $this.Visible) { return }

            $bgColor = if ($this.BackgroundColor) { $this.BackgroundColor } else { Get-ThemeColor "Background" }
            for ($y = $this.Y; $y -lt ($this.Y + $this.Height); $y++) {
                Write-BufferString -X $this.X -Y $y -Text (' ' * $this.Width) -BackgroundColor $bgColor
            }

            if ($this.ShowBorder) {
                $borderColor = if ($this.BorderColor) { Get-ThemeColor $this.BorderColor } else { Get-ThemeColor "Border" }
                Write-BufferBox -X $this.X -Y $this.Y -Width $this.Width -Height $this.Height -BorderColor $borderColor -BackgroundColor $bgColor -BorderStyle $this.BorderStyle -Title $this.Title
            }

            if ($this._isDirty) {
                [void]$this.CalculateLayout()
            }
            $layout = $this._cachedLayout

            if ($this.ShowGridLines -and $layout) {
                $bounds = $this.GetContentBounds()
                foreach ($offset in $layout.ColumnOffsets[1..($layout.ColumnOffsets.Count - 1)]) {
                    $x = $bounds.X + $offset; for ($y = $bounds.Y; $y -lt ($bounds.Y + $bounds.Height); $y++) { Write-BufferChar -X $x -Y $y -Char "" -ForegroundColor $this.GridLineColor }
                }
                foreach ($offset in $layout.RowOffsets[1..($layout.RowOffsets.Count - 1)]) {
                    $y = $bounds.Y + $offset; Write-BufferString -X $bounds.X -Y $y -Text ("" * $bounds.Width) -ForegroundColor $this.GridLineColor
                }
            }
        } -Context @{ Panel = $this.Name } -ErrorHandler {
            param($Exception)
            Write-Log -Level Error -Message "GridPanel Render error: $($Exception.Message)" -Data $Exception.Context
        }
    }

    return $panel
}

function New-HeliosDockPanel {
    [CmdletBinding()]
    param(
        [hashtable]$Props = @{}
    )
    # A DockPanel is a StackPanel with a fixed vertical orientation.
    # Clone the props to avoid side-effects on the caller's hashtable.
    $dockProps = $Props.Clone()
    $dockProps.Orientation = 'Vertical'
    return New-HeliosStackPanel -Props $dockProps
}

function New-HeliosWrapPanel {
    [CmdletBinding()]
    param(
        [hashtable]$Props = @{}
    )
    # The legacy implementation was an alias for StackPanel. A true WrapPanel
    # would require different layout logic. Replicating legacy behavior for now.
    return New-HeliosStackPanel -Props $Props
}

#endregion

Export-ModuleMember -Function "New-HeliosStackPanel", "New-HeliosGridPanel", "New-HeliosDockPanel", "New-HeliosWrapPanel"


####\filecopy.ps1
# This script finds all .ps1 and .psm1 files in the current directory and its subdirectories.
# For each found file, it creates a copy with a .txt extension in the same location.
# Finally, it concatenates the content of all original .ps1 and .psm1 files into a single file named 'all.txt'
# in the current directory. Each appended file is preceded by a header indicating its relative path.

# Set strict mode for better error handling
Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Get the current working directory, ensuring no trailing backslash for consistent path manipulation
$currentDirectory = (Get-Location).Path.TrimEnd('\')

# Define the name of the output concatenated file
$outputFileName = "all.txt"

Write-Host "Starting script operations in: $currentDirectory"

# --- Step 1: Clear the existing output file if it exists ---
try {
    if (Test-Path $outputFileName) {
        Remove-Item $outputFileName -Force -ErrorAction Stop
        Write-Host "Cleared existing '$outputFileName'."
    }
} catch {
    Write-Warning "Failed to clear '$outputFileName': $($_.Exception.Message)"
    # Continue, as this might not be a fatal error for the rest of the script
}

# --- Step 2: Find all .ps1 and .psm1 files recursively ---
try {
    $scriptFiles = Get-ChildItem -Path $currentDirectory -Recurse -Include *.ps1, *.psm1 -File -ErrorAction Stop
    Write-Host "Found $($scriptFiles.Count) PowerShell script files."
} catch {
    Write-Error "Failed to enumerate script files: $($_.Exception.Message)"
    exit 1 # Exit if we can't even find the files
}

# --- Step 3: Process each file (copy and concatenate) ---
if ($scriptFiles.Count -eq 0) {
    Write-Warning "No .ps1 or .psm1 files found to process."
} else {
    foreach ($file in $scriptFiles) {
        # Create a copy with .txt ending in the same folder
        $txtCopyPath = Join-Path -Path $file.DirectoryName -ChildPath ($file.BaseName + ".txt")
        try {
            Copy-Item -Path $file.FullName -Destination $txtCopyPath -Force -ErrorAction Stop
            Write-Host "  Copied: $($file.Name) to $($txtCopyPath)"
        } catch {
            Write-Warning "  Failed to copy $($file.FullName) to $($txtCopyPath): $($_.Exception.Message)"
        }

        # Prepare header for all.txt using relative path
        # Remove the base directory part from the full path to get the relative path
        $relativePath = $file.FullName.Substring($currentDirectory.Length)
        # Ensure the relative path starts with a single backslash
        if (-not $relativePath.StartsWith('\')) {
            $relativePath = '\' + $relativePath
        }

        $header = "####$relativePath"
        
        # Append the header and file content to all.txt
        try {
            Add-Content -Path $outputFileName -Value $header -Encoding UTF8 -ErrorAction Stop
            # Read the entire file content as a single string
            $fileContent = Get-Content -Path $file.FullName -Raw -Encoding UTF8 -ErrorAction Stop
            Add-Content -Path $outputFileName -Value $fileContent -Encoding UTF8 -ErrorAction Stop
            Add-Content -Path $outputFileName -Value "`n" -Encoding UTF8 -ErrorAction Stop # Add an extra newline for separation
            Write-Host "  Appended: $($file.Name) to $($outputFileName)"
        } catch {
            Write-Warning "  Failed to append $($file.FullName) to $($outputFileName): $($_.Exception.Message)"
        }
    }
}

Write-Host "All operations complete. Concatenated content saved to '$outputFileName'."


####\Start-PMCTerminal.ps1
# FILE: Start-PMCTerminal.ps1
# PURPOSE: Main entry point for the PMC Terminal v5 application.
#          Orchestrates module loading, service initialization, and application startup,
#          adhering to the PowerShell-First architectural principles.

# Set strict mode for better error handling
Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Get the directory where this script is located
$script:BasePath = Split-Path -Parent $MyInvocation.MyCommand.Path

#region --- Module Definitions ---
# Module loading order is critical - dependencies must load first.
# This list defines the modules to be loaded and their relative paths.
$script:ModulesToLoad = @(
    # Foundation Modules (pre-loaded before this list, but included for conceptual completeness)
     #@{ Name = "exceptions"; Path = "modules\exceptions.psm1"; Required = $true },
     #@{ Name = "logger"; Path = "modules\logger.psm1"; Required = $true },

    # Core Application Modules (ordered by dependency)
    # NOTE: event-system removed - using PowerShell native eventing
    @{ Name = "theme-support"; Path = "modules\theme-support.psm1"; Required = $true },
    # NOTE: data-manager removed - services manage their own data
    @{ Name = "focus-manager"; Path = "modules\focus-manager.psm1"; Required = $true },
    @{ Name = "tui-engine"; Path = "modules\tui-engine.psm1"; Required = $true },
    @{ Name = "dialog-system"; Path = "modules\dialog-system.psm1"; Required = $true },

    # UI Modules (depend on tui-engine, theme-manager, focus-manager)
    @{ Name = "helios-panels"; Path = "ui\helios-panels.psm1"; Required = $true },
    @{ Name = "helios-components"; Path = "ui\helios-components.psm1"; Required = $true },

    # Service Modules (depend on others)
    @{ Name = "task-service"; Path = "services\task-service.psm1"; Required = $true },
    @{ Name = "keybindings"; Path = "services\keybindings.psm1"; Required = $true },
    @{ Name = "navigation"; Path = "services\navigation.psm1"; Required = $true }
)

# Screen Modules (loaded after all core modules and services, as they depend on them)
# These are loaded as modules, but their actual screen instances are created via factories
# registered with the NavigationService.
$script:ScreenModules = @(
    "dashboard-screen",
    "task-screen"
    # Add other screens here as they are developed
)
#endregion

#region --- Helper Functions ---

function Load-PMCTerminalModules {
    param([bool]$Silent = $false)
    
    Invoke-WithErrorHandling -Component "ModuleLoader" -Context @{ Operation = "Load-PMCTerminalModules" } -ScriptBlock {
        Write-Log -Level Trace -Message "Starting module loading sequence."
        
        if (-not $Silent) { Write-Host "Initializing PMC Terminal v5..." -ForegroundColor Cyan }
        
        $loadedModules = @()
        
        foreach ($module in $script:ModulesToLoad) {
            $modulePath = Join-Path $script:BasePath $module.Path
            
            Write-Log -Level Trace -Message "Attempting to load module." -Data @{
                ModuleName = $module.Name
                ModulePath = $modulePath
                Required = $module.Required
            }
            
            try {
                if (Test-Path $modulePath) {
                    if (-not $Silent) { Write-Host "  Loading $($module.Name)..." -ForegroundColor Gray }
                    Import-Module $modulePath -Force -Global -ErrorAction Stop
                    $loadedModules += $module.Name
                    Write-Log -Level Debug -Message "Module loaded successfully." -Data @{ ModuleName = $module.Name }
                } elseif ($module.Required) { 
                    $errorMsg = "Required module not found: $($module.Name) at $modulePath"
                    Write-Log -Level Error -Message $errorMsg -Force
                    throw $errorMsg
                } else {
                    if (-not $Silent) { Write-Host "  Optional module $($module.Name) not found: $modulePath (Skipping)" -ForegroundColor Yellow }
                    Write-Log -Level Warn -Message "Optional module not found, skipping." -Data @{ ModuleName = $module.Name; Path = $modulePath }
                }
            } catch {
                $errorMsg = "Failed to load module $($module.Name): $($_.Exception.Message)"
                Write-Log -Level Error -Message $errorMsg -Data @{
                    ModuleName = $module.Name
                    ModulePath = $modulePath
                    Exception = $_.Exception.Message
                    StackTrace = $_.ScriptStackTrace
                } -Force
                throw $errorMsg # Re-throw for Invoke-WithErrorHandling to catch
            }
        }
        
        if (-not $Silent) { Write-Host "Loaded $($loadedModules.Count) core modules successfully." -ForegroundColor Green }
        Write-Log -Level Info -Message "Core modules loaded." -Data @{ LoadedCount = $loadedModules.Count; Modules = $loadedModules }
        return $loadedModules
    } -ErrorHandler {
        param($Exception)
        Write-Log -Level Fatal -Message "Critical error during module loading: $($Exception.Message)" -Data $Exception.Context -Force
        throw # Re-throw to main error handler
    }
}

function Initialize-PMCTerminalServices {
    param([bool]$Silent = $false)
    
    Invoke-WithErrorHandling -Component "ServiceInitializer" -Context @{ Operation = "Initialize-PMCTerminalServices" } -ScriptBlock {
        Write-Log -Level Trace -Message "Starting service initialization."
        if (-not $Silent) { Write-Host "Initializing services..." -ForegroundColor Cyan }
        
        $services = [PSCustomObject]@{} # Use PSCustomObject for services collection
        
        # Initialize TaskService
        if (Get-Command -Name "Initialize-TaskService" -ErrorAction SilentlyContinue) {
            $services | Add-Member -MemberType NoteProperty -Name Task -Value (Initialize-TaskService)
            if (-not $services.Task) { throw "Failed to initialize TaskService." }
            Write-Log -Level Debug -Message "TaskService initialized."
        } else {
            Write-Log -Level Warn -Message "Initialize-TaskService not found. Task functionality will be limited."
        }

        # Initialize KeybindingService
        if (Get-Command -Name "Initialize-KeybindingService" -ErrorAction SilentlyContinue) {
            $services | Add-Member -MemberType NoteProperty -Name Keybindings -Value (Initialize-KeybindingService)
            if (-not $services.Keybindings) { throw "Failed to initialize KeybindingService." }
            Write-Log -Level Debug -Message "KeybindingService initialized."
        } else {
            Write-Log -Level Warn -Message "Initialize-KeybindingService not found. Keybinding functionality will be limited."
        }

        # Initialize NavigationService
        if (Get-Command -Name "Initialize-NavigationService" -ErrorAction SilentlyContinue) {
            $services | Add-Member -MemberType NoteProperty -Name Navigation -Value (Initialize-NavigationService)
            if (-not $services.Navigation) { throw "Failed to initialize NavigationService." }
            Write-Log -Level Debug -Message "NavigationService initialized."
        } else {
            Write-Log -Level Fatal -Message "Initialize-NavigationService not found. Application cannot navigate."
            throw "NavigationService is critical and missing."
        }
        
        if (-not $Silent) { Write-Host "Services initialized successfully." -ForegroundColor Green }
        Write-Log -Level Info -Message "All core services initialized." -Data @{ ServiceCount = $services.PSObject.Properties.Count }
        
        return $services
    } -ErrorHandler {
        param($Exception)
        Write-Log -Level Fatal -Message "Critical error during service initialization: $($Exception.Message)" -Data $Exception.Context -Force
        throw # Re-throw to main error handler
    }
}

function Register-PMCTerminalScreens {
    param(
        [PSCustomObject]$Services,
        [bool]$Silent = $false
    )
    
    Invoke-WithErrorHandling -Component "ScreenRegistration" -Context @{ Operation = "Register-PMCTerminalScreens" } -ScriptBlock {
        if (-not $Services) { throw "Services object is null, cannot register screens." }
        if (-not $Services.Navigation) { throw "Navigation service is null, cannot register screens." }

        Write-Log -Level Trace -Message "Starting screen module loading and route registration."
        if (-not $Silent) { Write-Host "Loading screens and registering routes..." -ForegroundColor Cyan }
        
        $registeredScreens = @()
        
        foreach ($screenName in $script:ScreenModules) {
            $screenPath = Join-Path $script:BasePath "screens\$screenName.psm1"
            
            Write-Log -Level Trace -Message "Processing screen module for registration." -Data @{ ScreenName = $screenName; ScreenPath = $screenPath }
            
            try {
                if (Test-Path $screenPath) {
                    if (-not $Silent) { Write-Host "  Loading $($screenName)..." -ForegroundColor Gray }
                    Import-Module $screenPath -Force -Global -ErrorAction SilentlyContinue
                    
                    # FIX: Add "Helios" prefix to dynamically generated function name
                    $factoryFunctionName = "Get-Helios" + ((($screenName -split "-") | ForEach-Object { 
                        $_.Substring(0,1).ToUpper() + $_.Substring(1) 
                    }) -join "") + "Screen" # e.g., Get-HeliosDashboardScreen, Get-HeliosTaskScreen

                    if (Get-Command -Name $factoryFunctionName -ErrorAction SilentlyContinue) {
                        # Register the route with the NavigationService
                        $path = "/$($screenName -replace '-','/')" # e.g., /dashboard, /task
                        
                        # Special handling for task-screen if it has multiple entry points (as per legacy)
                        if ($screenName -eq "task-screen") {
                            # Assuming Get-TaskScreen is the primary entry for /task
                            $Services.Navigation.RegisterRoute($path, { param($Services) & $factoryFunctionName -Services $Services })
                            Write-Log -Level Debug -Message "Registered route for '$screenName' at '$path' using '$factoryFunctionName'."
                        } else {
                            $Services.Navigation.RegisterRoute($path, { param($Services) & $factoryFunctionName -Services $Services })
                            Write-Log -Level Debug -Message "Registered route for '$screenName' at '$path' using '$factoryFunctionName'."
                        }
                        $registeredScreens += $screenName
                    } else {
                        Write-Log -Level Warn -Message "Expected screen factory function '$factoryFunctionName' not found for module '$screenName'. Skipping route registration."
                    }
                } else { 
                    if (-not $Silent) { Write-Host "  Screen module not found: $screenName at $screenPath (Skipping)" -ForegroundColor Yellow }
                    Write-Log -Level Warn -Message "Screen module file not found, skipping." -Data @{ ScreenName = $screenName; Path = $screenPath }
                }
            } catch { 
                $errorMsg = "Failed to load or register screen '$screenName': $($_.Exception.Message)"
                Write-Log -Level Error -Message $errorMsg -Data @{
                    ScreenName = $screenName
                    ScreenPath = $screenPath
                    Exception = $_.Exception.Message
                    StackTrace = $_.ScriptStackTrace
                }
                if (-not $Silent) { Write-Host "  $errorMsg" -ForegroundColor Red }
            }
        }
        
        if (-not $Silent) { Write-Host "Registered $($registeredScreens.Count) screens successfully." -ForegroundColor Green }
        Write-Log -Level Info -Message "Screens loaded and routes registered." -Data @{ RegisteredCount = $registeredScreens.Count; Screens = $registeredScreens }
        return $registeredScreens
    } -ErrorHandler {
        param($Exception)
        Write-Log -Level Fatal -Message "Critical error during screen registration: $($Exception.Message)" -Data $Exception.Context -Force
        throw # Re-throw to main error handler
    }
}

#endregion

#region --- Main Application Entry Point ---

function Start-PMCTerminal {
    param([bool]$Silent = $false)
    
    Invoke-WithErrorHandling -Component "Start-PMCTerminal" -Context @{ SilentMode = $Silent } -ScriptBlock {
        Write-Log -Level Info -Message "PMC Terminal v5 startup initiated."
        
        # 1. Console Size Check
        $minWidth = 80
        $minHeight = 24
        if ($Host.UI.RawUI) {
            $currentWidth = $Host.UI.RawUI.WindowSize.Width
            $currentHeight = $Host.UI.RawUI.WindowSize.Height
            if ($currentWidth -lt $minWidth -or $currentHeight -lt $minHeight) {
                Write-Host "Console window too small!" -ForegroundColor Red
                Write-Host "Current size: ${currentWidth}x${currentHeight}" -ForegroundColor Yellow
                Write-Host "Minimum required: ${minWidth}x${minHeight}" -ForegroundColor Green
                Write-Host "Please resize your console window and try again." -ForegroundColor White
                Write-Host "Press any key to exit..." -ForegroundColor Gray
                $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
                exit 1
            }
        }
        Write-Log -Level Debug -Message "Console size check passed." -Data @{ Width = $currentWidth; Height = $currentHeight }

        # 2. Load all necessary modules
        $loadedModules = Load-PMCTerminalModules -Silent:$Silent
        Write-Log -Level Info -Message "All core modules loaded: $($loadedModules -join ', ')."

        # 3. Initialize TUI Engine (requires event-system and logger)
        if (Get-Command -Name "Initialize-TuiEngine" -ErrorAction SilentlyContinue) {
            Initialize-TuiEngine
            Write-Log -Level Info -Message "TUI Engine initialized successfully."
        } else {
            throw "TUI Engine initialization function 'Initialize-TuiEngine' not found."
        }

        # 4. Initialize Services
        $services = Initialize-PMCTerminalServices -Silent:$Silent
        # Make services globally accessible for screen factories and TUI engine's event handlers
        # This is the ONLY allowed global variable for services, passed explicitly to components.
        $global:Services = $services 
        Write-Log -Level Info -Message "All services initialized and set to `$global:Services."

        # 5. Register Screens (routes) with Navigation Service
        $registeredScreens = Register-PMCTerminalScreens -Services $services -Silent:$Silent
        Write-Log -Level Info -Message "All screens loaded and routes registered: $($registeredScreens -join ', ')."

        if (-not $Silent) { Write-Host "`nStarting application..." -ForegroundColor Green }
        
        # 6. Navigate to the initial screen
        $startPath = "/dashboard"
        if ($args -contains "-start") {
            $startIndex = [array]::IndexOf($args, "-start")
            if (($startIndex + 1) -lt $args.Count) { 
                $startPath = $args[$startIndex + 1] 
                Write-Log -Level Debug -Message "Custom start path specified." -Data @{ CustomPath = $startPath }
            }
        }
        
        if ($services.Navigation.IsValidRoute($startPath)) {
            Write-Log -Level Info -Message "Navigating to initial screen: $startPath."
            $services.Navigation.GoTo($startPath, $services)
        } else {
            Write-Log -Level Warning -Message "Startup path '$startPath' is not valid. Defaulting to /dashboard."
            $services.Navigation.GoTo("/dashboard", $services)
        }
        
        # 7. Start the main TUI loop
        if (Get-Command -Name "Start-TuiLoop" -ErrorAction SilentlyContinue) {
            Write-Log -Level Info -Message "Starting TUI main loop."
            Start-TuiLoop
        } else {
            throw "TUI main loop function 'Start-TuiLoop' not found."
        }
        
        Write-Log -Level Info -Message "PMC Terminal exited gracefully."
        return $true

    } -ErrorHandler {
        param($Exception, $DetailedError)
        
        # This is the top-level error handler for the application startup.
        # It should provide user-friendly feedback and diagnostic information.
        Write-Host "`n=== CRITICAL FAILURE ===" -ForegroundColor Red
        Write-Host "Fatal error occurred during PMC Terminal startup." -ForegroundColor Red
        
        $errorMessage = if ($Exception.Message) { $Exception.Message } else { "Unknown error" }
        Write-Host "Error: $errorMessage" -ForegroundColor Red
        
        $component = if ($Exception.Context -and $Exception.Context.ContainsKey("Component")) { $Exception.Context.Component } else { "Unknown" }
        Write-Host "Component: $component" -ForegroundColor Yellow
        
        Write-Host "`nDetailed Error Information:" -ForegroundColor Yellow
        if ($DetailedError) {
            Write-Host "Type: $($DetailedError.Type)" -ForegroundColor Gray
            Write-Host "Category: $($DetailedError.Category)" -ForegroundColor Gray
            Write-Host "Location: $($DetailedError.ScriptName):$($DetailedError.LineNumber)" -ForegroundColor Gray
            
            if ($DetailedError.StackTrace -and $DetailedError.StackTrace.Count -gt 0) {
                Write-Host "`nCall Stack (top 5 frames):" -ForegroundColor Yellow
                for ($i = 0; $i -lt [Math]::Min(5, $DetailedError.StackTrace.Count); $i++) {
                    $frame = $DetailedError.StackTrace[$i]
                    Write-Host "  [$i] $($frame.Command) at $($frame.Location)" -ForegroundColor Gray
                }
            }
        }
        
        # Attempt to generate a diagnostic report if logger is available
        if (Get-Command -Name "Get-HeliosDiagnosticReport" -ErrorAction SilentlyContinue) {
            try {
                $report = Get-HeliosDiagnosticReport -IncludeErrorHistory -IncludeLogEntries -LogEntryCount 100
                $reportPath = Join-Path $env:TEMP "helios_crash_$(Get-Date -Format 'yyyyMMdd_HHmmss').json"
                $report | ConvertTo-Json -Depth 10 | Set-Content $reportPath -Encoding UTF8
                Write-Host "`nDiagnostic report saved to: $reportPath" -ForegroundColor Yellow
                Write-Log -Level Info -Message "Crash diagnostic report saved." -Data @{ ReportPath = $reportPath } -Force
            } catch {
                Write-Host "Failed to generate diagnostic report: $($_.Exception.Message)" -ForegroundColor Yellow
            }
        } else {
            Write-Host "Diagnostic report generation not available." -ForegroundColor Yellow
        }
        
        Write-Host "`nCheck the log file for more details: $(Get-LogPath)" -ForegroundColor Cyan
        Write-Host "`n=== END CRITICAL FAILURE ===" -ForegroundColor Red
        
        # Do not re-throw here, let the finally block handle graceful exit.
        return $false
    }
}

#endregion

#region --- Main Execution Block ---

$script:Silent = $args -contains "-silent" -or $args -contains "-s"

try {
    # CRITICAL: Pre-load essential modules (exceptions, logger) BEFORE anything else.
    # This ensures Invoke-WithErrorHandling and Write-Log are available immediately.
    $exceptionsModulePath = Join-Path $script:BasePath "modules\exceptions.psm1"
    $loggerModulePath = Join-Path $script:BasePath "modules\logger.psm1"
    
    if (-not (Test-Path $exceptionsModulePath)) { throw "CRITICAL FAILURE: The core exception handling module is missing at '$exceptionsModulePath'. Cannot continue." }
    if (-not (Test-Path $loggerModulePath)) { throw "CRITICAL FAILURE: The core logger module is missing at '$loggerModulePath'. Cannot continue." }
    
    Import-Module $exceptionsModulePath -Force -Global
    Import-Module $loggerModulePath -Force -Global

    # Initialize logger as early as possible
    Initialize-Logger
    Write-Log -Level Info -Message "Logger initialized early in main execution block."
    
    # Provide immediate feedback to the user
    Write-Host "PMC Terminal v5 - Initializing..." -ForegroundColor Cyan
    if (-not $script:Silent) {
        Write-Host "Log files written to: $(Get-LogPath)" -ForegroundColor Green
        Write-Host ""
    }
    
    # Start the terminal application
    $appSuccess = Start-PMCTerminal -Silent:$script:Silent
    
    if (-not $appSuccess) {
        # If Start-PMCTerminal returned $false due to an error, exit with a non-zero code.
        exit 1
    }

} catch {
    # This is the ultimate fallback error handler if Invoke-WithErrorHandling itself fails.
    Write-Host "`n!!! ULTIMATE FALLBACK ERROR HANDLER !!!" -ForegroundColor Red
    Write-Host "An unhandled critical error occurred during PMC Terminal startup." -ForegroundColor Red
    Write-Host "Error: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Script stack trace:" -ForegroundColor Yellow
    Write-Host $_.ScriptStackTrace -ForegroundColor Gray
    
    # Attempt to save minimal crash information
    try {
        $ultimateFailureInfo = @{
            Timestamp = Get-Date
            UltimateError = $_.Exception.Message
            ErrorType = $_.GetType().FullName
            ProcessId = $PID
            PowerShellVersion = $PSVersionTable.PSVersion.ToString()
            WorkingDirectory = Get-Location
            Arguments = $args
        }
        $ultimatePath = Join-Path $env:TEMP "helios_ultimate_failure_$(Get-Date -Format 'yyyyMMdd_HHmmss').json"
        $ultimateFailureInfo | ConvertTo-Json -Depth 5 | Set-Content $ultimatePath -Encoding UTF8
        Write-Host "`nUltimate failure info saved to: $ultimatePath" -ForegroundColor Magenta
    } catch {
        Write-Host "Even ultimate failure logging failed: $($_.Exception.Message)" -ForegroundColor Red
    }
    
    exit 1 # Exit with error code
    
} finally {
    # Final cleanup and user interaction before exiting.
    # This block always runs, regardless of success or failure.
    
    if (Get-Command -Name "Stop-TuiEngine" -ErrorAction SilentlyContinue) { 
        if (-not $script:Silent) { Write-Host "`nShutting down TUI Engine..." -ForegroundColor Gray }
        Write-Log -Level Info -Message "Stopping TUI Engine."
        Stop-TuiEngine 
    }
    
    # Call service-specific cleanup/save methods if they exist
    # Ensure $global:Services exists and the Task service is initialized
    if ($global:Services -is [PSCustomObject] -and $global:Services.PSObject.Properties.Contains('Task') -and $global:Services.Task -and $global:Services.Task.Save) {
        if (-not $script:Silent) { Write-Host "Saving task data..." -ForegroundColor Gray }
        Write-Log -Level Info -Message "Saving TaskService data."
        $global:Services.Task.Save()
    }

    # Clean up event subscriptions if necessary (though screens should handle their own OnExit)
    # This is a general cleanup, but specific screen cleanup is preferred.
    if (Get-Command -Name "Unregister-Event" -ErrorAction SilentlyContinue) {
        # Unregister all engine events created by this session to prevent leaks
        Get-EventSubscriber | Where-Object { $_.SourceIdentifier -like "Helios.*" } | ForEach-Object {
            try {
                Unregister-Event -SourceIdentifier $_.SourceIdentifier -ErrorAction SilentlyContinue
                Write-Log -Level Trace -Message "Unregistered event subscriber: $($_.SourceIdentifier)"
            } catch {
                Write-Log -Level Warn -Message "Failed to unregister event subscriber '$($_.SourceIdentifier)': $($_.Exception.Message)"
            }
        }
    }

    if (-not $script:Silent) { Write-Host "Goodbye!" -ForegroundColor Green }
    Write-Log -Level Info -Message "PMC Terminal application exit complete."
    
    # Exit with 0 if successful, 1 if there was a fatal error.
    # The `exit 1` in the catch blocks handles error exits.
    # If we reach here after a successful `Start-PMCTerminal`, we exit 0.
    # If we reach here after an error that was handled by the `ErrorHandler` of `Start-PMCTerminal`,
    # `appSuccess` will be `$false`, and the `exit 1` above would have been called.
    # So, if we reach this line, it implies success.
    exit 0 
}


