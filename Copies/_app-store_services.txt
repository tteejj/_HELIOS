# FILE: services/app-store.psm1
# PURPOSE: Provides a single, reactive source of truth for all shared application state using a Redux-like pattern.

function Initialize-AppStore {
    param(
        [hashtable]$InitialData = @{},
        [bool]$EnableDebugLogging = $false
    )
    
    # Ensure Create-TuiState exists
    if (-not (Get-Command -Name "Create-TuiState" -ErrorAction SilentlyContinue)) {
        throw "Create-TuiState not found. Ensure tui-framework.psm1 is loaded first."
    }
    
    $store = @{
        _state = (Create-TuiState -InitialState $InitialData)
        _actions = @{}
        _middleware = @()
        _history = @()  # For time-travel debugging
        _enableDebugLogging = $EnableDebugLogging
        
        GetState = { 
            param($self, [string]$path = $null) 
            if ([string]::IsNullOrEmpty($path)) {
                return (& $self._state.GetValue)
            }
            return (& $self._state.GetValue -Path $path)
        }
        
        Subscribe = { 
            param($self, [string]$path, [scriptblock]$handler) 
            if (-not $handler) { throw "Handler scriptblock is required for Subscribe" }
            return (& $self._state.Subscribe -Path $path -Handler $handler)
        }
        
        Unsubscribe = { 
            param($self, $subId) 
            if ($subId) { & $self._state.Unsubscribe -SubscriptionId $subId }
        }
        
        RegisterAction = { 
            param($self, [string]$actionName, [scriptblock]$scriptBlock) 
            if ([string]::IsNullOrWhiteSpace($actionName)) { throw "Action name cannot be empty" }
            if (-not $scriptBlock) { throw "Script block is required for action '$actionName'" }
            $self._actions[$actionName] = $scriptBlock 
            if ($self._enableDebugLogging) { Write-Log -Level Debug -Message "Registered action: $actionName" }
        }
        
        AddMiddleware = {
            param($self, [scriptblock]$middleware)
            $self._middleware += $middleware
        }
        
        Dispatch = {
            param($self, [string]$actionName, $payload = $null)
            
            if ([string]::IsNullOrWhiteSpace($actionName)) { return @{ Success = $false; Error = "Action name cannot be empty" } }
            
            $action = @{ Type = $actionName; Payload = $payload; Timestamp = [DateTime]::UtcNow }
            
            foreach ($mw in $self._middleware) {
                if ($null -ne $mw) {
                    $action = & $mw -Action $action -Store $self
                    if (-not $action) { return @{ Success = $false; Error = "Action cancelled by middleware" } }
                }
            }
            
            if (-not $self._actions.ContainsKey($actionName)) {
                if ($self._enableDebugLogging) { Write-Log -Level Warning -Message "Action '$actionName' not found." }
                return @{ Success = $false; Error = "Action '$actionName' not registered." }
            }
            
            if ($self._enableDebugLogging) { Write-Log -Level Debug -Message "Dispatching action '$actionName'" -Data $payload }
            
            try {
                $previousState = & $self.GetState -self $self
                
                $actionContext = @{
                    GetState = { & $self.GetState -self $self }
                    UpdateState = { param($updates) & $self._updateState -self $self -updates $updates }
                    Dispatch = { param($name, $p) & $self.Dispatch -self $self -actionName $name -payload $p }
                }
                
                & $self._actions[$actionName] -Context $actionContext -Payload $payload
                
                if ($self._history.Count -gt 100) { $self._history = $self._history[-100..-1] }
                $self._history += @{ Action = $action; PreviousState = $previousState; NextState = (& $self.GetState -self $self) }
                
                return @{ Success = $true }
            } 
            catch {
                if ($self._enableDebugLogging) { Write-Log -Level Error -Message "Error in action handler '$actionName'" -Data $_ }
                return @{ Success = $false; Error = $_.ToString() }
            }
        }
        
        _updateState = { 
            param($self, [hashtable]$updates)
            if ($updates) { & $self._state.Update -Updates $updates }
        }
        
        GetHistory = { param($self) ; return $self._history }
        
        RestoreState = {
            param($self, [int]$stepsBack = 1)
            if ($stepsBack -gt $self._history.Count) { throw "Cannot go back $stepsBack steps. Only $($self._history.Count) actions in history." }
            $targetState = $self._history[-$stepsBack].PreviousState
            # This call is correct because it calls another method on the store itself.
            & $self._updateState -self $self -updates $targetState
        }
    }
    
    # Register built-in actions
    & $store.RegisterAction -self $store -actionName "RESET_STATE" -scriptBlock {
        param($Context, $Payload)
        $Context.UpdateState($InitialData)
    }
    
    & $store.RegisterAction -self $store -actionName "UPDATE_STATE" -scriptBlock {
        param($Context, $Payload)
        if ($Payload -is [hashtable]) {
            $Context.UpdateState($Payload)
        }
    }
    
    return $store
}

Export-ModuleMember -Function "Initialize-AppStore"