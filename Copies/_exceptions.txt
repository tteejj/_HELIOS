# Enhanced Exception Module for Helios
# Provides detailed error tracking and context capture

# Custom exception types for better error handling
class HeliosException : System.Exception {
    [hashtable]$Context
    [string]$Component
    [System.Management.Automation.ErrorRecord]$OriginalError
    
    HeliosException([string]$message, [hashtable]$context) : base($message) {
        $this.Context = $context
        $this.Component = $context.Component
    }
}

class NavigationException : HeliosException {
    NavigationException([string]$message, [hashtable]$context) : base($message, $context) { }
}

class ServiceInitializationException : HeliosException {
    ServiceInitializationException([string]$message, [hashtable]$context) : base($message, $context) { }
}

class ComponentRenderException : HeliosException {
    ComponentRenderException([string]$message, [hashtable]$context) : base($message, $context) { }
}

class StateMutationException : HeliosException {
    StateMutationException([string]$message, [hashtable]$context) : base($message, $context) { }
}

class InputHandlingException : HeliosException {
    InputHandlingException([string]$message, [hashtable]$context) : base($message, $context) { }
}

# Global error handler with detailed context capture
function Set-HeliosErrorHandler {
    param(
        [scriptblock]$CustomHandler = $null
    )
    
    $Global:ErrorActionPreference = 'Stop'
    
    # Set up error trap
    trap {
        $errorInfo = Get-DetailedError -ErrorRecord $_
        
        # Log the detailed error
        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            Write-Log -Level Error -Message $errorInfo.Summary -Data $errorInfo
        } else {
            Write-Host "ERROR: $($errorInfo.Summary)" -ForegroundColor Red
            Write-Host "Details: $($errorInfo | ConvertTo-Json -Depth 3)" -ForegroundColor Yellow
        }
        
        if ($CustomHandler) {
            & $CustomHandler -ErrorInfo $errorInfo
        }
        
        continue
    }
}

# Get detailed error information including stack trace
function Get-DetailedError {
    param(
        [System.Management.Automation.ErrorRecord]$ErrorRecord
    )
    
    $errorInfo = @{
        Summary = $ErrorRecord.Exception.Message
        Type = $ErrorRecord.Exception.GetType().FullName
        Category = $ErrorRecord.CategoryInfo.Category
        TargetObject = $ErrorRecord.TargetObject
        ScriptName = $ErrorRecord.InvocationInfo.ScriptName
        LineNumber = $ErrorRecord.InvocationInfo.ScriptLineNumber
        ColumnNumber = $ErrorRecord.InvocationInfo.OffsetInLine
        Line = $ErrorRecord.InvocationInfo.Line
        PositionMessage = $ErrorRecord.InvocationInfo.PositionMessage
        StackTrace = @()
        InnerException = $null
        HeliosContext = @{}
    }
    
    # Capture call stack
    $callStack = Get-PSCallStack
    $errorInfo.StackTrace = $callStack | ForEach-Object {
        @{
            Command = $_.Command
            Location = $_.Location
            ScriptName = $_.ScriptName
            ScriptLineNumber = $_.ScriptLineNumber
            Arguments = $_.Arguments
        }
    }
    
    # Capture inner exceptions
    $innerEx = $ErrorRecord.Exception.InnerException
    $innerExceptions = @()
    while ($innerEx) {
        $innerExceptions += @{
            Message = $innerEx.Message
            Type = $innerEx.GetType().FullName
            StackTrace = $innerEx.StackTrace
        }
        $innerEx = $innerEx.InnerException
    }
    if ($innerExceptions.Count -gt 0) {
        $errorInfo.InnerException = $innerExceptions
    }
    
    # Extract Helios-specific context if available
    if ($ErrorRecord.Exception -is [HeliosException]) {
        $errorInfo.HeliosContext = $ErrorRecord.Exception.Context
        $errorInfo.Component = $ErrorRecord.Exception.Component
    }
    
    # Try to identify the Helios component/service involved
    $errorInfo.HeliosComponent = Identify-HeliosComponent -ErrorRecord $ErrorRecord
    
    return $errorInfo
}

# Identify which Helios component caused the error
function Identify-HeliosComponent {
    param(
        [System.Management.Automation.ErrorRecord]$ErrorRecord
    )
    
    $scriptName = $ErrorRecord.InvocationInfo.ScriptName
    if (-not $scriptName) { return "Unknown" }
    
    $fileName = [System.IO.Path]::GetFileNameWithoutExtension($scriptName)
    
    # Map file patterns to components
    $componentMap = @{
        'app-store' = 'AppStore'
        'navigation' = 'Navigation Service'
        'tui-engine' = 'TUI Engine'
        'dashboard-screen' = 'Dashboard Screen'
        'task-screen' = 'Task Screen'
        'timer' = 'Timer Service'
        'dialog' = 'Dialog System'
        'focus-manager' = 'Focus Manager'
        'layout' = 'Layout System'
        'panel' = 'Panel Component'
        'main-helios' = 'Main Application'
    }
    
    foreach ($pattern in $componentMap.Keys) {
        if ($fileName -match $pattern) {
            return $componentMap[$pattern]
        }
    }
    
    return $fileName
}

# Wrap a scriptblock with comprehensive error handling
function Invoke-WithErrorHandling {
    param(
        [scriptblock]$ScriptBlock,
        [string]$Component = "Unknown",
        [hashtable]$Context = @{},
        [scriptblock]$ErrorHandler = $null
    )
    
    try {
        & $ScriptBlock
    }
    catch {
        $errorContext = $Context.Clone()
        $errorContext.Component = $Component
        $errorContext.Timestamp = Get-Date
        
        # Create appropriate exception type
        $heliosEx = switch -Regex ($Component) {
            'Navigation' { [NavigationException]::new($_.Exception.Message, $errorContext) }
            'Store|State' { [StateMutationException]::new($_.Exception.Message, $errorContext) }
            'Render' { [ComponentRenderException]::new($_.Exception.Message, $errorContext) }
            'Input' { [InputHandlingException]::new($_.Exception.Message, $errorContext) }
            'Service' { [ServiceInitializationException]::new($_.Exception.Message, $errorContext) }
            default { [HeliosException]::new($_.Exception.Message, $errorContext) }
        }
        
        # Store original error
        $heliosEx.OriginalError = $_
        
        if ($ErrorHandler) {
            & $ErrorHandler -Exception $heliosEx
        }
        else {
            throw $heliosEx
        }
    }
}

# Create a diagnostic report for debugging
function Get-HeliosDiagnosticReport {
    $report = @{
        Timestamp = Get-Date
        PowerShellVersion = $PSVersionTable
        LoadedModules = Get-Module | Select-Object Name, Version, Path
        GlobalVariables = @{}
        Services = @{}
        ErrorHistory = @()
    }
    
    # Capture relevant global variables
    $relevantGlobals = @('Data', 'Services', 'CurrentScreen')
    foreach ($varName in $relevantGlobals) {
        $var = Get-Variable -Name $varName -Scope Global -ErrorAction SilentlyContinue
        if ($var) {
            $report.GlobalVariables[$varName] = @{
                Type = $var.Value.GetType().FullName
                Properties = if ($var.Value -is [hashtable]) { $var.Value.Keys } else { $null }
            }
        }
    }
    
    # Capture service states if available
    if ($global:Services) {
        foreach ($serviceName in $global:Services.Keys) {
            $service = $global:Services[$serviceName]
            $report.Services[$serviceName] = @{
                Type = $service.GetType().FullName
                Methods = if ($service -is [hashtable]) { 
                    $service.Keys | Where-Object { $service[$_] -is [scriptblock] }
                } else { $null }
            }
        }
    }
    
    # Get recent errors
    $report.ErrorHistory = $global:Error[0..4] | ForEach-Object {
        Get-DetailedError -ErrorRecord $_
    }
    
    return $report
}

# Export all functions and classes
Export-ModuleMember -Function @(
    'Set-HeliosErrorHandler',
    'Get-DetailedError',
    'Identify-HeliosComponent',
    'Invoke-WithErrorHandling',
    'Get-HeliosDiagnosticReport'
) -Variable @() -Cmdlet @() -Alias @()

# Export exception classes
$ExceptionTypes = @(
    'HeliosException',
    'NavigationException',
    'ServiceInitializationException',
    'ComponentRenderException',
    'StateMutationException',
    'InputHandlingException'
)

foreach ($type in $ExceptionTypes) {
    Add-Type -TypeDefinition @"
using System;
public class $type : Exception {
    public System.Collections.Hashtable Context { get; set; }
    public string Component { get; set; }
    
    public $type(string message, System.Collections.Hashtable context) : base(message) {
        this.Context = context;
        this.Component = context.ContainsKey("Component") ? context["Component"].ToString() : "Unknown";
    }
}
"@ -ErrorAction SilentlyContinue
}
