# PMC Terminal v4.2 "Helios" - Main Entry Point
# This file orchestrates module loading and application startup with the new service architecture

# Set strict mode for better error handling
Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Get the directory where this script is located
$script:BasePath = Split-Path -Parent $MyInvocation.MyCommand.Path

# Module loading order is critical - dependencies must load first
$script:ModulesToLoad = @(
    # Core infrastructure (no dependencies)
    @{ Name = "logger"; Path = "modules\logger.psm1"; Required = $true },
    @{ Name = "event-system"; Path = "modules\event-system.psm1"; Required = $true },
    
    # Data and theme (depend on event system)
    @{ Name = "data-manager"; Path = "modules\data-manager.psm1"; Required = $true },
    @{ Name = "theme-manager"; Path = "modules\theme-manager.psm1"; Required = $true },
    
    # Framework (depends on event system)
    @{ Name = "tui-framework"; Path = "modules\tui-framework.psm1"; Required = $true },
    
    # Engine (depends on theme and framework)
    @{ Name = "tui-engine-v2"; Path = "modules\tui-engine-v2.psm1"; Required = $true },
    
    # Dialog system (depends on engine)
    @{ Name = "dialog-system"; Path = "modules\dialog-system.psm1"; Required = $true },
    
    # Services (depend on framework for state management)
    @{ Name = "app-store"; Path = "services\app-store.psm1"; Required = $true },
    @{ Name = "navigation"; Path = "services\navigation.psm1"; Required = $true },
    @{ Name = "keybindings"; Path = "services\keybindings.psm1"; Required = $true },
    
    # Layout system
    @{ Name = "layout-panels"; Path = "layout\panels.psm1"; Required = $true },
    
    # Focus management (depends on event system)
    @{ Name = "focus-manager"; Path = "utilities\focus-manager.psm1"; Required = $true },
    
    # Components (depend on engine and panels)
    @{ Name = "tui-components"; Path = "components\tui-components.psm1"; Required = $true },
    @{ Name = "advanced-input-components"; Path = "components\advanced-input-components.psm1"; Required = $false },
    @{ Name = "advanced-data-components"; Path = "components\advanced-data-components.psm1"; Required = $true }
)

# Screen modules will be loaded dynamically
$script:ScreenModules = @(
    "dashboard-screen-helios",
    "task-screen-helios",
    "timer-start-screen",
    "project-management-screen",
    "timer-management-screen",
    "reports-screen",
    "settings-screen",
    "debug-log-screen",
    "demo-screen",
    "time-entry-screen"
)

function Initialize-PMCModules {
    param([bool]$Silent = $false)
    
    # Console size validation
    $minWidth = 80
    $minHeight = 24
    $currentWidth = [Console]::WindowWidth
    $currentHeight = [Console]::WindowHeight
    
    if ($currentWidth -lt $minWidth -or $currentHeight -lt $minHeight) {
        Write-Host "Console window too small!" -ForegroundColor Red
        Write-Host "Current size: ${currentWidth}x${currentHeight}" -ForegroundColor Yellow
        Write-Host "Minimum required: ${minWidth}x${minHeight}" -ForegroundColor Green
        Write-Host ""
        Write-Host "Please resize your console window and try again." -ForegroundColor White
        Write-Host "Press any key to exit..." -ForegroundColor Gray
        $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
        exit 1
    }
    
    if (-not $Silent) {
        Write-Host "Initializing PMC Terminal v4.2 'Helios'..." -ForegroundColor Cyan
    }
    
    $loadedModules = @()
    
    foreach ($module in $script:ModulesToLoad) {
        $modulePath = Join-Path $script:BasePath $module.Path
        
        try {
            if (Test-Path $modulePath) {
                if (-not $Silent) {
                    Write-Host "  Loading $($module.Name)..." -ForegroundColor Gray
                }
                Import-Module $modulePath -Force -Global -ErrorAction Stop
                $loadedModules += $module.Name
            } elseif ($module.Required) {
                throw "Required module not found: $($module.Name) at $modulePath"
            }
        } catch {
            if ($module.Required) {
                Write-Host "  Failed to load $($module.Name): $_" -ForegroundColor Red
                throw "Failed to load required module $($module.Name): $_"
            } else {
                if (-not $Silent) {
                    Write-Host "  Optional module $($module.Name) not loaded: $_" -ForegroundColor Yellow
                }
            }
        }
    }
    
    if (-not $Silent) {
        Write-Host "Loaded $($loadedModules.Count) modules successfully" -ForegroundColor Green
    }
    return $loadedModules
}

function Initialize-PMCScreens {
    param([bool]$Silent = $false)
    
    if (-not $Silent) {
        Write-Host "Loading screens..." -ForegroundColor Cyan
    }
    
    $loadedScreens = @()
    
    foreach ($screenName in $script:ScreenModules) {
        $screenPath = Join-Path $script:BasePath "screens\$screenName.psm1"
        
        try {
            if (Test-Path $screenPath) {
                Import-Module $screenPath -Force -Global -ErrorAction SilentlyContinue
                $loadedScreens += $screenName
            } else {
                if (-not $Silent) {
                    Write-Host "  Screen module not found: $screenName" -ForegroundColor Yellow
                }
            }
        } catch {
            if (-not $Silent) {
                Write-Host "  Failed to load screen: $screenName - $_" -ForegroundColor Yellow
            }
        }
    }
    
    if (-not $Silent) {
        Write-Host "Loaded $($loadedScreens.Count) screens" -ForegroundColor Green
    }
    return $loadedScreens
}

function Initialize-PMCServices {
    param([bool]$Silent = $false)
    
    if (-not $Silent) {
        Write-Host "Initializing services..." -ForegroundColor Cyan
    }
    
    # Create the service registry
    $services = @{}
    
    try {
        # Initialize App Store with initial data
        $initialData = if ($global:Data) { $global:Data } else { @{} }
        $services.Store = Initialize-AppStore -InitialData $initialData -EnableDebugLogging $false
        
        # Register store actions using the v3.0 call pattern
        & $services.Store.RegisterAction -self $services.Store -actionName "LOAD_DASHBOARD_DATA" -scriptBlock {
            param($Context)
            
            # Load quick actions
            $quickActions = @(
                @{ Action = "[Enter] Start Timer" },
                @{ Action = "[Space] Quick Timer" },
                @{ Action = "[T] Tasks" },
                @{ Action = "[P] Projects" },
                @{ Action = "[R] Reports" },
                @{ Action = "[S] Settings" }
            )
            $Context.UpdateState(@{ quickActions = $quickActions })
            
            # Calculate today's hours
            $todayHours = 0
            if ($global:Data -and $global:Data.time_entries) {
                $today = (Get-Date).Date
                $todayEntries = $global:Data.time_entries | Where-Object { 
                    [DateTime]::Parse($_.start_time).Date -eq $today 
                }
                foreach ($entry in $todayEntries) {
                    $todayHours += $entry.duration
                }
            }
            $Context.UpdateState(@{ stats = @{ todayHours = [Math]::Round($todayHours, 2) } })
        }
        
        & $services.Store.RegisterAction -self $services.Store -actionName "TASKS_LOAD" -scriptBlock {
            param($Context)
            
            $tasks = @()
            if ($global:Data -and $global:Data.tasks) {
                $tasks = $global:Data.tasks | ForEach-Object {
                    @{
                        Status = if ($_.completed) { "✓" } else { "○" }
                        Priority = $_.priority ?? "Medium"
                        Title = $_.title ?? "Untitled"
                    }
                }
            }
            $Context.UpdateState(@{ tasks = $tasks })
        }
        
        if (-not $Silent) {
            Write-Host "  App Store initialized" -ForegroundColor Gray
        }
        
        # Initialize Navigation Service
        $services.Navigation = Initialize-NavigationService -EnableBreadcrumbs $true
        if (-not $Silent) {
            Write-Host "  Navigation Service initialized" -ForegroundColor Gray
        }
        
        # Initialize Keybinding Service
        $services.Keybindings = Initialize-KeybindingService -EnableChords $false
        
        # Register global keybinding handlers using the v3.0 call pattern
        & $services.Keybindings.RegisterGlobalHandler -self $services.Keybindings -ActionName "App.Help" -Handler {
            Show-AlertDialog -Title "Help" -Message "PMC Terminal v4.2`n`nPress F1 for help`nPress Escape to go back`nPress Q to quit"
        }
        
        if (-not $Silent) {
            Write-Host "  Keybinding Service initialized" -ForegroundColor Gray
        }
        
    } catch {
        Write-Host "  Failed to initialize services: $_" -ForegroundColor Red
        throw
    }
    
    # Store services globally for backward compatibility
    $global:Services = $services
    
    return $services
}

function Start-PMCTerminal {
    param([bool]$Silent = $false)
    
    try {
        # Load modules
        $loadedModules = Initialize-PMCModules -Silent:$Silent
        
        if (-not $Silent) {
            Write-Host "`nInitializing subsystems..." -ForegroundColor Cyan
        }
        
        # Initialize logger first
        if (Get-Command Initialize-Logger -ErrorAction SilentlyContinue) {
            Initialize-Logger
            Write-Log -Level Info -Message "PMC Terminal v4.2 'Helios' startup initiated"
            Write-Log -Level Info -Message "Loaded modules: $($loadedModules -join ', ')"
        }
        
        # Initialize core systems in correct order
        Initialize-EventSystem
        Initialize-ThemeManager
        Initialize-DataManager
        Initialize-TuiFramework
        Initialize-TuiEngine
        Initialize-DialogSystem
        
        # Load application data
        Load-UnifiedData
        
        # Initialize services AFTER data is loaded
        $services = Initialize-PMCServices -Silent:$Silent
        
        # Initialize focus manager
        Initialize-FocusManager
        if (-not $Silent) {
            Write-Host "  Focus Manager initialized" -ForegroundColor Gray
        }
        
        # Load screens
        Initialize-PMCScreens -Silent:$Silent
        
        if (-not $Silent) {
            Write-Host "`nStarting application..." -ForegroundColor Green
        }
        
        # Clear the console before starting
        Clear-Host
        
        # Navigate to initial screen
        if ($args -contains "-demo" -and (& $services.Navigation.IsValidRoute -self $services.Navigation -Path "/demo")) {
            & $services.Navigation.GoTo -self $services.Navigation -Path "/demo"
        } else {
            & $services.Navigation.GoTo -self $services.Navigation -Path "/dashboard"
        }
        
        # Start the main loop
        Start-TuiLoop
        
    } catch {
        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            Write-Log -Level Error -Message "FATAL: Failed to initialize PMC Terminal" -Data $_
        }
        
        # Enhanced error display
        Write-Host "`n========================================" -ForegroundColor Red
        Write-Host "FATAL ERROR DURING INITIALIZATION" -ForegroundColor Red
        Write-Host "========================================" -ForegroundColor Red
        Write-Host ""
        Write-Host "Error: $($_.Exception.Message)" -ForegroundColor Yellow
        Write-Host ""
        Write-Host "Stack Trace:" -ForegroundColor Cyan
        Write-Host $_.ScriptStackTrace -ForegroundColor Gray
        Write-Host ""
        Write-Host "========================================" -ForegroundColor Red
        
        throw
    } finally {
        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            Write-Log -Level Info -Message "PMC Terminal shutting down"
        }
        
        # Cleanup
        if (Get-Command -Name "Stop-TuiEngine" -ErrorAction SilentlyContinue) {
            if (-not $Silent) {
                Write-Host "`nShutting down..." -ForegroundColor Yellow
            }
            Stop-TuiEngine
        }
        
        # Save data
        if ($global:Data -and (Get-Command -Name "Save-UnifiedData" -ErrorAction SilentlyContinue)) {
            if (-not $Silent) {
                Write-Host "Saving data..." -ForegroundColor Yellow -NoNewline
            }
            Save-UnifiedData
            if (-not $Silent) {
                Write-Host " Done!" -ForegroundColor Green
            }
        }
        
        if (-not $Silent) {
            Write-Host "Goodbye!" -ForegroundColor Green
        }
        
        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            Write-Log -Level Info -Message "PMC Terminal shutdown complete"
        }
    }
}

# Parse command line arguments
$script:args = $args
$script:Silent = $args -contains "-silent" -or $args -contains "-s"

try {
    Clear-Host
    Start-PMCTerminal -Silent:$script:Silent
} catch {
    Write-Error "Fatal error occurred: $_"
    Write-Host "`nPress any key to exit..." -ForegroundColor Red
    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
    exit 1
}
# Advanced Data Components Module
# Enhanced data display components with sorting, filtering, and pagination

#region Advanced Table Component

function global:New-TuiDataTable {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "DataTable"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 80
        Height = $Props.Height ?? 20
        Title = $Props.Title
        ShowBorder = $Props.ShowBorder ?? $true  # <-- NEW: Controls whether component draws its own border
        Data = $Props.Data ?? @()
        Columns = $Props.Columns ?? @()
        SelectedRow = 0
        ScrollOffset = 0
        SortColumn = $null
        SortDirection = "Ascending"
        FilterText = ""
        FilterColumn = $null
        PageSize = 0  # 0 = auto-calculate
        CurrentPage = 0
        ShowHeader = $Props.ShowHeader ?? $true
        ShowFooter = $Props.ShowFooter ?? $true
        ShowRowNumbers = $Props.ShowRowNumbers ?? $false
        AllowSort = $Props.AllowSort ?? $true
        AllowFilter = $Props.AllowFilter ?? $true
        AllowSelection = $Props.AllowSelection ?? $true
        MultiSelect = $Props.MultiSelect ?? $false
        SelectedRows = @()
        IsFocusable = $Props.IsFocusable ?? $true
        Visible = $Props.Visible ?? $true
        Name = $Props.Name
        FilteredData = @()
        ProcessedData = @()
        
        # Event handlers from Props
        OnRowSelect = $Props.OnRowSelect
        OnSelectionChange = $Props.OnSelectionChange
        
        # Column configuration example:
        # @{
        #     Name = "PropertyName"
        #     Header = "Display Header"
        #     Width = 20
        #     Align = "Left"  # Left, Right, Center
        #     Format = { param($value) $value.ToString("N2") }
        #     Sortable = $true
        #     Filterable = $true
        #     Color = { param($value, $row) if ($value -lt 0) { "Red" } else { "Green" } }
        # }
        
        ProcessData = {
            param($self)
            # Filter data
            if ([string]::IsNullOrWhiteSpace($self.FilterText)) {
                $self.FilteredData = $self.Data
            } else {
                if ($self.FilterColumn) {
                    # Filter specific column
                    $self.FilteredData = @($self.Data | Where-Object {
                        $value = $_."$($self.FilterColumn)"
                        $value -and $value.ToString() -like "*$($self.FilterText)*"
                    })
                } else {
                    # Filter all columns
                    $self.FilteredData = @($self.Data | Where-Object {
                        $row = $_
                        $matched = $false
                        foreach ($col in $self.Columns) {
                            if ($col.Filterable -ne $false) {
                                $value = $row."$($col.Name)"
                                if ($value -and $value.ToString() -like "*$($self.FilterText)*") {
                                    $matched = $true
                                    break
                                }
                            }
                        }
                        $matched
                    })
                }
            }
            
            # Sort data
            if ($self.SortColumn -and $self.AllowSort) {
                $self.ProcessedData = $self.FilteredData | Sort-Object -Property $self.SortColumn -Descending:($self.SortDirection -eq "Descending")
            } else {
                $self.ProcessedData = $self.FilteredData
            }
            
            # Reset selection if needed
            if ($self.SelectedRow -ge $self.ProcessedData.Count) {
                $self.SelectedRow = [Math]::Max(0, $self.ProcessedData.Count - 1)
            }
            
            # Calculate page size if auto
            if ($self.PageSize -eq 0) {
                $headerLines = if ($self.ShowHeader) { 3 } else { 0 }
                $footerLines = if ($self.ShowFooter) { 2 } else { 0 }
                $filterLines = if ($self.AllowFilter) { 2 } else { 0 }
                $borderAdjust = if ($self.ShowBorder) { 2 } else { 0 }
                $self.PageSize = $self.Height - $headerLines - $footerLines - $filterLines - $borderAdjust
            }
            
            # Adjust current page
            $totalPages = [Math]::Ceiling($self.ProcessedData.Count / [Math]::Max(1, $self.PageSize))
            if ($self.CurrentPage -ge $totalPages) {
                $self.CurrentPage = [Math]::Max(0, $totalPages - 1)
            }
        }
        
        Render = {
            param($self)
            
            # CRITICAL: Check if component is visible
            if ($self.Visible -eq $false) { return }
            
            # Debug: Check data state for Quick Actions
            if ($self.Title -eq "Quick Actions") {
                Write-Log -Level Debug -Message "Rendering Quick Actions DataTable:"
                Write-Log -Level Debug -Message "  Data count: $($self.Data.Count)"
                Write-Log -Level Debug -Message "  ProcessedData count: $($self.ProcessedData.Count)"
                if ($self.ProcessedData.Count -gt 0) {
                    Write-Log -Level Debug -Message "  First row: $($self.ProcessedData[0] | ConvertTo-Json -Compress)"
                }
                $colInfo = $self.Columns | ForEach-Object { "$($_.Name):$($_.CalculatedWidth)" }
                Write-Log -Level Debug -Message "  Columns: $($colInfo -join ', ')"
            }
            
            # Process data first
            & $self.ProcessData -self $self
            
            # Only draw border if ShowBorder is true
            $contentX = $self.X
            $contentY = $self.Y
            $contentWidth = $self.Width
            $contentHeight = $self.Height
            
            if ($self.ShowBorder) {
                $borderColor = if ($self.IsFocusable -and $self.IsFocused) { 
                    Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
                } else { 
                    Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
                }
                
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor -Title " $($self.Title ?? 'Data Table') "
                
                # Adjust content area for border
                $contentX = $self.X + 1
                $contentY = $self.Y + 1
                $contentWidth = $self.Width - 2
                $contentHeight = $self.Height - 2
            }
            
            $currentY = $contentY
            $innerWidth = $contentWidth
            
            # Filter bar
            if ($self.AllowFilter) {
                $filterBg = if ($self.FilterText) { Get-ThemeColor "Warning" -Default ([ConsoleColor]::Yellow) } else { Get-ThemeColor "Background" -Default ([ConsoleColor]::Black) }
                $filterFg = if ($self.FilterText) { Get-ThemeColor "Background" -Default ([ConsoleColor]::Black) } else { Get-ThemeColor "Subtle" -Default ([ConsoleColor]::DarkGray) }
                
                Write-BufferString -X ($contentX + 1) -Y $currentY -Text "Filter: " -ForegroundColor (Get-ThemeColor "Primary" -Default ([ConsoleColor]::White))
                
                $filterDisplayText = if ($self.FilterText) { $self.FilterText } else { "Type to filter..." }
                Write-BufferString -X ($contentX + 9) -Y $currentY -Text $filterDisplayText `
                    -ForegroundColor $filterFg -BackgroundColor $filterBg
                
                if ($self.FilterColumn) {
                    $colName = ($self.Columns | Where-Object { $_.Name -eq $self.FilterColumn }).Header ?? $self.FilterColumn
                    Write-BufferString -X ($contentX + $contentWidth - 19) -Y $currentY `
                        -Text "Column: $colName" -ForegroundColor (Get-ThemeColor "Info" -Default ([ConsoleColor]::Blue))
                }
                
                $currentY += 2
            }
            
            # Calculate column widths - FIXED VERSION
            $totalDefinedWidth = ($self.Columns | Where-Object { $_.Width } | Measure-Object -Property Width -Sum).Sum ?? 0
            $flexColumns = @($self.Columns | Where-Object { -not $_.Width })
            $columnSeparators = if ($self.Columns.Count -gt 1) { $self.Columns.Count - 1 } else { 0 }  # Only add separators if multiple columns
            $remainingWidth = $innerWidth - $totalDefinedWidth - ($self.ShowRowNumbers ? 5 : 0) - $columnSeparators
            
            # CRITICAL FIX: Ensure flex columns get adequate width, especially for single-column tables
            if ($flexColumns.Count -eq 1 -and $self.Columns.Count -eq 1) {
                # Single flex column should use full available width
                $flexWidth = $remainingWidth
            } elseif ($flexColumns.Count -gt 0) {
                $flexWidth = [Math]::Floor($remainingWidth / $flexColumns.Count)
            } else {
                $flexWidth = 0
            }
            
            # Assign calculated widths
            foreach ($col in $self.Columns) {
                if ($col.Width) {
                    $col.CalculatedWidth = $col.Width
                } else {
                    # For the Quick Actions single column, ensure it gets proper width
                    if ($self.Title -eq "Quick Actions" -and $self.Columns.Count -eq 1) {
                        # Table width 35, minus 2 for borders if ShowBorder=false (but content area already adjusted)
                        $col.CalculatedWidth = $innerWidth - 1  # Leave 1 space for safety
                    } else {
                        $col.CalculatedWidth = [Math]::Max(5, $flexWidth)
                    }
                }
            }
            
            # Header
            if ($self.ShowHeader) {
                $headerX = $contentX
                
                # Row number header
                if ($self.ShowRowNumbers) {
                    Write-BufferString -X $headerX -Y $currentY -Text "#".PadRight(4) `
                        -ForegroundColor (Get-ThemeColor "Header" -Default ([ConsoleColor]::Cyan))
                    $headerX += 5
                }
                
                # Column headers
                foreach ($col in $self.Columns) {
                    $headerText = $col.Header ?? $col.Name
                    $width = $col.CalculatedWidth
                    
                    # Add sort indicator
                    if ($self.AllowSort -and $col.Sortable -ne $false -and $col.Name -eq $self.SortColumn) {
                        $sortIndicator = if ($self.SortDirection -eq "Ascending") { "▲" } else { "▼" }
                        $headerText = "$headerText $sortIndicator"
                    }
                    
                    # Truncate if needed
                    if ($headerText.Length -gt $width) {
                        # FIX: Robust substring
                        $maxLength = [Math]::Max(0, $width - 3)
                        $headerText = $headerText.Substring(0, $maxLength) + "..."
                    }
                    
                    # Align header
                    $alignedText = switch ($col.Align) {
                        "Right" { $headerText.PadLeft($width) }
                        "Center" { 
                            $padding = $width - $headerText.Length
                            $leftPad = [Math]::Floor($padding / 2)
                            $rightPad = $padding - $leftPad
                            " " * $leftPad + $headerText + " " * $rightPad
                        }
                        default { $headerText.PadRight($width) }
                    }
                    
                    Write-BufferString -X $headerX -Y $currentY -Text $alignedText `
                        -ForegroundColor (Get-ThemeColor "Header" -Default ([ConsoleColor]::Cyan))
                    
                    $headerX += $width + 1
                }
                
                $currentY++
                
                # Header separator
                $separatorColor = Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
                Write-BufferString -X $contentX -Y $currentY `
                    -Text ("─" * $contentWidth) -ForegroundColor $separatorColor
                $currentY++
            }
            
            # Data rows
            $startIdx = $self.CurrentPage * $self.PageSize
            $endIdx = [Math]::Min($startIdx + $self.PageSize - 1, $self.ProcessedData.Count - 1)
            
            for ($i = $startIdx; $i -le $endIdx; $i++) {
                $row = $self.ProcessedData[$i]
                $rowX = $contentX
                
                # Selection highlighting
                $isSelected = if ($self.MultiSelect) {
                    $self.SelectedRows -contains $i
                } else {
                    $i -eq $self.SelectedRow
                }
                
                $rowBg = if ($isSelected) { Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan) } else { Get-ThemeColor "Background" -Default ([ConsoleColor]::Black) }
                $rowFg = if ($isSelected) { Get-ThemeColor "Background" -Default ([ConsoleColor]::Black) } else { Get-ThemeColor "Primary" -Default ([ConsoleColor]::White) }
                
                # Clear row background if selected
                if ($isSelected) {
                    Write-BufferString -X $rowX -Y $currentY -Text (" " * $contentWidth) `
                        -BackgroundColor $rowBg
                }
                
                # Row number
                if ($self.ShowRowNumbers) {
                    Write-BufferString -X $rowX -Y $currentY -Text ($i + 1).ToString().PadRight(4) `
                        -ForegroundColor (Get-ThemeColor "Subtle" -Default ([ConsoleColor]::DarkGray)) -BackgroundColor $rowBg
                    $rowX += 5
                }
                
                # Cell data
                foreach ($col in $self.Columns) {
                    $value = $row."$($col.Name)"
                    $width = $col.CalculatedWidth
                    
                    # Format value
                    $displayValue = if ($col.Format -and $value -ne $null) {
                        & $col.Format $value
                    } elseif ($value -ne $null) {
                        $value.ToString()
                    } else {
                        ""
                    }
                    
                    # Truncate if needed
                    if ($displayValue.Length -gt $width) {
                        # FIX: Robust substring
                        $maxLength = [Math]::Max(0, $width - 3)
                        if ($maxLength -le 0) {
                            Write-Log -Level Warning -Message "DataTable '$($self.Title)' column '$($col.Name)' width too small: $width (max length: $maxLength)"
                            $displayValue = "..."
                        } else {
                            $displayValue = $displayValue.Substring(0, $maxLength) + "..."
                        }
                    }
                    
                    
                    # Align value
                    $alignedValue = switch ($col.Align) {
                        "Right" { $displayValue.PadLeft($width) }
                        "Center" { 
                            $padding = $width - $displayValue.Length
                            $leftPad = [Math]::Floor($padding / 2)
                            $rightPad = $padding - $leftPad
                            " " * $leftPad + $displayValue + " " * $rightPad
                        }
                        default { $displayValue.PadRight($width) }
                    }
                    
                    # Determine color
                    $cellFg = if ($col.Color -and -not $isSelected) {
                        $colorName = & $col.Color $value $row
                        Get-ThemeColor $colorName -Default ([ConsoleColor]::White)
                    } else {
                        $rowFg
                    }
                    
                    Write-BufferString -X $rowX -Y $currentY -Text $alignedValue `
                        -ForegroundColor $cellFg -BackgroundColor $rowBg
                    
                    $rowX += $width + 1
                }
                
                $currentY++
            }
            
            # Empty state
            if ($self.ProcessedData.Count -eq 0) {
                $emptyMessage = if ($self.FilterText) {
                    "No results match the filter"
                } else {
                    "No data to display"
                }
                $msgX = $contentX + [Math]::Floor(($contentWidth - $emptyMessage.Length) / 2)
                $msgY = $contentY + [Math]::Floor($contentHeight / 2)
                Write-BufferString -X $msgX -Y $msgY -Text $emptyMessage `
                    -ForegroundColor (Get-ThemeColor "Subtle" -Default ([ConsoleColor]::DarkGray))
            }
            
            # Footer
            if ($self.ShowFooter) {
                $footerY = $contentY + $contentHeight - 1
                
                # Status
                $statusText = "$($self.ProcessedData.Count) rows"
                if ($self.FilterText) {
                    $statusText += " (filtered from $($self.Data.Count))"
                }
                if ($self.MultiSelect) {
                    $statusText += " | $($self.SelectedRows.Count) selected"
                }
                Write-BufferString -X ($contentX + 1) -Y $footerY -Text $statusText `
                    -ForegroundColor (Get-ThemeColor "Subtle" -Default ([ConsoleColor]::DarkGray))
                
                # Pagination
                if ($self.ProcessedData.Count -gt $self.PageSize) {
                    $totalPages = [Math]::Ceiling($self.ProcessedData.Count / [Math]::Max(1, $self.PageSize))
                    $pageText = "Page $($self.CurrentPage + 1)/$totalPages"
                    Write-BufferString -X ($contentX + $contentWidth - $pageText.Length - 1) -Y $footerY `
                        -Text $pageText -ForegroundColor (Get-ThemeColor "Info" -Default ([ConsoleColor]::Blue))
                }
                
                # Scrollbar
                if ($self.ProcessedData.Count -gt $self.PageSize) {
                    $scrollHeight = $contentHeight - 4 - (if ($self.ShowHeader) { 2 } else { 0 }) - (if ($self.AllowFilter) { 2 } else { 0 })
                    $scrollPos = [Math]::Floor(($self.SelectedRow / ($self.ProcessedData.Count - 1)) * ($scrollHeight - 1))
                    $scrollX = $contentX + $contentWidth - 1
                    
                    for ($i = 0; $i -lt $scrollHeight; $i++) {
                        $scrollY = $currentY - $scrollHeight + $i
                        $char = if ($i -eq $scrollPos) { "█" } else { "│" }
                        $color = if ($i -eq $scrollPos) { Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan) } else { Get-ThemeColor "Subtle" -Default ([ConsoleColor]::DarkGray) }
                        Write-BufferString -X $scrollX -Y $scrollY -Text $char -ForegroundColor $color
                    }
                }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            
            # Filter mode
            if ($Key.Modifiers -band [ConsoleModifiers]::Control) {
                switch ($Key.Key) {
                    ([ConsoleKey]::F) {
                        # Toggle filter focus
                        $self.FilterMode = -not $self.FilterMode
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::S) {
                        # Cycle sort column
                        if ($self.AllowSort) {
                            $sortableCols = @($self.Columns | Where-Object { $_.Sortable -ne $false })
                            if ($sortableCols.Count -gt 0) {
                                $currentIdx = [array]::IndexOf($sortableCols.Name, $self.SortColumn)
                                $nextIdx = ($currentIdx + 1) % $sortableCols.Count
                                $self.SortColumn = $sortableCols[$nextIdx].Name
                                & $self.ProcessData -self $self
                                Request-TuiRefresh
                            }
                        }
                        return $true
                    }
                    ([ConsoleKey]::A) {
                        # Select all (if multi-select)
                        if ($self.MultiSelect) {
                            if ($self.SelectedRows.Count -eq $self.ProcessedData.Count) {
                                $self.SelectedRows = @()
                            } else {
                                $self.SelectedRows = @(0..($self.ProcessedData.Count - 1))
                            }
                            if ($self.OnSelectionChange) {
                                & $self.OnSelectionChange -SelectedRows $self.SelectedRows
                            }
                            Request-TuiRefresh
                        }
                        return $true
                    }
                }
            }
            
            # Filter text input
            if ($self.FilterMode) {
                switch ($Key.Key) {
                    ([ConsoleKey]::Escape) {
                        $self.FilterMode = $false
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::Enter) {
                        $self.FilterMode = $false
                        & $self.ProcessData -self $self
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::Backspace) {
                        if ($self.FilterText.Length -gt 0) {
                            $self.FilterText = $self.FilterText.Substring(0, $self.FilterText.Length - 1)
                            & $self.ProcessData -self $self
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    default {
                        if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar)) {
                            $self.FilterText += $Key.KeyChar
                            & $self.ProcessData -self $self
                            Request-TuiRefresh
                            return $true
                        }
                    }
                }
                return $false
            }
            
            # Normal navigation
            switch ($Key.Key) {
                ([ConsoleKey]::UpArrow) {
                    if ($self.SelectedRow -gt 0) {
                        $self.SelectedRow--
                        
                        # Adjust page if needed
                        if ($self.SelectedRow -lt ($self.CurrentPage * $self.PageSize)) {
                            $self.CurrentPage--
                        }
                        
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::DownArrow) {
                    if ($self.SelectedRow -lt ($self.ProcessedData.Count - 1)) {
                        $self.SelectedRow++
                        
                        # Adjust page if needed
                        if ($self.SelectedRow -ge (($self.CurrentPage + 1) * $self.PageSize)) {
                            $self.CurrentPage++
                        }
                        
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::PageUp) {
                    if ($self.CurrentPage -gt 0) {
                        $self.CurrentPage--
                        $self.SelectedRow = $self.CurrentPage * $self.PageSize
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::PageDown) {
                    $totalPages = [Math]::Ceiling($self.ProcessedData.Count / [Math]::Max(1, $self.PageSize))
                    if ($self.CurrentPage -lt ($totalPages - 1)) {
                        $self.CurrentPage++
                        $self.SelectedRow = $self.CurrentPage * $self.PageSize
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::Home) {
                    $self.SelectedRow = 0
                    $self.CurrentPage = 0
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::End) {
                    $self.SelectedRow = $self.ProcessedData.Count - 1
                    $self.CurrentPage = [Math]::Floor($self.SelectedRow / [Math]::Max(1, $self.PageSize))
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::Spacebar) {
                    if ($self.MultiSelect) {
                        if ($self.SelectedRows -contains $self.SelectedRow) {
                            $self.SelectedRows = @($self.SelectedRows | Where-Object { $_ -ne $self.SelectedRow })
                        } else {
                            $self.SelectedRows += $self.SelectedRow
                        }
                        if ($self.OnSelectionChange) {
                            & $self.OnSelectionChange -SelectedRows $self.SelectedRows
                        }
                        Request-TuiRefresh
                    } elseif ($self.AllowSort) {
                        # Toggle sort direction
                        if ($self.SortDirection -eq "Ascending") {
                            $self.SortDirection = "Descending"
                        } else {
                            $self.SortDirection = "Ascending"
                        }
                        & $self.ProcessData -self $self
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::Enter) {
                    if ($self.OnRowSelect -and $self.ProcessedData.Count -gt 0) {
                        $selectedData = if ($self.MultiSelect) {
                            @($self.SelectedRows | ForEach-Object { $self.ProcessedData[$_] })
                        } else {
                            $self.ProcessedData[$self.SelectedRow]
                        }
                        & $self.OnRowSelect -SelectedData $selectedData -SelectedIndex $self.SelectedRow
                    }
                    return $true
                }
                ([ConsoleKey]::F) {
                    if ($self.AllowFilter) {
                        $self.FilterMode = $true
                        Request-TuiRefresh
                    }
                    return $true
                }
                default {
                    # Number keys for column sorting
                    if ($Key.KeyChar -match '\d' -and $self.AllowSort) {
                        $colIndex = [int]$Key.KeyChar.ToString() - 1
                        if ($colIndex -ge 0 -and $colIndex -lt $self.Columns.Count) {
                            $col = $self.Columns[$colIndex]
                            if ($col.Sortable -ne $false) {
                                if ($self.SortColumn -eq $col.Name) {
                                    # Toggle direction
                                    $self.SortDirection = if ($self.SortDirection -eq "Ascending") { "Descending" } else { "Ascending" }
                                } else {
                                    $self.SortColumn = $col.Name
                                    $self.SortDirection = "Ascending"
                                }
                                & $self.ProcessData -self $self
                                Request-TuiRefresh
                            }
                        }
                        return $true
                    }
                }
            }
            
            return $false
        }
        
        # Public methods
        RefreshData = {
            param($self)
            & $self.ProcessData -self $self
            Request-TuiRefresh
        }
        
        SetFilter = {
            param($self, $FilterText, $FilterColumn)
            $self.FilterText = $FilterText
            $self.FilterColumn = $FilterColumn
            & $self.ProcessData -self $self
            Request-TuiRefresh
        }
        
        ExportData = {
            param($self, $Format = "CSV", $FilePath)
            
            $exportData = if ($self.FilterText) { $self.ProcessedData } else { $self.Data }
            
            switch ($Format.ToUpper()) {
                "CSV" {
                    $exportData | Export-Csv -Path $FilePath -NoTypeInformation
                }
                "JSON" {
                    $exportData | ConvertTo-Json -Depth 10 | Set-Content -Path $FilePath
                }
                "HTML" {
                    # Simple HTML table export
                    $html = "<table border='1'><tr>"
                    foreach ($col in $self.Columns) {
                        $html += "<th>$($col.Header ?? $col.Name)</th>"
                    }
                    $html += "</tr>"
                    
                    foreach ($row in $exportData) {
                        $html += "<tr>"
                        foreach ($col in $self.Columns) {
                            $value = $row."$($col.Name)"
                            $html += "<td>$value</td>"
                        }
                        $html += "</tr>"
                    }
                    $html += "</table>"
                    
                    $html | Set-Content -Path $FilePath
                }
            }
        }
    }
    
    # Initialize data processing after component is created
    & $component.ProcessData -self $component
    
    return $component
}

#endregion

#region Tree View Component

function global:New-TuiTreeView {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "TreeView"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 40
        Height = $Props.Height ?? 20
        RootNode = $Props.RootNode ?? @{ Name = "Root"; Children = @(); Expanded = $true }
        SelectedNode = $null
        SelectedPath = @()
        FlattenedNodes = @()
        ScrollOffset = 0
        ShowRoot = $Props.ShowRoot ?? $true
        IsFocusable = $true
        Visible = $Props.Visible ?? $true
        Name = $Props.Name
        
        # Node structure:
        # @{
        #     Name = "Node Name"
        #     Data = @{}  # Custom data
        #     Children = @()
        #     Expanded = $false
        #     Icon = "📁"  # Optional
        #     Parent = $null  # Set automatically
        # }
        
        FlattenTree = {
            param($self)
            $flattened = @()
            
            $processNode = {
                param($Node, $Level, $Parent)
                
                $node.Parent = $Parent
                $node.Level = $Level
                
                if ($self.ShowRoot -or $Level -gt 0) {
                    $flattened += $Node
                }
                
                if ($Node.Expanded -and $Node.Children) {
                    foreach ($child in $Node.Children) {
                        & $processNode $child ($Level + 1) $Node
                    }
                }
            }
            
            & $processNode $self.RootNode 0 $null
            $self.FlattenedNodes = $flattened
        }
        
        Render = {
            param($self)
            
            # Check if component is visible
            if ($self.Visible -eq $false) { return }
            
            # Flatten tree first
            & $self.FlattenTree -self $self
            
            $borderColor = if ($self.IsFocused) { 
                Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
            } else { 
                Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
            }
            
            Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                -BorderColor $borderColor -Title " Tree View "
            
            $visibleHeight = $self.Height - 2
            $startIdx = $self.ScrollOffset
            $endIdx = [Math]::Min($self.FlattenedNodes.Count - 1, $startIdx + $visibleHeight - 1)
            
            $currentY = $self.Y + 1
            
            for ($i = $startIdx; $i -le $endIdx; $i++) {
                $node = $self.FlattenedNodes[$i]
                $isSelected = ($node -eq $self.SelectedNode)
                
                # Indentation
                $indent = "  " * $node.Level
                
                # Expand/collapse indicator
                $expandIcon = if ($node.Children -and $node.Children.Count -gt 0) {
                    if ($node.Expanded) { "▼" } else { "▶" }
                } else {
                    " "
                }
                
                # Node icon
                $nodeIcon = if ($node.Icon) { 
                    $node.Icon 
                } elseif ($node.Children -and $node.Children.Count -gt 0) {
                    if ($node.Expanded) { "📂" } else { "📁" }
                } else {
                    "📄"
                }
                
                # Colors
                $fg = if ($isSelected) { Get-ThemeColor "Background" -Default ([ConsoleColor]::Black) } else { Get-ThemeColor "Primary" -Default ([ConsoleColor]::White) }
                $bg = if ($isSelected) { Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan) } else { Get-ThemeColor "Background" -Default ([ConsoleColor]::Black) }
                
                # Clear line if selected
                if ($isSelected) {
                    Write-BufferString -X ($self.X + 1) -Y $currentY -Text (" " * ($self.Width - 2)) `
                        -BackgroundColor $bg
                }
                
                # Render node
                $nodeText = "$indent$expandIcon $nodeIcon $($node.Name)"
                if ($nodeText.Length -gt ($self.Width - 3)) {
                    $nodeText = $nodeText.Substring(0, $self.Width - 6) + "..."
                }
                
                Write-BufferString -X ($self.X + 1) -Y $currentY -Text $nodeText `
                    -ForegroundColor $fg -BackgroundColor $bg
                
                $currentY++
            }
            
            # Scrollbar
            if ($self.FlattenedNodes.Count -gt $visibleHeight) {
                $scrollHeight = $visibleHeight
                $scrollPos = if ($self.FlattenedNodes.Count -gt 1) {
                    $selectedIdx = [array]::IndexOf($self.FlattenedNodes, $self.SelectedNode)
                    [Math]::Floor(($selectedIdx / ($self.FlattenedNodes.Count - 1)) * ($scrollHeight - 1))
                } else { 0 }
                
                for ($i = 0; $i -lt $scrollHeight; $i++) {
                    $char = if ($i -eq $scrollPos) { "█" } else { "│" }
                    $color = if ($i -eq $scrollPos) { Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan) } else { Get-ThemeColor "Subtle" -Default ([ConsoleColor]::DarkGray) }
                    Write-BufferString -X ($self.X + $self.Width - 2) -Y ($self.Y + 1 + $i) `
                        -Text $char -ForegroundColor $color
                }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            
            if ($self.FlattenedNodes.Count -eq 0) { return $false }
            
            $currentIdx = if ($self.SelectedNode) {
                [array]::IndexOf($self.FlattenedNodes, $self.SelectedNode)
            } else { 0 }
            
            switch ($Key.Key) {
                ([ConsoleKey]::UpArrow) {
                    if ($currentIdx -gt 0) {
                        $currentIdx--
                        $self.SelectedNode = $self.FlattenedNodes[$currentIdx]
                        
                        # Adjust scroll
                        if ($currentIdx -lt $self.ScrollOffset) {
                            $self.ScrollOffset = $currentIdx
                        }
                        
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::DownArrow) {
                    if ($currentIdx -lt ($self.FlattenedNodes.Count - 1)) {
                        $currentIdx++
                        $self.SelectedNode = $self.FlattenedNodes[$currentIdx]
                        
                        # Adjust scroll
                        $visibleHeight = $self.Height - 2
                        if ($currentIdx -ge ($self.ScrollOffset + $visibleHeight)) {
                            $self.ScrollOffset = $currentIdx - $visibleHeight + 1
                        }
                        
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::LeftArrow) {
                    if ($self.SelectedNode) {
                        if ($self.SelectedNode.Expanded -and $self.SelectedNode.Children) {
                            # Collapse
                            $self.SelectedNode.Expanded = $false
                            Request-TuiRefresh
                        } elseif ($self.SelectedNode.Parent) {
                            # Move to parent
                            $self.SelectedNode = $self.SelectedNode.Parent
                            Request-TuiRefresh
                        }
                    }
                    return $true
                }
                ([ConsoleKey]::RightArrow) {
                    if ($self.SelectedNode -and $self.SelectedNode.Children -and $self.SelectedNode.Children.Count -gt 0) {
                        if (-not $self.SelectedNode.Expanded) {
                            # Expand
                            $self.SelectedNode.Expanded = $true
                            Request-TuiRefresh
                        } else {
                            # Move to first child
                            $self.SelectedNode = $self.SelectedNode.Children[0]
                            Request-TuiRefresh
                        }
                    }
                    return $true
                }
                ([ConsoleKey]::Spacebar) {
                    if ($self.SelectedNode -and $self.SelectedNode.Children -and $self.SelectedNode.Children.Count -gt 0) {
                        $self.SelectedNode.Expanded = -not $self.SelectedNode.Expanded
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::Enter) {
                    if ($self.OnNodeSelect -and $self.SelectedNode) {
                        # Build path
                        $path = @()
                        $current = $self.SelectedNode
                        while ($current) {
                            $path = @($current.Name) + $path
                            $current = $current.Parent
                        }
                        
                        & $self.OnNodeSelect -Node $self.SelectedNode -Path $path
                    }
                    return $true
                }
                ([ConsoleKey]::Home) {
                    if ($self.FlattenedNodes.Count -gt 0) {
                        $self.SelectedNode = $self.FlattenedNodes[0]
                        $self.ScrollOffset = 0
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::End) {
                    if ($self.FlattenedNodes.Count -gt 0) {
                        $self.SelectedNode = $self.FlattenedNodes[-1]
                        $visibleHeight = $self.Height - 2
                        $self.ScrollOffset = [Math]::Max(0, $self.FlattenedNodes.Count - $visibleHeight)
                        Request-TuiRefresh
                    }
                    return $true
                }
                { $_ -in @([ConsoleKey]::Add, [ConsoleKey]::OemPlus) } {
                    # Expand all
                    $expandAll = {
                        param($Node)
                        $Node.Expanded = $true
                        foreach ($child in $Node.Children) {
                            & $expandAll $child
                        }
                    }
                    & $expandAll $self.RootNode
                    Request-TuiRefresh
                    return $true
                }
                { $_ -in @([ConsoleKey]::Subtract, [ConsoleKey]::OemMinus) } {
                    # Collapse all
                    $collapseAll = {
                        param($Node)
                        $Node.Expanded = $false
                        foreach ($child in $Node.Children) {
                            & $collapseAll $child
                        }
                    }
                    & $collapseAll $self.RootNode
                    $self.RootNode.Expanded = $true  # Keep root expanded
                    Request-TuiRefresh
                    return $true
                }
            }
            
            return $false
        }
        
        # Public methods
        AddNode = {
            param($self, $ParentNode, $NewNode)
            if (-not $ParentNode.Children) {
                $ParentNode.Children = @()
            }
            $ParentNode.Children += $NewNode
            $NewNode.Parent = $ParentNode
            Request-TuiRefresh
        }
        
        RemoveNode = {
            param($self, $Node)
            if ($Node.Parent) {
                $Node.Parent.Children = @($Node.Parent.Children | Where-Object { $_ -ne $Node })
                if ($self.SelectedNode -eq $Node) {
                    $self.SelectedNode = $Node.Parent
                }
                Request-TuiRefresh
            }
        }
        
        FindNode = {
            param($self, $Predicate)
            
            $find = {
                param($Node)
                if (& $Predicate $Node) { return $Node }
                foreach ($child in $Node.Children) {
                    $found = & $find $child
                    if ($found) { return $found }
                }
                return $null
            }
            
            return & $find $self.RootNode
        }
    }
    
    return $component
}

#endregion

Export-ModuleMember -Function @(
    'New-TuiDataTable',
    'New-TuiTreeView'
)
# Advanced Input Components Module
# Enhanced input components from the TUI Upgrade Roadmap

#region DateTime Components with Calendar Grid

function global:New-TuiCalendarPicker {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "CalendarPicker"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 30
        Height = $Props.Height ?? 10
        Value = $Props.Value ?? (Get-Date)
        Mode = $Props.Mode ?? "Date"  # Date, DateTime, Time
        IsFocusable = $true
        CurrentView = "Day"  # Day, Month, Year
        SelectedDate = $Props.Value ?? (Get-Date)
        ViewDate = $Props.Value ?? (Get-Date)
        
        Render = {
            param($self)
            
            $borderColor = if ($self.IsFocused) { 
                Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
            } else { 
                Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
            }
            
            # Main container
            Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                -BorderColor $borderColor -Title " Calendar "
            
            # Header with navigation
            $headerY = $self.Y + 1
            $monthYear = $self.ViewDate.ToString("MMMM yyyy")
            $headerX = $self.X + [Math]::Floor(($self.Width - $monthYear.Length) / 2)
            
            Write-BufferString -X ($self.X + 2) -Y $headerY -Text "◄" -ForegroundColor $borderColor
            Write-BufferString -X $headerX -Y $headerY -Text $monthYear -ForegroundColor (Get-ThemeColor "Header")
            Write-BufferString -X ($self.X + $self.Width - 3) -Y $headerY -Text "►" -ForegroundColor $borderColor
            
            # Day headers
            $dayHeaderY = $headerY + 2
            $days = @("Su", "Mo", "Tu", "We", "Th", "Fr", "Sa")
            $dayWidth = 4
            $startX = $self.X + 2
            
            for ($i = 0; $i -lt $days.Count; $i++) {
                Write-BufferString -X ($startX + ($i * $dayWidth)) -Y $dayHeaderY `
                    -Text $days[$i] -ForegroundColor (Get-ThemeColor "Subtle")
            }
            
            # Calendar grid
            $firstDay = Get-Date -Year $self.ViewDate.Year -Month $self.ViewDate.Month -Day 1
            $startDayOfWeek = [int]$firstDay.DayOfWeek
            $daysInMonth = [DateTime]::DaysInMonth($self.ViewDate.Year, $self.ViewDate.Month)
            
            $currentDay = 1
            $calendarY = $dayHeaderY + 1
            
            for ($week = 0; $week -lt 6; $week++) {
                if ($currentDay -gt $daysInMonth) { break }
                
                for ($dayOfWeek = 0; $dayOfWeek -lt 7; $dayOfWeek++) {
                    $x = $startX + ($dayOfWeek * $dayWidth)
                    
                    if ($week -eq 0 -and $dayOfWeek -lt $startDayOfWeek) {
                        continue
                    }
                    
                    if ($currentDay -le $daysInMonth) {
                        $isSelected = ($currentDay -eq $self.SelectedDate.Day -and 
                                     $self.ViewDate.Month -eq $self.SelectedDate.Month -and 
                                     $self.ViewDate.Year -eq $self.SelectedDate.Year)
                        
                        $isToday = ($currentDay -eq (Get-Date).Day -and 
                                  $self.ViewDate.Month -eq (Get-Date).Month -and 
                                  $self.ViewDate.Year -eq (Get-Date).Year)
                        
                        $fg = if ($isSelected) { 
                            Get-ThemeColor "Background" 
                        } elseif ($isToday) { 
                            Get-ThemeColor "Accent" 
                        } else { 
                            Get-ThemeColor "Primary" 
                        }
                        
                        $bg = if ($isSelected) { 
                            Get-ThemeColor "Accent" 
                        } else { 
                            Get-ThemeColor "Background" 
                        }
                        
                        $dayText = $currentDay.ToString().PadLeft(2)
                        Write-BufferString -X $x -Y ($calendarY + $week) -Text $dayText `
                            -ForegroundColor $fg -BackgroundColor $bg
                        
                        $currentDay++
                    }
                }
            }
            
            # Time picker if in DateTime mode
            if ($self.Mode -eq "DateTime") {
                $timeY = $self.Y + $self.Height - 2
                $timeStr = $self.SelectedDate.ToString("HH:mm")
                Write-BufferString -X ($self.X + 2) -Y $timeY -Text "Time: $timeStr" `
                    -ForegroundColor (Get-ThemeColor "Primary")
            }
        }
        
        HandleInput = {
            param($self, $Key)
            
            $handled = $true
            $date = $self.SelectedDate
            $viewDate = $self.ViewDate
            
            switch ($Key.Key) {
                ([ConsoleKey]::LeftArrow) {
                    if ($Key.Modifiers -band [ConsoleModifiers]::Control) {
                        # Previous month
                        $self.ViewDate = $viewDate.AddMonths(-1)
                    } else {
                        # Previous day
                        $date = $date.AddDays(-1)
                        if ($date.Month -ne $viewDate.Month) {
                            $self.ViewDate = $date
                        }
                    }
                }
                ([ConsoleKey]::RightArrow) {
                    if ($Key.Modifiers -band [ConsoleModifiers]::Control) {
                        # Next month
                        $self.ViewDate = $viewDate.AddMonths(1)
                    } else {
                        # Next day
                        $date = $date.AddDays(1)
                        if ($date.Month -ne $viewDate.Month) {
                            $self.ViewDate = $date
                        }
                    }
                }
                ([ConsoleKey]::UpArrow) {
                    $date = $date.AddDays(-7)
                    if ($date.Month -ne $viewDate.Month) {
                        $self.ViewDate = $date
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    $date = $date.AddDays(7)
                    if ($date.Month -ne $viewDate.Month) {
                        $self.ViewDate = $date
                    }
                }
                ([ConsoleKey]::PageUp) {
                    $self.ViewDate = $viewDate.AddMonths(-1)
                    $date = Get-Date -Year $self.ViewDate.Year -Month $self.ViewDate.Month `
                        -Day ([Math]::Min($date.Day, [DateTime]::DaysInMonth($self.ViewDate.Year, $self.ViewDate.Month)))
                }
                ([ConsoleKey]::PageDown) {
                    $self.ViewDate = $viewDate.AddMonths(1)
                    $date = Get-Date -Year $self.ViewDate.Year -Month $self.ViewDate.Month `
                        -Day ([Math]::Min($date.Day, [DateTime]::DaysInMonth($self.ViewDate.Year, $self.ViewDate.Month)))
                }
                ([ConsoleKey]::Home) {
                    $date = Get-Date
                    $self.ViewDate = $date
                }
                ([ConsoleKey]::Enter) {
                    if ($self.OnSelect) {
                        & $self.OnSelect -Date $date
                    }
                }
                default {
                    $handled = $false
                }
            }
            
            if ($handled) {
                $self.SelectedDate = $date
                if ($self.OnChange) {
                    & $self.OnChange -NewValue $date
                }
                Request-TuiRefresh
            }
            
            return $handled
        }
    }
    
    return $component
}

#endregion

#region Enhanced Dropdown with Search

function global:New-TuiSearchableDropdown {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "SearchableDropdown"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 30
        Height = $Props.Height ?? 3
        Options = $Props.Options ?? @()
        Value = $Props.Value
        Placeholder = $Props.Placeholder ?? "Type to search..."
        MaxDisplayItems = $Props.MaxDisplayItems ?? 5
        AllowCustomValue = $Props.AllowCustomValue ?? $false
        IsFocusable = $true
        IsOpen = $false
        SearchText = ""
        FilteredOptions = @()
        SelectedIndex = 0
        
        Render = {
            param($self)
            
            $borderColor = if ($self.IsFocused) { 
                Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
            } else { 
                Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
            }
            
            # Main dropdown box
            Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                -BorderColor $borderColor
            
            # Display text
            $displayText = ""
            if ($self.IsOpen) {
                $displayText = $self.SearchText
                if ([string]::IsNullOrEmpty($displayText) -and -not $self.IsFocused) {
                    $displayText = $self.Placeholder
                }
            } else {
                if ($self.Value) {
                    $selected = $self.Options | Where-Object { $_.Value -eq $self.Value } | Select-Object -First 1
                    if ($selected) {
                        $displayText = $selected.Display
                    } else {
                        $displayText = $self.Value.ToString()
                    }
                } else {
                    $displayText = "Select..."
                }
            }
            
            Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $displayText
            
            # Dropdown indicator
            $indicator = if ($self.IsOpen) { "▲" } else { "▼" }
            Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text $indicator `
                -ForegroundColor $borderColor
            
            # Cursor for search mode
            if ($self.IsOpen -and $self.IsFocused) {
                $cursorX = $self.X + 2 + $self.SearchText.Length
                if ($cursorX -lt ($self.X + $self.Width - 3)) {
                    Write-BufferString -X $cursorX -Y ($self.Y + 1) -Text "_" `
                        -BackgroundColor (Get-ThemeColor "Accent")
                }
            }
            
            # Options dropdown
            if ($self.IsOpen -and $self.FilteredOptions.Count -gt 0) {
                $dropHeight = [Math]::Min($self.FilteredOptions.Count, $self.MaxDisplayItems) + 2
                Write-BufferBox -X $self.X -Y ($self.Y + $self.Height) -Width $self.Width -Height $dropHeight `
                    -BorderColor $borderColor -BackgroundColor (Get-ThemeColor "Background")
                
                $startIdx = 0
                if ($self.SelectedIndex -ge $self.MaxDisplayItems) {
                    $startIdx = $self.SelectedIndex - $self.MaxDisplayItems + 1
                }
                
                $endIdx = [Math]::Min($startIdx + $self.MaxDisplayItems - 1, $self.FilteredOptions.Count - 1)
                
                for ($i = $startIdx; $i -le $endIdx; $i++) {
                    $option = $self.FilteredOptions[$i]
                    $y = $self.Y + $self.Height + 1 + ($i - $startIdx)
                    
                    $isSelected = ($i -eq $self.SelectedIndex)
                    $fg = if ($isSelected) { Get-ThemeColor "Background" } else { Get-ThemeColor "Primary" }
                    $bg = if ($isSelected) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Background" }
                    
                    $text = $option.Display
                    if ($text.Length -gt ($self.Width - 4)) {
                        $text = $text.Substring(0, $self.Width - 7) + "..."
                    }
                    
                    # Highlight matching text
                    if ($self.SearchText.Length -gt 0 -and -not $isSelected) {
                        $matchIndex = $text.IndexOf($self.SearchText, [StringComparison]::OrdinalIgnoreCase)
                        if ($matchIndex -ge 0) {
                            # Draw text before match
                            if ($matchIndex -gt 0) {
                                Write-BufferString -X ($self.X + 2) -Y $y `
                                    -Text $text.Substring(0, $matchIndex) -ForegroundColor $fg
                            }
                            
                            # Draw matching text highlighted
                            Write-BufferString -X ($self.X + 2 + $matchIndex) -Y $y `
                                -Text $text.Substring($matchIndex, $self.SearchText.Length) `
                                -ForegroundColor (Get-ThemeColor "Warning")
                            
                            # Draw text after match
                            $afterMatch = $matchIndex + $self.SearchText.Length
                            if ($afterMatch -lt $text.Length) {
                                Write-BufferString -X ($self.X + 2 + $afterMatch) -Y $y `
                                    -Text $text.Substring($afterMatch) -ForegroundColor $fg
                            }
                            
                            continue
                        }
                    }
                    
                    Write-BufferString -X ($self.X + 2) -Y $y -Text $text `
                        -ForegroundColor $fg -BackgroundColor $bg
                }
                
                # Scrollbar if needed
                if ($self.FilteredOptions.Count -gt $self.MaxDisplayItems) {
                    $scrollHeight = $self.MaxDisplayItems
                    $scrollPos = [Math]::Floor(($self.SelectedIndex / ($self.FilteredOptions.Count - 1)) * ($scrollHeight - 1))
                    
                    for ($i = 0; $i -lt $scrollHeight; $i++) {
                        $char = if ($i -eq $scrollPos) { "█" } else { "│" }
                        $color = if ($i -eq $scrollPos) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Subtle" }
                        Write-BufferString -X ($self.X + $self.Width - 2) -Y ($self.Y + $self.Height + 1 + $i) `
                            -Text $char -ForegroundColor $color
                    }
                }
            }
        }
        
        FilterOptions = {
            if ([string]::IsNullOrEmpty($this.SearchText)) {
                $this.FilteredOptions = $this.Options
            } else {
                $this.FilteredOptions = @($this.Options | Where-Object {
                    $_.Display -like "*$($this.SearchText)*"
                })
                
                # Add custom value option if allowed and no exact match
                if ($this.AllowCustomValue) {
                    $exactMatch = $this.FilteredOptions | Where-Object { $_.Display -eq $this.SearchText }
                    if (-not $exactMatch) {
                        $this.FilteredOptions = @(@{
                            Display = $this.SearchText
                            Value = $this.SearchText
                            IsCustom = $true
                        }) + $this.FilteredOptions
                    }
                }
            }
            
            # Reset selection to first item
            $this.SelectedIndex = 0
        }
        
        HandleInput = {
            param($self, $Key)
            
            if (-not $self.IsOpen) {
                switch ($Key.Key) {
                    { $_ -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar, [ConsoleKey]::DownArrow) } {
                        $self.IsOpen = $true
                        $self.SearchText = ""
                        & $self.FilterOptions
                        Request-TuiRefresh
                        return $true
                    }
                }
                return $false
            }
            
            # Handle open dropdown
            switch ($Key.Key) {
                ([ConsoleKey]::Escape) {
                    $self.IsOpen = $false
                    $self.SearchText = ""
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::Enter) {
                    if ($self.FilteredOptions.Count -gt 0) {
                        $selected = $self.FilteredOptions[$self.SelectedIndex]
                        if ($self.OnChange) {
                            & $self.OnChange -NewValue $selected.Value -Option $selected
                        }
                        $self.Value = $selected.Value
                        $self.IsOpen = $false
                        $self.SearchText = ""
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::UpArrow) {
                    if ($self.SelectedIndex -gt 0) {
                        $self.SelectedIndex--
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::DownArrow) {
                    if ($self.SelectedIndex -lt ($self.FilteredOptions.Count - 1)) {
                        $self.SelectedIndex++
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::Backspace) {
                    if ($self.SearchText.Length -gt 0) {
                        $self.SearchText = $self.SearchText.Substring(0, $self.SearchText.Length - 1)
                        & $self.FilterOptions
                        Request-TuiRefresh
                    }
                    return $true
                }
                default {
                    if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar)) {
                        $self.SearchText += $Key.KeyChar
                        & $self.FilterOptions
                        Request-TuiRefresh
                        return $true
                    }
                }
            }
            
            return $false
        }
    }
    
    return $component
}

#endregion

#region Multi-Select Components

function global:New-TuiMultiSelect {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "MultiSelect"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 30
        Height = $Props.Height ?? 10
        Options = $Props.Options ?? @()
        SelectedValues = $Props.SelectedValues ?? @()
        Title = $Props.Title ?? "Select items"
        AllowSelectAll = $Props.AllowSelectAll ?? $true
        IsFocusable = $true
        SelectedIndex = 0
        ScrollOffset = 0
        
        Render = {
            param($self)
            
            $borderColor = if ($self.IsFocused) { 
                Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
            } else { 
                Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
            }
            
            Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                -BorderColor $borderColor -Title " $($self.Title) "
            
            # Select all option
            $currentY = $self.Y + 1
            if ($self.AllowSelectAll) {
                $allSelected = $self.Options.Count -eq $self.SelectedValues.Count
                $checkbox = if ($allSelected) { "[X]" } else { "[ ]" }
                $fg = if ($self.SelectedIndex -eq -1) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
                Write-BufferString -X ($self.X + 2) -Y $currentY -Text "$checkbox Select All" `
                    -ForegroundColor $fg
                $currentY += 2
            }
            
            # Options
            $visibleHeight = $self.Height - 4
            if ($self.AllowSelectAll) { $visibleHeight -= 2 }
            
            $startIdx = $self.ScrollOffset
            $endIdx = [Math]::Min($self.Options.Count - 1, $startIdx + $visibleHeight - 1)
            
            for ($i = $startIdx; $i -le $endIdx; $i++) {
                $option = $self.Options[$i]
                $isChecked = $self.SelectedValues -contains $option.Value
                $isHighlighted = ($i -eq $self.SelectedIndex)
                
                $checkbox = if ($isChecked) { "[X]" } else { "[ ]" }
                $fg = if ($isHighlighted) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Primary" }
                
                $text = "$checkbox $($option.Display)"
                if ($text.Length -gt ($self.Width - 4)) {
                    $text = $text.Substring(0, $self.Width - 7) + "..."
                }
                
                Write-BufferString -X ($self.X + 2) -Y $currentY -Text $text -ForegroundColor $fg
                $currentY++
            }
            
            # Status line
            $statusY = $self.Y + $self.Height - 2
            $statusText = "$($self.SelectedValues.Count) of $($self.Options.Count) selected"
            Write-BufferString -X ($self.X + 2) -Y $statusY -Text $statusText `
                -ForegroundColor (Get-ThemeColor "Subtle")
        }
        
        HandleInput = {
            param($self, $Key)
            
            $maxIndex = $self.Options.Count - 1
            if ($self.AllowSelectAll) { $maxIndex++ }
            
            switch ($Key.Key) {
                ([ConsoleKey]::UpArrow) {
                    if ($self.AllowSelectAll -and $self.SelectedIndex -eq 0) {
                        $self.SelectedIndex = -1
                    } elseif ($self.SelectedIndex -gt 0 -or ($self.AllowSelectAll -and $self.SelectedIndex -gt -1)) {
                        $self.SelectedIndex--
                        if ($self.SelectedIndex -ge 0 -and $self.SelectedIndex -lt $self.ScrollOffset) {
                            $self.ScrollOffset = $self.SelectedIndex
                        }
                    }
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::DownArrow) {
                    if ($self.SelectedIndex -lt ($self.Options.Count - 1)) {
                        $self.SelectedIndex++
                        $visibleHeight = $self.Height - 4
                        if ($self.AllowSelectAll) { $visibleHeight -= 2 }
                        if ($self.SelectedIndex -ge ($self.ScrollOffset + $visibleHeight)) {
                            $self.ScrollOffset = $self.SelectedIndex - $visibleHeight + 1
                        }
                    }
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::Spacebar) {
                    if ($self.SelectedIndex -eq -1 -and $self.AllowSelectAll) {
                        # Toggle all
                        if ($self.SelectedValues.Count -eq $self.Options.Count) {
                            $self.SelectedValues = @()
                        } else {
                            $self.SelectedValues = @($self.Options | ForEach-Object { $_.Value })
                        }
                    } elseif ($self.SelectedIndex -ge 0) {
                        # Toggle individual
                        $option = $self.Options[$self.SelectedIndex]
                        if ($self.SelectedValues -contains $option.Value) {
                            $self.SelectedValues = @($self.SelectedValues | Where-Object { $_ -ne $option.Value })
                        } else {
                            $self.SelectedValues += $option.Value
                        }
                    }
                    
                    if ($self.OnChange) {
                        & $self.OnChange -SelectedValues $self.SelectedValues
                    }
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::Enter) {
                    if ($self.OnSubmit) {
                        & $self.OnSubmit -SelectedValues $self.SelectedValues
                    }
                    return $true
                }
            }
            
            return $false
        }
    }
    
    return $component
}

#endregion

#region Numeric Input Components

function global:New-TuiNumberInput {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "NumberInput"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 20
        Height = $Props.Height ?? 3
        Value = $Props.Value ?? 0
        Min = $Props.Min ?? 0
        Max = $Props.Max ?? 100
        Step = $Props.Step ?? 1
        DecimalPlaces = $Props.DecimalPlaces ?? 0
        IsFocusable = $true
        TextValue = ($Props.Value ?? 0).ToString()
        CursorPosition = 0
        
        Render = {
            param($self)
            
            $borderColor = if ($self.IsFocused) { 
                Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
            } else { 
                Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
            }
            
            Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                -BorderColor $borderColor
            
            # Value display
            $displayValue = $self.TextValue
            if ($displayValue.Length -gt ($self.Width - 6)) {
                $displayValue = $displayValue.Substring(0, $self.Width - 9) + "..."
            }
            
            Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $displayValue
            
            # Cursor
            if ($self.IsFocused -and $self.CursorPosition -le $displayValue.Length) {
                $cursorX = $self.X + 2 + $self.CursorPosition
                if ($cursorX -lt ($self.X + $self.Width - 4)) {
                    Write-BufferString -X $cursorX -Y ($self.Y + 1) -Text "_" `
                        -BackgroundColor (Get-ThemeColor "Accent")
                }
            }
            
            # Spinner buttons
            Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text "▲" `
                -ForegroundColor $borderColor
            Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text "▼" `
                -ForegroundColor $borderColor
            
            # Min/Max indicators
            if ($self.Value -le $self.Min) {
                Write-BufferString -X ($self.X + 1) -Y ($self.Y + 1) -Text "⊥" `
                    -ForegroundColor (Get-ThemeColor "Warning")
            }
            if ($self.Value -ge $self.Max) {
                Write-BufferString -X ($self.X + $self.Width - 2) -Y ($self.Y + 1) -Text "⊤" `
                    -ForegroundColor (Get-ThemeColor "Warning")
            }
        }
        
        ValidateAndUpdate = {
            try {
                $newValue = [double]$this.TextValue
                $newValue = [Math]::Max($this.Min, [Math]::Min($this.Max, $newValue))
                
                if ($this.DecimalPlaces -eq 0) {
                    $newValue = [Math]::Floor($newValue)
                } else {
                    $newValue = [Math]::Round($newValue, $this.DecimalPlaces)
                }
                
                $this.Value = $newValue
                $this.TextValue = $newValue.ToString("F$($this.DecimalPlaces)")
                
                if ($this.OnChange) {
                    & $this.OnChange -NewValue $newValue
                }
                
                return $true
            } catch {
                # Invalid input, restore previous value
                $this.TextValue = $this.Value.ToString("F$($this.DecimalPlaces)")
                return $false
            }
        }
        
        HandleInput = {
            param($self, $Key)
            
            switch ($Key.Key) {
                ([ConsoleKey]::UpArrow) {
                    $self.Value = [Math]::Min($self.Max, $self.Value + $self.Step)
                    $self.TextValue = $self.Value.ToString("F$($self.DecimalPlaces)")
                    $self.CursorPosition = $self.TextValue.Length
                    if ($self.OnChange) {
                        & $self.OnChange -NewValue $self.Value
                    }
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::DownArrow) {
                    $self.Value = [Math]::Max($self.Min, $self.Value - $self.Step)
                    $self.TextValue = $self.Value.ToString("F$($self.DecimalPlaces)")
                    $self.CursorPosition = $self.TextValue.Length
                    if ($self.OnChange) {
                        & $self.OnChange -NewValue $self.Value
                    }
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::LeftArrow) {
                    if ($self.CursorPosition -gt 0) {
                        $self.CursorPosition--
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::RightArrow) {
                    if ($self.CursorPosition -lt $self.TextValue.Length) {
                        $self.CursorPosition++
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::Home) {
                    $self.CursorPosition = 0
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::End) {
                    $self.CursorPosition = $self.TextValue.Length
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::Backspace) {
                    if ($self.CursorPosition -gt 0) {
                        $self.TextValue = $self.TextValue.Remove($self.CursorPosition - 1, 1)
                        $self.CursorPosition--
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::Delete) {
                    if ($self.CursorPosition -lt $self.TextValue.Length) {
                        $self.TextValue = $self.TextValue.Remove($self.CursorPosition, 1)
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::Enter) {
                    & $self.ValidateAndUpdate
                    Request-TuiRefresh
                    return $true
                }
                default {
                    if ($Key.KeyChar -and ($Key.KeyChar -match '[\d\.\-]')) {
                        $self.TextValue = $self.TextValue.Insert($self.CursorPosition, $Key.KeyChar)
                        $self.CursorPosition++
                        Request-TuiRefresh
                        return $true
                    }
                }
            }
            
            return $false
        }
    }
    
    return $component
}

function global:New-TuiSlider {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "Slider"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 30
        Height = $Props.Height ?? 1
        Value = $Props.Value ?? 50
        Min = $Props.Min ?? 0
        Max = $Props.Max ?? 100
        Step = $Props.Step ?? 1
        ShowValue = $Props.ShowValue ?? $true
        IsFocusable = $true
        
        Render = {
            param($self)
            
            $fg = if ($self.IsFocused) { 
                Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
            } else { 
                Get-ThemeColor "Primary" -Default ([ConsoleColor]::White)
            }
            
            # Calculate position
            $range = $self.Max - $self.Min
            $percent = ($self.Value - $self.Min) / $range
            $trackWidth = $self.Width - 2
            $thumbPos = [Math]::Floor($trackWidth * $percent)
            
            # Draw track
            $track = "─" * $trackWidth
            Write-BufferString -X ($self.X + 1) -Y $self.Y -Text $track -ForegroundColor (Get-ThemeColor "Subtle")
            
            # Draw filled portion
            if ($thumbPos -gt 0) {
                $filled = "═" * $thumbPos
                Write-BufferString -X ($self.X + 1) -Y $self.Y -Text $filled -ForegroundColor $fg
            }
            
            # Draw thumb
            Write-BufferString -X ($self.X + 1 + $thumbPos) -Y $self.Y -Text "●" -ForegroundColor $fg
            
            # Draw bounds
            Write-BufferString -X $self.X -Y $self.Y -Text "[" -ForegroundColor $fg
            Write-BufferString -X ($self.X + $self.Width - 1) -Y $self.Y -Text "]" -ForegroundColor $fg
            
            # Show value
            if ($self.ShowValue) {
                $valueText = $self.Value.ToString()
                $valueX = $self.X + [Math]::Floor(($self.Width - $valueText.Length) / 2)
                Write-BufferString -X $valueX -Y ($self.Y + 1) -Text $valueText -ForegroundColor $fg
            }
        }
        
        HandleInput = {
            param($self, $Key)
            
            $handled = $true
            $oldValue = $self.Value
            
            switch ($Key.Key) {
                ([ConsoleKey]::LeftArrow) {
                    $self.Value = [Math]::Max($self.Min, $self.Value - $self.Step)
                }
                ([ConsoleKey]::RightArrow) {
                    $self.Value = [Math]::Min($self.Max, $self.Value + $self.Step)
                }
                ([ConsoleKey]::Home) {
                    $self.Value = $self.Min
                }
                ([ConsoleKey]::End) {
                    $self.Value = $self.Max
                }
                ([ConsoleKey]::PageDown) {
                    $largeStep = [Math]::Max($self.Step, ($self.Max - $self.Min) / 10)
                    $self.Value = [Math]::Max($self.Min, $self.Value - $largeStep)
                }
                ([ConsoleKey]::PageUp) {
                    $largeStep = [Math]::Max($self.Step, ($self.Max - $self.Min) / 10)
                    $self.Value = [Math]::Min($self.Max, $self.Value + $largeStep)
                }
                default {
                    $handled = $false
                }
            }
            
            if ($handled -and $self.Value -ne $oldValue) {
                if ($self.OnChange) {
                    & $self.OnChange -NewValue $self.Value
                }
                Request-TuiRefresh
            }
            
            return $handled
        }
    }
    
    return $component
}

#endregion

Export-ModuleMember -Function @(
    'New-TuiCalendarPicker',
    'New-TuiSearchableDropdown',
    'New-TuiMultiSelect',
    'New-TuiNumberInput',
    'New-TuiSlider'
)
# TUI Component Library - COMPLIANT VERSION
# Stateful component factories following the canonical architecture

#region Basic Components

function global:New-TuiLabel {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "Label"
        IsFocusable = $false
        
        # Properties (from Props)
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 10
        Height = $Props.Height ?? 1
        Visible = $Props.Visible ?? $true
        Text = $Props.Text ?? ""
        ForegroundColor = $Props.ForegroundColor
        Name = $Props.Name
        
        # Methods
        Render = {
            param($self)
            if (-not $self.Visible) { return }
            
            $fg = if ($self.ForegroundColor) { $self.ForegroundColor } else { Get-ThemeColor "Primary" }
            Write-BufferString -X $self.X -Y $self.Y -Text $self.Text -ForegroundColor $fg
        }
        
        HandleInput = {
            param($self, $Key)
            return $false
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

function global:New-TuiButton {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "Button"
        IsFocusable = $true
        
        # Properties (from Props)
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 10
        Height = $Props.Height ?? 3
        Visible = $Props.Visible ?? $true
        Text = $Props.Text ?? "Button"
        Name = $Props.Name
        
        # Internal State
        IsPressed = $false
        
        # Event Handlers (from Props)
        OnClick = $Props.OnClick
        
        # Methods
        Render = {
            param($self)
            if (-not $self.Visible) { return }
            
            $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Primary" }
            $bgColor = if ($self.IsPressed) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Background" }
            $fgColor = if ($self.IsPressed) { Get-ThemeColor "Background" } else { $borderColor }
            
            Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                -BorderColor $borderColor -BackgroundColor $bgColor
                
            $textX = $self.X + [Math]::Floor(($self.Width - $self.Text.Length) / 2)
            Write-BufferString -X $textX -Y ($self.Y + 1) -Text $self.Text `
                -ForegroundColor $fgColor -BackgroundColor $bgColor
        }
        
        HandleInput = {
            param($self, $Key)
            if ($Key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                if ($self.OnClick) {
                    & $self.OnClick
                }
                Request-TuiRefresh
                return $true
            }
            return $false
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

function global:New-TuiTextBox {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "TextBox"
        IsFocusable = $true
        
        # Properties (from Props)
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 20
        Height = $Props.Height ?? 3
        Visible = $Props.Visible ?? $true
        Text = $Props.Text ?? ""
        Placeholder = $Props.Placeholder ?? ""
        MaxLength = $Props.MaxLength ?? 100
        Name = $Props.Name
        
        # Internal State
        CursorPosition = $Props.CursorPosition ?? 0
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
        
        # Methods
        Render = {
            param($self)
            if (-not $self.Visible) { return }
            
            $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
            Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height 3 -BorderColor $borderColor
            
            $displayText = if ($self.Text) { $self.Text } else { "" }
            if ([string]::IsNullOrEmpty($displayText) -and -not $self.IsFocused) { 
                $displayText = if ($self.Placeholder) { $self.Placeholder } else { "" }
            }
            
            $maxDisplayLength = $self.Width - 4
            if ($displayText.Length -gt $maxDisplayLength) {
                $displayText = $displayText.Substring(0, $maxDisplayLength)
            }
            
            Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $displayText
            
            if ($self.IsFocused -and $self.CursorPosition -le $displayText.Length) {
                $cursorX = $self.X + 2 + $self.CursorPosition
                Write-BufferString -X $cursorX -Y ($self.Y + 1) -Text "_" `
                    -BackgroundColor (Get-ThemeColor "Accent")
            }
        }
        
        HandleInput = {
            param($self, $Key)
            $text = if ($self.Text) { $self.Text } else { "" }
            $cursorPos = if ($null -ne $self.CursorPosition) { $self.CursorPosition } else { 0 }
            $oldText = $text
            
            switch ($Key.Key) {
                ([ConsoleKey]::Backspace) { 
                    if ($cursorPos -gt 0) { 
                        $text = $text.Remove($cursorPos - 1, 1)
                        $cursorPos-- 
                    }
                }
                ([ConsoleKey]::Delete) { 
                    if ($cursorPos -lt $text.Length) { 
                        $text = $text.Remove($cursorPos, 1) 
                    }
                }
                ([ConsoleKey]::LeftArrow) { 
                    if ($cursorPos -gt 0) { $cursorPos-- }
                }
                ([ConsoleKey]::RightArrow) { 
                    if ($cursorPos -lt $text.Length) { $cursorPos++ }
                }
                ([ConsoleKey]::Home) { $cursorPos = 0 }
                ([ConsoleKey]::End) { $cursorPos = $text.Length }
                ([ConsoleKey]::V) {
                    # Handle Ctrl+V (paste)
                    if ($Key.Modifiers -band [ConsoleModifiers]::Control) {
                        try {
                            # Get clipboard text (Windows only)
                            $clipboardText = if (Get-Command Get-Clipboard -ErrorAction SilentlyContinue) {
                                Get-Clipboard -Format Text -ErrorAction SilentlyContinue
                            } else {
                                $null
                            }
                            
                            if ($clipboardText) {
                                # Remove newlines for single-line textbox
                                $clipboardText = $clipboardText -replace '[\r\n]+', ' '
                                
                                # Insert as much as will fit
                                $remainingSpace = $self.MaxLength - $text.Length
                                if ($remainingSpace -gt 0) {
                                    $toInsert = if ($clipboardText.Length -gt $remainingSpace) {
                                        $clipboardText.Substring(0, $remainingSpace)
                                    } else {
                                        $clipboardText
                                    }
                                    
                                    $text = $text.Insert($cursorPos, $toInsert)
                                    $cursorPos += $toInsert.Length
                                }
                            }
                        } catch {
                            # Silently ignore clipboard errors
                        }
                    } else {
                        # Regular 'V' key
                        if (-not [char]::IsControl($Key.KeyChar) -and $text.Length -lt $self.MaxLength) {
                            $text = $text.Insert($cursorPos, $Key.KeyChar)
                            $cursorPos++
                        } else {
                            return $false
                        }
                    }
                }
                default {
                    if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar) -and $text.Length -lt $self.MaxLength) {
                        $text = $text.Insert($cursorPos, $Key.KeyChar)
                        $cursorPos++
                    } else { 
                        return $false 
                    }
                }
            }
            
            if ($text -ne $oldText -or $cursorPos -ne $self.CursorPosition) {
                $self.Text = $text
                $self.CursorPosition = $cursorPos
                
                if ($self.OnChange) { 
                    & $self.OnChange -NewValue $text
                }
                Request-TuiRefresh
            }
            return $true
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

function global:New-TuiCheckBox {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "CheckBox"
        IsFocusable = $true
        
        # Properties (from Props)
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 20
        Height = $Props.Height ?? 1
        Visible = $Props.Visible ?? $true
        Text = $Props.Text ?? "Checkbox"
        Checked = $Props.Checked ?? $false
        Name = $Props.Name
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
        
        # Methods
        Render = {
            param($self)
            if (-not $self.Visible) { return }
            
            $fg = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Primary" }
            $checkbox = if ($self.Checked) { "[X]" } else { "[ ]" }
            Write-BufferString -X $self.X -Y $self.Y -Text "$checkbox $($self.Text)" -ForegroundColor $fg
        }
        
        HandleInput = {
            param($self, $Key)
            if ($Key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                $self.Checked = -not $self.Checked
                
                if ($self.OnChange) { 
                    & $self.OnChange -NewValue $self.Checked 
                }
                Request-TuiRefresh
                return $true
            }
            return $false
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

function global:New-TuiDropdown {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "Dropdown"
        IsFocusable = $true
        
        # Properties (from Props)
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 20
        Height = $Props.Height ?? 3
        Visible = $Props.Visible ?? $true
        Options = $Props.Options ?? @()
        Value = $Props.Value
        Placeholder = $Props.Placeholder ?? "Select..."
        Name = $Props.Name
        
        # Internal State
        IsOpen = $false
        SelectedIndex = 0
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
        
        # Methods
        Render = {
            param($self)
            if (-not $self.Visible) { return }
            
            $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
            Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height 3 -BorderColor $borderColor
            
            $displayText = $self.Placeholder
            if ($self.Value -and $self.Options) {
                $selected = $self.Options | Where-Object { $_.Value -eq $self.Value } | Select-Object -First 1
                if ($selected) { $displayText = $selected.Display }
            }
            
            Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $displayText
            $indicator = if ($self.IsOpen) { "▲" } else { "▼" }
            Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text $indicator
            
            if ($self.IsOpen -and $self.Options.Count -gt 0) {
                $listHeight = [Math]::Min($self.Options.Count + 2, 8)
                Write-BufferBox -X $self.X -Y ($self.Y + 3) -Width $self.Width -Height $listHeight `
                    -BorderColor $borderColor -BackgroundColor (Get-ThemeColor "Background")
                
                $displayCount = [Math]::Min($self.Options.Count, 6)
                for ($i = 0; $i -lt $displayCount; $i++) {
                    $option = $self.Options[$i]
                    $y = $self.Y + 4 + $i
                    $fg = if ($i -eq $self.SelectedIndex) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Primary" }
                    $bg = if ($i -eq $self.SelectedIndex) { Get-ThemeColor "Secondary" } else { Get-ThemeColor "Background" }
                    $text = $option.Display
                    if ($text.Length -gt ($self.Width - 4)) { 
                        $text = $text.Substring(0, $self.Width - 7) + "..." 
                    }
                    Write-BufferString -X ($self.X + 2) -Y $y -Text $text -ForegroundColor $fg -BackgroundColor $bg
                }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            if (-not $self.IsOpen) {
                if ($Key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar, [ConsoleKey]::DownArrow)) {
                    $self.IsOpen = $true
                    Request-TuiRefresh
                    return $true
                }
            } else {
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) { 
                        if ($self.SelectedIndex -gt 0) { 
                            $self.SelectedIndex--
                            Request-TuiRefresh 
                        }
                        return $true 
                    }
                    ([ConsoleKey]::DownArrow) { 
                        if ($self.SelectedIndex -lt ($self.Options.Count - 1)) { 
                            $self.SelectedIndex++
                            Request-TuiRefresh 
                        }
                        return $true 
                    }
                    ([ConsoleKey]::Enter) {
                        if ($self.Options.Count -gt 0) {
                            $selected = $self.Options[$self.SelectedIndex]
                            $self.Value = $selected.Value
                            
                            if ($self.OnChange) { 
                                & $self.OnChange -NewValue $selected.Value 
                            }
                        }
                        $self.IsOpen = $false
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::Escape) { 
                        $self.IsOpen = $false
                        Request-TuiRefresh
                        return $true 
                    }
                }
            }
            return $false
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

function global:New-TuiProgressBar {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "ProgressBar"
        IsFocusable = $false
        
        # Properties (from Props)
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 20
        Height = $Props.Height ?? 1
        Visible = $Props.Visible ?? $true
        Value = $Props.Value ?? 0
        Max = $Props.Max ?? 100
        ShowPercent = $Props.ShowPercent ?? $false
        Name = $Props.Name
        
        # Methods
        Render = {
            param($self)
            if (-not $self.Visible) { return }
            
            $percent = [Math]::Min(100, [Math]::Max(0, ($self.Value / $self.Max) * 100))
            $filled = [Math]::Floor(($self.Width - 2) * ($percent / 100))
            $empty = ($self.Width - 2) - $filled
            
            $bar = "█" * $filled + "░" * $empty
            Write-BufferString -X $self.X -Y $self.Y -Text "[$bar]" -ForegroundColor (Get-ThemeColor "Accent")
            
            if ($self.ShowPercent) {
                $percentText = "$([Math]::Round($percent))%"
                $textX = $self.X + [Math]::Floor(($self.Width - $percentText.Length) / 2)
                Write-BufferString -X $textX -Y $self.Y -Text $percentText -ForegroundColor (Get-ThemeColor "Primary")
            }
        }
        
        HandleInput = {
            param($self, $Key)
            return $false
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

function global:New-TuiTextArea {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "TextArea"
        IsFocusable = $true
        
        # Properties (from Props)
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 40
        Height = $Props.Height ?? 6
        Visible = $Props.Visible ?? $true
        Text = $Props.Text ?? ""
        Placeholder = $Props.Placeholder ?? "Enter text..."
        WrapText = $Props.WrapText ?? $true
        Name = $Props.Name
        
        # Internal State
        Lines = @($Props.Text -split "`n")
        CursorX = 0
        CursorY = 0
        ScrollOffset = 0
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
        
        # Methods
        Render = {
            param($self)
            if (-not $self.Visible) { return }
            
            $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
            Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height -BorderColor $borderColor
            
            $innerWidth = $self.Width - 4
            $innerHeight = $self.Height - 2
            $displayLines = @()
            if ($self.Lines.Count -eq 0) { $self.Lines = @("") }
            
            foreach ($line in $self.Lines) {
                if ($self.WrapText -and $line.Length -gt $innerWidth) {
                    for ($i = 0; $i -lt $line.Length; $i += $innerWidth) {
                        $displayLines += $line.Substring($i, [Math]::Min($innerWidth, $line.Length - $i))
                    }
                } else { 
                    $displayLines += $line 
                }
            }
            
            if ($displayLines.Count -eq 1 -and $displayLines[0] -eq "" -and -not $self.IsFocused) {
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $self.Placeholder
                return
            }
            
            $startLine = $self.ScrollOffset
            $endLine = [Math]::Min($displayLines.Count - 1, $startLine + $innerHeight - 1)
            
            for ($i = $startLine; $i -le $endLine; $i++) {
                $y = $self.Y + 1 + ($i - $startLine)
                $line = $displayLines[$i]
                Write-BufferString -X ($self.X + 2) -Y $y -Text $line
            }
            
            if ($self.IsFocused -and $self.CursorY -ge $startLine -and $self.CursorY -le $endLine) {
                $cursorScreenY = $self.Y + 1 + ($self.CursorY - $startLine)
                $cursorX = [Math]::Min($self.CursorX, $displayLines[$self.CursorY].Length)
                Write-BufferString -X ($self.X + 2 + $cursorX) -Y $cursorScreenY -Text "_" `
                    -BackgroundColor (Get-ThemeColor "Accent")
            }
            
            if ($displayLines.Count -gt $innerHeight) {
                $scrollbarHeight = $innerHeight
                $scrollPosition = [Math]::Floor(($self.ScrollOffset / ($displayLines.Count - $innerHeight)) * ($scrollbarHeight - 1))
                for ($i = 0; $i -lt $scrollbarHeight; $i++) {
                    $char = if ($i -eq $scrollPosition) { "█" } else { "│" }
                    $color = if ($i -eq $scrollPosition) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Subtle" }
                    Write-BufferString -X ($self.X + $self.Width - 2) -Y ($self.Y + 1 + $i) -Text $char -ForegroundColor $color
                }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            $lines = $self.Lines
            $cursorY = $self.CursorY
            $cursorX = $self.CursorX
            $innerHeight = $self.Height - 2
            
            switch ($Key.Key) {
                ([ConsoleKey]::UpArrow) {
                    if ($cursorY -gt 0) {
                        $cursorY--
                        $cursorX = [Math]::Min($cursorX, $lines[$cursorY].Length)
                        if ($cursorY -lt $self.ScrollOffset) { 
                            $self.ScrollOffset = $cursorY 
                        }
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    if ($cursorY -lt $lines.Count - 1) {
                        $cursorY++
                        $cursorX = [Math]::Min($cursorX, $lines[$cursorY].Length)
                        if ($cursorY -ge $self.ScrollOffset + $innerHeight) { 
                            $self.ScrollOffset = $cursorY - $innerHeight + 1 
                        }
                    }
                }
                ([ConsoleKey]::LeftArrow) {
                    if ($cursorX -gt 0) { 
                        $cursorX-- 
                    } elseif ($cursorY -gt 0) { 
                        $cursorY--
                        $cursorX = $lines[$cursorY].Length 
                    }
                }
                ([ConsoleKey]::RightArrow) {
                    if ($cursorX -lt $lines[$cursorY].Length) { 
                        $cursorX++ 
                    } elseif ($cursorY -lt $lines.Count - 1) { 
                        $cursorY++
                        $cursorX = 0 
                    }
                }
                ([ConsoleKey]::Home) { $cursorX = 0 }
                ([ConsoleKey]::End) { $cursorX = $lines[$cursorY].Length }
                ([ConsoleKey]::Enter) {
                    $currentLine = $lines[$cursorY]
                    $beforeCursor = $currentLine.Substring(0, $cursorX)
                    $afterCursor = $currentLine.Substring($cursorX)
                    $lines[$cursorY] = $beforeCursor
                    $lines = @($lines[0..$cursorY]) + @($afterCursor) + @($lines[($cursorY + 1)..($lines.Count - 1)])
                    $cursorY++
                    $cursorX = 0
                    if ($cursorY -ge $self.ScrollOffset + $innerHeight) { 
                        $self.ScrollOffset = $cursorY - $innerHeight + 1 
                    }
                }
                ([ConsoleKey]::Backspace) {
                    if ($cursorX -gt 0) { 
                        $lines[$cursorY] = $lines[$cursorY].Remove($cursorX - 1, 1)
                        $cursorX-- 
                    } elseif ($cursorY -gt 0) {
                        $prevLineLength = $lines[$cursorY - 1].Length
                        $lines[$cursorY - 1] += $lines[$cursorY]
                        $newLines = @()
                        for ($i = 0; $i -lt $lines.Count; $i++) { 
                            if ($i -ne $cursorY) { $newLines += $lines[$i] } 
                        }
                        $lines = $newLines
                        $cursorY--
                        $cursorX = $prevLineLength
                    }
                }
                ([ConsoleKey]::Delete) {
                    if ($cursorX -lt $lines[$cursorY].Length) { 
                        $lines[$cursorY] = $lines[$cursorY].Remove($cursorX, 1) 
                    } elseif ($cursorY -lt $lines.Count - 1) {
                        $lines[$cursorY] += $lines[$cursorY + 1]
                        $newLines = @()
                        for ($i = 0; $i -lt $lines.Count; $i++) { 
                            if ($i -ne ($cursorY + 1)) { $newLines += $lines[$i] } 
                        }
                        $lines = $newLines
                    }
                }
                ([ConsoleKey]::V) {
                    # Handle Ctrl+V (paste)
                    if ($Key.Modifiers -band [ConsoleModifiers]::Control) {
                        try {
                            # Get clipboard text (Windows only)
                            $clipboardText = if (Get-Command Get-Clipboard -ErrorAction SilentlyContinue) {
                                Get-Clipboard -Format Text -ErrorAction SilentlyContinue
                            } else {
                                $null
                            }
                            
                            if ($clipboardText) {
                                # Split clipboard text into lines
                                $clipboardLines = $clipboardText -split '[\r\n]+'
                                
                                if ($clipboardLines.Count -eq 1) {
                                    # Single line paste - insert at cursor
                                    $lines[$cursorY] = $lines[$cursorY].Insert($cursorX, $clipboardLines[0])
                                    $cursorX += $clipboardLines[0].Length
                                } else {
                                    # Multi-line paste
                                    $currentLine = $lines[$cursorY]
                                    $beforeCursor = $currentLine.Substring(0, $cursorX)
                                    $afterCursor = $currentLine.Substring($cursorX)
                                    
                                    # First line
                                    $lines[$cursorY] = $beforeCursor + $clipboardLines[0]
                                    
                                    # Insert middle lines
                                    $insertLines = @()
                                    for ($i = 1; $i -lt $clipboardLines.Count - 1; $i++) {
                                        $insertLines += $clipboardLines[$i]
                                    }
                                    
                                    # Last line
                                    $lastLine = $clipboardLines[-1] + $afterCursor
                                    $insertLines += $lastLine
                                    
                                    # Insert all new lines
                                    $newLines = @()
                                    for ($i = 0; $i -le $cursorY; $i++) {
                                        $newLines += $lines[$i]
                                    }
                                    $newLines += $insertLines
                                    for ($i = $cursorY + 1; $i -lt $lines.Count; $i++) {
                                        $newLines += $lines[$i]
                                    }
                                    
                                    $lines = $newLines
                                    $cursorY += $clipboardLines.Count - 1
                                    $cursorX = $clipboardLines[-1].Length
                                }
                                
                                # Adjust scroll if needed
                                $innerHeight = $self.Height - 2
                                if ($cursorY -ge $self.ScrollOffset + $innerHeight) { 
                                    $self.ScrollOffset = $cursorY - $innerHeight + 1 
                                }
                            }
                        } catch {
                            # Silently ignore clipboard errors
                        }
                    } else {
                        # Regular 'V' key
                        if (-not [char]::IsControl($Key.KeyChar)) {
                            $lines[$cursorY] = $lines[$cursorY].Insert($cursorX, $Key.KeyChar)
                            $cursorX++
                        } else {
                            return $false
                        }
                    }
                }
                default {
                    if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar)) {
                        $lines[$cursorY] = $lines[$cursorY].Insert($cursorX, $Key.KeyChar)
                        $cursorX++
                    } else { 
                        return $false 
                    }
                }
            }
            
            $self.Lines = $lines
            $self.CursorX = $cursorX
            $self.CursorY = $cursorY
            $self.Text = $lines -join "`n"
            
            if ($self.OnChange) { 
                & $self.OnChange -NewValue $self.Text 
            }
            Request-TuiRefresh
            return $true
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

#endregion

#region DateTime Components

function global:New-TuiDatePicker {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "DatePicker"
        IsFocusable = $true
        
        # Properties (from Props)
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 20
        Height = $Props.Height ?? 3
        Visible = $Props.Visible ?? $true
        Value = $Props.Value ?? (Get-Date)
        Format = $Props.Format ?? "yyyy-MM-dd"
        Name = $Props.Name
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
        
        # Methods
        Render = {
            param($self)
            if (-not $self.Visible) { return }
            
            $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
            Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height 3 -BorderColor $borderColor
            $dateStr = $self.Value.ToString($self.Format)
            
            # Truncate date string if too long
            $maxLength = $self.Width - 6
            if ($dateStr.Length -gt $maxLength) {
                $dateStr = $dateStr.Substring(0, $maxLength)
            }
            
            Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $dateStr
            if ($self.IsFocused -and $self.Width -ge 6) { 
                Write-BufferString -X ($self.X + $self.Width - 4) -Y ($self.Y + 1) -Text "📅" -ForegroundColor $borderColor 
            }
        }
        
        HandleInput = {
            param($self, $Key)
            $date = $self.Value
            $handled = $true
            
            switch ($Key.Key) {
                ([ConsoleKey]::UpArrow)   { $date = $date.AddDays(1) }
                ([ConsoleKey]::DownArrow) { $date = $date.AddDays(-1) }
                ([ConsoleKey]::PageUp)    { $date = $date.AddMonths(1) }
                ([ConsoleKey]::PageDown)  { $date = $date.AddMonths(-1) }
                ([ConsoleKey]::Home)      { $date = Get-Date }
                ([ConsoleKey]::T) { 
                    if ($Key.Modifiers -band [ConsoleModifiers]::Control) { 
                        $date = Get-Date 
                    } else { 
                        $handled = $false 
                    } 
                }
                default { $handled = $false }
            }
            
            if ($handled) {
                $self.Value = $date
                if ($self.OnChange) { 
                    & $self.OnChange -NewValue $date 
                }
                Request-TuiRefresh
            }
            return $handled
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

function global:New-TuiTimePicker {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "TimePicker"
        IsFocusable = $true
        
        # Properties (from Props)
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 15
        Height = $Props.Height ?? 3
        Visible = $Props.Visible ?? $true
        Hour = $Props.Hour ?? 0
        Minute = $Props.Minute ?? 0
        Format24H = $Props.Format24H ?? $true
        Name = $Props.Name
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
        
        # Methods
        Render = {
            param($self)
            if (-not $self.Visible) { return }
            
            $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
            Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height 3 -BorderColor $borderColor
            
            if ($self.Format24H) { 
                $timeStr = "{0:D2}:{1:D2}" -f $self.Hour, $self.Minute 
            } else {
                $displayHour = if ($self.Hour -eq 0) { 12 } elseif ($self.Hour -gt 12) { $self.Hour - 12 } else { $self.Hour }
                $ampm = if ($self.Hour -lt 12) { "AM" } else { "PM" }
                $timeStr = "{0:D2}:{1:D2} {2}" -f $displayHour, $self.Minute, $ampm
            }
            
            # Truncate time string if too long
            $maxLength = $self.Width - 6
            if ($timeStr.Length -gt $maxLength) {
                $timeStr = $timeStr.Substring(0, $maxLength)
            }
            
            Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $timeStr
            if ($self.IsFocused -and $self.Width -ge 6) { 
                Write-BufferString -X ($self.X + $self.Width - 4) -Y ($self.Y + 1) -Text "⏰" -ForegroundColor $borderColor 
            }
        }
        
        HandleInput = {
            param($self, $Key)
            $handled = $true
            $hour = $self.Hour
            $minute = $self.Minute
            
            switch ($Key.Key) {
                ([ConsoleKey]::UpArrow) { 
                    $minute = ($minute + 15) % 60
                    if ($minute -eq 0) { $hour = ($hour + 1) % 24 } 
                }
                ([ConsoleKey]::DownArrow) { 
                    $minute = ($minute - 15 + 60) % 60
                    if ($minute -eq 45) { $hour = ($hour - 1 + 24) % 24 } 
                }
                ([ConsoleKey]::LeftArrow)  { $hour = ($hour - 1 + 24) % 24 }
                ([ConsoleKey]::RightArrow) { $hour = ($hour + 1) % 24 }
                default { $handled = $false }
            }
            
            if ($handled) {
                $self.Hour = $hour
                $self.Minute = $minute
                
                if ($self.OnChange) { 
                    & $self.OnChange -NewHour $hour -NewMinute $minute 
                }
                Request-TuiRefresh
            }
            return $handled
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

#endregion

#region Data Display Components

function global:New-TuiTable {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "Table"
        IsFocusable = $true
        
        # Properties (from Props)
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 60
        Height = $Props.Height ?? 15
        Visible = $Props.Visible ?? $true
        Columns = $Props.Columns ?? @()
        Rows = $Props.Rows ?? @()
        Name = $Props.Name
        
        # Internal State
        SelectedRow = 0
        ScrollOffset = 0
        SortColumn = $null
        SortAscending = $true
        
        # Event Handlers (from Props)
        OnRowSelect = $Props.OnRowSelect
        
        # Methods
        Render = {
            param($self)
            if (-not $self.Visible -or $self.Columns.Count -eq 0) { return }
            
            $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
            Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height -BorderColor $borderColor
            
            $totalWidth = $self.Width - 4
            $colWidth = [Math]::Floor($totalWidth / $self.Columns.Count)
            $headerY = $self.Y + 1
            $currentX = $self.X + 2
            
            # Draw headers
            foreach ($col in $self.Columns) {
                $header = $col.Header
                if ($col.Name -eq $self.SortColumn) { 
                    $arrow = if ($self.SortAscending) { "▲" } else { "▼" }
                    $header = "$header $arrow" 
                }
                if ($header.Length -gt $colWidth - 1) { 
                    $header = $header.Substring(0, $colWidth - 4) + "..." 
                }
                Write-BufferString -X $currentX -Y $headerY -Text $header -ForegroundColor (Get-ThemeColor "Header")
                $currentX += $colWidth
            }
            
            # Header separator
            Write-BufferString -X ($self.X + 1) -Y ($headerY + 1) -Text ("─" * ($self.Width - 2)) -ForegroundColor $borderColor
            
            # Draw rows
            $visibleRows = $self.Height - 5
            $startIdx = $self.ScrollOffset
            $endIdx = [Math]::Min($self.Rows.Count - 1, $startIdx + $visibleRows - 1)
            
            for ($i = $startIdx; $i -le $endIdx; $i++) {
                $row = $self.Rows[$i]
                $rowY = ($headerY + 2) + ($i - $startIdx)
                $currentX = $self.X + 2
                $isSelected = ($i -eq $self.SelectedRow -and $self.IsFocused)
                $bgColor = if ($isSelected) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Background" }
                $fgColor = if ($isSelected) { Get-ThemeColor "Background" } else { Get-ThemeColor "Primary" }
                
                if ($isSelected) { 
                    Write-BufferString -X ($self.X + 1) -Y $rowY -Text (" " * ($self.Width - 2)) -BackgroundColor $bgColor 
                }
                
                foreach ($col in $self.Columns) {
                    $value = $row.($col.Name)
                    if ($null -eq $value) { $value = "" }
                    $text = $value.ToString()
                    if ($text.Length -gt $colWidth - 1) { 
                        $text = $text.Substring(0, $colWidth - 4) + "..." 
                    }
                    Write-BufferString -X $currentX -Y $rowY -Text $text -ForegroundColor $fgColor -BackgroundColor $bgColor
                    $currentX += $colWidth
                }
            }
            
            # Scrollbar
            if ($self.Rows.Count -gt $visibleRows) {
                $scrollbarHeight = $visibleRows
                $scrollPosition = [Math]::Floor(($self.ScrollOffset / ($self.Rows.Count - $visibleRows)) * ($scrollbarHeight - 1))
                for ($i = 0; $i -lt $scrollbarHeight; $i++) {
                    $char = if ($i -eq $scrollPosition) { "█" } else { "│" }
                    $color = if ($i -eq $scrollPosition) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Subtle" }
                    Write-BufferString -X ($self.X + $self.Width - 2) -Y ($headerY + 2 + $i) -Text $char -ForegroundColor $color
                }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            if ($self.Rows.Count -eq 0) { return $false }
            
            $visibleRows = $self.Height - 5
            $handled = $true
            
            switch ($Key.Key) {
                ([ConsoleKey]::UpArrow) { 
                    if ($self.SelectedRow -gt 0) { 
                        $self.SelectedRow--
                        if ($self.SelectedRow -lt $self.ScrollOffset) { 
                            $self.ScrollOffset = $self.SelectedRow 
                        }
                        Request-TuiRefresh 
                    } 
                }
                ([ConsoleKey]::DownArrow) { 
                    if ($self.SelectedRow -lt $self.Rows.Count - 1) { 
                        $self.SelectedRow++
                        if ($self.SelectedRow -ge $self.ScrollOffset + $visibleRows) { 
                            $self.ScrollOffset = $self.SelectedRow - $visibleRows + 1 
                        }
                        Request-TuiRefresh 
                    } 
                }
                ([ConsoleKey]::PageUp) { 
                    $self.SelectedRow = [Math]::Max(0, $self.SelectedRow - $visibleRows)
                    $self.ScrollOffset = [Math]::Max(0, $self.ScrollOffset - $visibleRows)
                    Request-TuiRefresh 
                }
                ([ConsoleKey]::PageDown) { 
                    $self.SelectedRow = [Math]::Min($self.Rows.Count - 1, $self.SelectedRow + $visibleRows)
                    $maxScroll = [Math]::Max(0, $self.Rows.Count - $visibleRows)
                    $self.ScrollOffset = [Math]::Min($maxScroll, $self.ScrollOffset + $visibleRows)
                    Request-TuiRefresh 
                }
                ([ConsoleKey]::Home) { 
                    $self.SelectedRow = 0
                    $self.ScrollOffset = 0
                    Request-TuiRefresh 
                }
                ([ConsoleKey]::End) { 
                    $self.SelectedRow = $self.Rows.Count - 1
                    $self.ScrollOffset = [Math]::Max(0, $self.Rows.Count - $visibleRows)
                    Request-TuiRefresh 
                }
                ([ConsoleKey]::Enter) { 
                    if ($self.OnRowSelect) { 
                        & $self.OnRowSelect -Row $self.Rows[$self.SelectedRow] -Index $self.SelectedRow 
                    } 
                }
                default {
                    if ($Key.KeyChar -match '\d') {
                        $colIndex = [int]$Key.KeyChar.ToString() - 1
                        if ($colIndex -ge 0 -and $colIndex -lt $self.Columns.Count) {
                            $colName = $self.Columns[$colIndex].Name
                            if ($self.SortColumn -eq $colName) { 
                                $self.SortAscending = -not $self.SortAscending 
                            } else { 
                                $self.SortColumn = $colName
                                $self.SortAscending = $true 
                            }
                            $self.Rows = $self.Rows | Sort-Object -Property $colName -Descending:(-not $self.SortAscending)
                            Request-TuiRefresh
                        }
                    } else { 
                        $handled = $false 
                    }
                }
            }
            return $handled
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

function global:New-TuiChart {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "Chart"
        IsFocusable = $false
        
        # Properties (from Props)
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 40
        Height = $Props.Height ?? 10
        Visible = $Props.Visible ?? $true
        ChartType = $Props.ChartType ?? "Bar"
        Data = $Props.Data ?? @()
        ShowValues = $Props.ShowValues ?? $true
        Name = $Props.Name
        
        # Methods
        Render = {
            param($self)
            if (-not $self.Visible -or $self.Data.Count -eq 0) { return }
            
            switch ($self.ChartType) {
                "Bar" {
                    $maxValue = ($self.Data | Measure-Object -Property Value -Maximum).Maximum
                    if ($maxValue -eq 0) { $maxValue = 1 }
                    $chartHeight = $self.Height - 2
                    $barWidth = [Math]::Floor(($self.Width - 4) / $self.Data.Count)
                    
                    for ($i = 0; $i -lt $self.Data.Count; $i++) {
                        $item = $self.Data[$i]
                        $barHeight = [Math]::Floor(($item.Value / $maxValue) * $chartHeight)
                        $barX = $self.X + 2 + ($i * $barWidth)
                        
                        for ($y = 0; $y -lt $barHeight; $y++) { 
                            $barY = $self.Y + $self.Height - 2 - $y
                            Write-BufferString -X $barX -Y $barY -Text ("█" * ($barWidth - 1)) -ForegroundColor (Get-ThemeColor "Accent") 
                        }
                        
                        if ($item.Label -and $barWidth -gt 3) { 
                            $label = $item.Label
                            if ($label.Length -gt $barWidth - 1) { 
                                $label = $label.Substring(0, $barWidth - 2) 
                            }
                            Write-BufferString -X $barX -Y ($self.Y + $self.Height - 1) -Text $label -ForegroundColor (Get-ThemeColor "Subtle") 
                        }
                        
                        if ($self.ShowValues -and $barHeight -gt 0) { 
                            $valueText = $item.Value.ToString()
                            Write-BufferString -X $barX -Y ($self.Y + $self.Height - 3 - $barHeight) -Text $valueText -ForegroundColor (Get-ThemeColor "Primary") 
                        }
                    }
                }
                "Sparkline" {
                    $width = $self.Width - 2
                    $height = $self.Height - 1
                    $maxValue = ($self.Data | Measure-Object -Maximum).Maximum
                    if ($maxValue -eq 0) { $maxValue = 1 }
                    
                    $sparkChars = @(" ", " ", "▂", "▃", "▄", "▅", "▆", "▇", "█")
                    $sparkline = ""
                    
                    foreach ($value in $self.Data) { 
                        $normalized = ($value / $maxValue)
                        $charIndex = [Math]::Floor($normalized * ($sparkChars.Count - 1))
                        $sparkline += $sparkChars[$charIndex] 
                    }
                    
                    if ($sparkline.Length -gt $width) { 
                        $sparkline = $sparkline.Substring($sparkline.Length - $width) 
                    } else { 
                        $sparkline = $sparkline.PadLeft($width) 
                    }
                    
                    Write-BufferString -X ($self.X + 1) -Y ($self.Y + [Math]::Floor($height / 2)) -Text $sparkline -ForegroundColor (Get-ThemeColor "Accent")
                }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            return $false
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

#endregion

#region Container Components

function global:New-TuiPanel {
    param([hashtable]$Props = @{})
    
    $component = @{
        # --- Standard Component Metadata ---
        Type = "Panel"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 40
        Height = $Props.Height ?? 20
        Visible = $Props.Visible ?? $true
        IsFocusable = $Props.IsFocusable ?? $false
        
        # --- Child and Layout Management ---
        Children = @()
        Layout = $Props.Layout ?? 'Stack'
        Orientation = $Props.Orientation ?? 'Vertical'
        Spacing = $Props.Spacing ?? 1
        Padding = $Props.Padding ?? 1
        
        # --- Visual Properties ---
        ShowBorder = $Props.ShowBorder ?? $false
        Title = $Props.Title
        Name = $Props.Name

        # =================================================================
        # METHODS
        # =================================================================

        # --- Public Method: AddChild ---
        AddChild = {
            param($self, $Child)
            $self.Children += $Child
            $Child.Parent = $self
            # We don't need to recalculate here; the Render loop will handle it,
            # which is more efficient if multiple children are added in one frame.
        }
        
        # --- Internal Method: _RecalculateLayout ---
        _RecalculateLayout = {
            param($self)
            $contentX = $self.X + $self.Padding
            $contentY = $self.Y + $self.Padding
            $contentWidth = $self.Width - ($self.Padding * 2)
            $contentHeight = $self.Height - ($self.Padding * 2)
            
            if ($self.ShowBorder) {
                $contentX++
                $contentY++
                $contentWidth -= 2
                $contentHeight -= 2
            }
            
            # Debug logging
            if ((Get-Command Write-Log -ErrorAction SilentlyContinue) -and $self.Title) {
                Write-Log -Level Debug -Message "Panel '$($self.Title)' layout: Panel at ($($self.X),$($self.Y)), Content area at ($contentX,$contentY) size ${contentWidth}x${contentHeight}"
            }
            
            # Apply the chosen layout algorithm
            switch ($self.Layout) {
                'Stack' {
                    $currentX = $contentX
                    $currentY = $contentY
                    
                    foreach ($child in $self.Children) {
                        # A child that is not visible does not occupy space in the layout.
                        # This allows components to be "in" the panel but hidden without breaking layout.
                        if ($child.Visible -ne $true) { continue }
                        
                        $child.X = $currentX
                        $child.Y = $currentY
                        
                        # Debug child positioning
                        if ((Get-Command Write-Log -ErrorAction SilentlyContinue) -and $child.Name) {
                            Write-Log -Level Debug -Message "  Positioned child '$($child.Name)' at ($($child.X),$($child.Y))"
                        }
                        
                        if ($self.Orientation -eq 'Vertical') {
                            $child.Width = [Math]::Min($child.Width, $contentWidth)
                            $currentY += $child.Height + $self.Spacing
                        } else { # Horizontal
                            $child.Height = [Math]::Min($child.Height, $contentHeight)
                            $currentX += $child.Width + $self.Spacing
                        }
                    }
                }
                # Other layouts like 'Grid' would be implemented here.
            }
        }
        
        # --- THE NEW, CORRECTED RENDER METHOD ---
        Render = {
            param($self)
            
            # 1. THE GOLDEN RULE: If the panel is not visible, it does NOTHING.
            # It does not render its border. It does not render its children.
            # This single check solves the entire category of visibility bugs.
            if ($self.Visible -ne $true) {
                return
            }
            
            # 2. Recalculate layout on every render frame. This is the key to making
            # the panel self-sufficient and responsive to changes in its own state.
            & $self._RecalculateLayout -self $self

            # 3. Draw the panel's own UI (its border and title).
            if ($self.ShowBorder) {
                $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Border" }
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor -Title $self.Title
            }
            
            # 4. Delegate rendering to children.
            # The panel is now the orchestrator.
            foreach ($child in $self.Children) {
                # The panel respects the child's own Visible property. This allows for
                # hiding a single field within an otherwise visible form.
                # Since we already checked if the panel itself is visible, we are guaranteed
                # that children of a hidden panel will never be rendered.
                if ($child.Visible -eq $true -and $child.Render) {
                    & $child.Render -self $child
                }
            }
        }
        
        # --- Public Method: Show ---
        # Recursively makes the panel and all its children visible.
        Show = {
            param($self)
            $self.Visible = $true
            foreach ($child in $self.Children) {
                # Check if the child is a Panel itself and call its Show method,
                # otherwise just set its Visible property.
                if ($child.Show) {
                    & $child.Show -self $child
                } else {
                    $child.Visible = $true
                }
            }
        }
        
        # --- Public Method: Hide ---
        # Recursively makes the panel and all its children invisible.
        Hide = {
            param($self)
            $self.Visible = $false
            foreach ($child in $self.Children) {
                if ($child.Hide) {
                    & $child.Hide -self $child
                } else {
                    $child.Visible = $false
                }
            }
        }
        
        # --- Input Handling ---
        HandleInput = {
            param($self, $Key)
            return $false # Panels delegate focus, they don't handle input.
        }
    }
    
    return $component
}

#endregion

Export-ModuleMember -Function @(
    # Basic Components
    'New-TuiLabel',
    'New-TuiButton',
    'New-TuiTextBox',
    'New-TuiCheckBox',
    'New-TuiDropdown',
    'New-TuiProgressBar',
    'New-TuiTextArea',
    # DateTime Components
    'New-TuiDatePicker',
    'New-TuiTimePicker',
    # Data Display Components
    'New-TuiTable',
    'New-TuiChart',
    # Container Components
    'New-TuiPanel'
)
# FILE: layout/panels.psm1
# PURPOSE: Provides a suite of specialized layout panels for declarative UI construction.

function New-BasePanel {
    param([hashtable]$Props)
    
    $panel = @{
        Type = "Panel"
        Name = $Props.Name ?? "Panel_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 40
        Height = $Props.Height ?? 20
        Visible = $Props.Visible ?? $true
        IsFocusable = $Props.IsFocusable ?? $false
        Children = @()
        Parent = $null
        LayoutProps = $Props.LayoutProps ?? @{}
        ShowBorder = $Props.ShowBorder ?? $false
        BorderStyle = $Props.BorderStyle ?? "Single"  # Single, Double, Rounded
        Title = $Props.Title
        Padding = $Props.Padding ?? 0
        Margin = $Props.Margin ?? 0
        BackgroundColor = $Props.BackgroundColor
        ForegroundColor = $Props.ForegroundColor
        _isDirty = $true
        _cachedLayout = $null
        
        AddChild = { 
            param($self, $Child, [hashtable]$LayoutProps = @{})
            
            if (-not $Child) {
                throw "Cannot add null child to panel"
            }
            
            $Child.Parent = $self
            $Child.LayoutProps = $LayoutProps
            $self.Children += $Child
            $self._isDirty = $true
            
            # Propagate visibility
            if (-not $self.Visible) {
                $Child.Visible = $false
            }
        }
        
        RemoveChild = {
            param($self, $Child)
            
            $self.Children = $self.Children | Where-Object { $_ -ne $Child }
            if ($Child.Parent -eq $self) {
                $Child.Parent = $null
            }
            $self._isDirty = $true
        }
        
        ClearChildren = {
            param($self)
            
            foreach ($child in $self.Children) {
                $child.Parent = $null
            }
            $self.Children = @()
            $self._isDirty = $true
        }
        
        Show = { 
            param($self)
            
            $self.Visible = $true
            foreach ($child in $self.Children) { 
                if ($child.Show) { 
                    & $child.Show -self $child
                } else { 
                    $child.Visible = $true
                }
            }
            
            # Request refresh if we have access to the function
            if (Get-Command -Name "Request-TuiRefresh" -ErrorAction SilentlyContinue) {
                Request-TuiRefresh
            }
        }
        
        Hide = { 
            param($self)
            
            $self.Visible = $false
            foreach ($child in $self.Children) { 
                if ($child.Hide) { 
                    & $child.Hide -self $child
                } else { 
                    $child.Visible = $false
                }
            }
            
            # Request refresh if we have access to the function
            if (Get-Command -Name "Request-TuiRefresh" -ErrorAction SilentlyContinue) {
                Request-TuiRefresh
            }
        }
        
        HandleInput = { 
            param($self, $Key)
            
            # Panels typically don't handle input directly
            # but can be overridden for special behavior
            return $false
        }
        
        GetContentBounds = {
            param($self)
            
            $borderOffset = if ($self.ShowBorder) { 1 } else { 0 }
            
            return @{
                X = $self.X + $self.Padding + $borderOffset + $self.Margin
                Y = $self.Y + $self.Padding + $borderOffset + $self.Margin
                Width = $self.Width - (2 * ($self.Padding + $borderOffset + $self.Margin))
                Height = $self.Height - (2 * ($self.Padding + $borderOffset + $self.Margin))
            }
        }
        
        InvalidateLayout = {
            param($self)
            
            $self._isDirty = $true
            
            # Propagate to parent
            if ($self.Parent -and $self.Parent.InvalidateLayout) {
                & $self.Parent.InvalidateLayout -self $self.Parent
            }
        }
    }
    
    return $panel
}

function global:New-TuiStackPanel {
    param([hashtable]$Props = @{})
    
    $panel = New-BasePanel -Props $Props
    $panel.Type = "StackPanel"
    $panel.Layout = 'Stack'
    $panel.Orientation = $Props.Orientation ?? 'Vertical'
    $panel.Spacing = $Props.Spacing ?? 1
    $panel.HorizontalAlignment = $Props.HorizontalAlignment ?? 'Stretch'  # Left, Center, Right, Stretch
    $panel.VerticalAlignment = $Props.VerticalAlignment ?? 'Stretch'      # Top, Middle, Bottom, Stretch
    
    $panel.CalculateLayout = {
        param($self)
        
        if (-not $self._isDirty) {
            return $self._cachedLayout
        }
        
        $bounds = & $self.GetContentBounds -self $self
        $layout = @{
            Children = @()
        }
        
        $currentX = $bounds.X
        $currentY = $bounds.Y
        $totalChildWidth = 0
        $totalChildHeight = 0
        $visibleChildren = $self.Children | Where-Object { $_.Visible }
        
        # Calculate total size needed
        foreach ($child in $visibleChildren) {
            if ($self.Orientation -eq 'Vertical') {
                $totalChildHeight += $child.Height
                $totalChildWidth = [Math]::Max($totalChildWidth, $child.Width)
            } else {
                $totalChildWidth += $child.Width
                $totalChildHeight = [Math]::Max($totalChildHeight, $child.Height)
            }
        }
        
        # Add spacing
        if ($visibleChildren.Count -gt 1) {
            if ($self.Orientation -eq 'Vertical') {
                $totalChildHeight += ($visibleChildren.Count - 1) * $self.Spacing
            } else {
                $totalChildWidth += ($visibleChildren.Count - 1) * $self.Spacing
            }
        }
        
        # Calculate starting position based on alignment
        if ($self.Orientation -eq 'Vertical') {
            switch ($self.VerticalAlignment) {
                'Top' { $currentY = $bounds.Y }
                'Middle' { $currentY = $bounds.Y + [Math]::Floor(($bounds.Height - $totalChildHeight) / 2) }
                'Bottom' { $currentY = $bounds.Y + $bounds.Height - $totalChildHeight }
                'Stretch' { $currentY = $bounds.Y }
            }
        } else {
            switch ($self.HorizontalAlignment) {
                'Left' { $currentX = $bounds.X }
                'Center' { $currentX = $bounds.X + [Math]::Floor(($bounds.Width - $totalChildWidth) / 2) }
                'Right' { $currentX = $bounds.X + $bounds.Width - $totalChildWidth }
                'Stretch' { $currentX = $bounds.X }
            }
        }
        
        # Layout children
        foreach ($child in $visibleChildren) {
            $childLayout = @{
                Component = $child
                X = $currentX
                Y = $currentY
                Width = $child.Width
                Height = $child.Height
            }
            
            # Apply stretch behavior
            if ($self.Orientation -eq 'Vertical' -and $self.HorizontalAlignment -eq 'Stretch') {
                $childLayout.Width = $bounds.Width
            }
            elseif ($self.Orientation -eq 'Horizontal' -and $self.VerticalAlignment -eq 'Stretch') {
                $childLayout.Height = $bounds.Height
            }
            
            # Handle horizontal alignment for vertical stacks
            if ($self.Orientation -eq 'Vertical' -and $self.HorizontalAlignment -ne 'Stretch') {
                switch ($self.HorizontalAlignment) {
                    'Center' { $childLayout.X = $bounds.X + [Math]::Floor(($bounds.Width - $child.Width) / 2) }
                    'Right' { $childLayout.X = $bounds.X + $bounds.Width - $child.Width }
                }
            }
            
            # Handle vertical alignment for horizontal stacks
            if ($self.Orientation -eq 'Horizontal' -and $self.VerticalAlignment -ne 'Stretch') {
                switch ($self.VerticalAlignment) {
                    'Middle' { $childLayout.Y = $bounds.Y + [Math]::Floor(($bounds.Height - $child.Height) / 2) }
                    'Bottom' { $childLayout.Y = $bounds.Y + $bounds.Height - $child.Height }
                }
            }
            
            $layout.Children += $childLayout
            
            # Move to next position
            if ($self.Orientation -eq 'Vertical') {
                $currentY += $childLayout.Height + $self.Spacing
            } else {
                $currentX += $childLayout.Width + $self.Spacing
            }
        }
        
        $self._cachedLayout = $layout
        $self._isDirty = $false
        return $layout
    }
    
    $panel.Render = {
        param($self)
        
        # Debug: Log panel state for debugging
        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            Write-Log -Level Debug -Message "StackPanel Render called: Title='$($self.Title)', Visible=$($self.Visible), Position=($($self.X),$($self.Y)), Size=$($self.Width)x$($self.Height), Children=$($self.Children.Count)"
        }
        
        if (-not $self.Visible) {
            if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
                Write-Log -Level Debug -Message "StackPanel '$($self.Title)' not visible, skipping render"
            }
            return
        }
        
        # Clear background if color specified
        if ($self.BackgroundColor) {
            for ($y = $self.Y; $y -lt ($self.Y + $self.Height); $y++) {
                Write-BufferString -X $self.X -Y $y -Text (' ' * $self.Width) -BackgroundColor $self.BackgroundColor
            }
        }
        
        # Draw border if requested
        if ($self.ShowBorder) {
            $borderColor = if ($self.ForegroundColor) { $self.ForegroundColor } else { Get-ThemeColor "Border" -Default Gray }
            Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height -BorderColor $borderColor -Title $self.Title
        }
        
        # Calculate and apply layout
        $layout = & $self.CalculateLayout -self $self
        
        foreach ($childLayout in $layout.Children) {
            $child = $childLayout.Component
            
            # Apply calculated position
            $child.X = $childLayout.X
            $child.Y = $childLayout.Y
            
            # Apply calculated size if child supports it
            if ($childLayout.Width -ne $child.Width -and $child.PSObject.Properties['Width'].IsSettable) {
                $child.Width = $childLayout.Width
            }
            if ($childLayout.Height -ne $child.Height -and $child.PSObject.Properties['Height'].IsSettable) {
                $child.Height = $childLayout.Height
            }
            
            # Render child
            if ($child.Render) {
                & $child.Render -self $child
            }
        }
    }
    
    return $panel
}

function global:New-TuiGridPanel {
    param([hashtable]$Props = @{})
    
    $panel = New-BasePanel -Props $Props
    $panel.Type = "GridPanel"
    $panel.Layout = 'Grid'
    $panel.RowDefinitions = $Props.RowDefinitions ?? @("1*")
    $panel.ColumnDefinitions = $Props.ColumnDefinitions ?? @("1*")
    $panel.ShowGridLines = $Props.ShowGridLines ?? $false
    $panel.GridLineColor = $Props.GridLineColor ?? (Get-ThemeColor "BorderDim" -Default DarkGray)
    
    $panel._CalculateGridSizes = {
        param($self, $definitions, $totalSize)
        
        # Parse definitions and calculate sizes
        $parsedDefs = @()
        $totalFixed = 0
        $totalStars = 0
        
        foreach ($def in $definitions) {
            if ($def -match '^(\d+)$') {
                # Fixed size
                $size = [int]$Matches[1]
                $parsedDefs += @{ Type = 'Fixed'; Value = $size }
                $totalFixed += $size
            }
            elseif ($def -match '^(\d*\.?\d*)\*$') {
                # Star size
                $stars = if ($Matches[1]) { [double]$Matches[1] } else { 1.0 }
                $parsedDefs += @{ Type = 'Star'; Value = $stars }
                $totalStars += $stars
            }
            elseif ($def -eq 'Auto') {
                # Auto size (not implemented yet, treat as 1*)
                $parsedDefs += @{ Type = 'Star'; Value = 1.0 }
                $totalStars += 1.0
            }
            else {
                throw "Invalid grid definition: $def"
            }
        }
        
        # Calculate actual sizes
        $remainingSize = [Math]::Max(0, $totalSize - $totalFixed)
        $sizes = @()
        
        foreach ($def in $parsedDefs) {
            if ($def.Type -eq 'Fixed') {
                $sizes += $def.Value
            }
            else {
                # Star sizing
                if ($totalStars -gt 0) {
                    $size = [Math]::Floor($remainingSize * ($def.Value / $totalStars))
                    $sizes += $size
                } else {
                    $sizes += 0
                }
            }
        }
        
        # Adjust last cell to account for rounding
        if ($sizes.Count -gt 0) {
            $totalAllocated = ($sizes | Measure-Object -Sum).Sum
            $difference = $totalSize - $totalAllocated
            if ($difference -gt 0 -and $sizes[-1] -gt 0) {
                $sizes[-1] += $difference
            }
        }
        
        return $sizes
    }
    
    $panel.CalculateLayout = {
        param($self)
        
        if (-not $self._isDirty) {
            return $self._cachedLayout
        }
        
        $bounds = & $self.GetContentBounds -self $self
        
        # Calculate row and column sizes
        $rowHeights = & $self._CalculateGridSizes -self $self -definitions $self.RowDefinitions -totalSize $bounds.Height
        $colWidths = & $self._CalculateGridSizes -self $self -definitions $self.ColumnDefinitions -totalSize $bounds.Width
        
        # Calculate offsets
        $rowOffsets = @(0)
        $colOffsets = @(0)
        
        for ($i = 0; $i -lt $rowHeights.Count - 1; $i++) {
            $rowOffsets += ($rowOffsets[-1] + $rowHeights[$i])
        }
        
        for ($i = 0; $i -lt $colWidths.Count - 1; $i++) {
            $colOffsets += ($colOffsets[-1] + $colWidths[$i])
        }
        
        # Layout children
        $layout = @{
            Children = @()
            Rows = $rowHeights
            Columns = $colWidths
            RowOffsets = $rowOffsets
            ColumnOffsets = $colOffsets
        }
        
        foreach ($child in $self.Children) {
            if (-not $child.Visible) { continue }
            
            # Get grid position
            $row = [Math]::Max(0, [Math]::Min($rowHeights.Count - 1, [int]($child.LayoutProps."Grid.Row" ?? 0)))
            $col = [Math]::Max(0, [Math]::Min($colWidths.Count - 1, [int]($child.LayoutProps."Grid.Column" ?? 0)))
            $rowSpan = [Math]::Max(1, [Math]::Min($rowHeights.Count - $row, [int]($child.LayoutProps."Grid.RowSpan" ?? 1)))
            $colSpan = [Math]::Max(1, [Math]::Min($colWidths.Count - $col, [int]($child.LayoutProps."Grid.ColumnSpan" ?? 1)))
            
            # Calculate cell bounds
            $cellX = $bounds.X + $colOffsets[$col]
            $cellY = $bounds.Y + $rowOffsets[$row]
            $cellWidth = 0
            $cellHeight = 0
            
            for ($i = 0; $i -lt $colSpan; $i++) {
                if (($col + $i) -lt $colWidths.Count) {
                    $cellWidth += $colWidths[$col + $i]
                }
            }
            
            for ($i = 0; $i -lt $rowSpan; $i++) {
                if (($row + $i) -lt $rowHeights.Count) {
                    $cellHeight += $rowHeights[$row + $i]
                }
            }
            
            # Apply alignment within cell
            $childX = $cellX
            $childY = $cellY
            $childWidth = [Math]::Min($child.Width, $cellWidth)
            $childHeight = [Math]::Min($child.Height, $cellHeight)
            
            # Horizontal alignment
            $hAlign = $child.LayoutProps."Grid.HorizontalAlignment" ?? "Stretch"
            switch ($hAlign) {
                "Center" { $childX = $cellX + [Math]::Floor(($cellWidth - $childWidth) / 2) }
                "Right" { $childX = $cellX + $cellWidth - $childWidth }
                "Stretch" { $childWidth = $cellWidth }
            }
            
            # Vertical alignment
            $vAlign = $child.LayoutProps."Grid.VerticalAlignment" ?? "Stretch"
            switch ($vAlign) {
                "Middle" { $childY = $cellY + [Math]::Floor(($cellHeight - $childHeight) / 2) }
                "Bottom" { $childY = $cellY + $cellHeight - $childHeight }
                "Stretch" { $childHeight = $cellHeight }
            }
            
            $layout.Children += @{
                Component = $child
                X = $childX
                Y = $childY
                Width = $childWidth
                Height = $childHeight
                Row = $row
                Column = $col
                RowSpan = $rowSpan
                ColumnSpan = $colSpan
            }
        }
        
        $self._cachedLayout = $layout
        $self._isDirty = $false
        return $layout
    }
    
    $panel.Render = {
        param($self)
        
        # Debug: Log panel state for debugging
        if (-not (Get-Command Write-Log -ErrorAction SilentlyContinue)) {
            # If Write-Log not available, use Write-Host for debugging
            Write-Host "[DEBUG] GridPanel Render: Title='$($self.Title)', Visible=$($self.Visible), Pos=($($self.X),$($self.Y)), Size=$($self.Width)x$($self.Height), Children=$($self.Children.Count)" -ForegroundColor Yellow
        } else {
            Write-Log -Level Debug -Message "GridPanel Render called: Title='$($self.Title)', Visible=$($self.Visible), Position=($($self.X),$($self.Y)), Size=$($self.Width)x$($self.Height), Children=$($self.Children.Count)"
        }
        
        if (-not $self.Visible) {
            Write-Log -Level Debug -Message "GridPanel '$($self.Title)' not visible, skipping render"
            return
        }
        
        # Clear background if color specified
        if ($self.BackgroundColor) {
            for ($y = $self.Y; $y -lt ($self.Y + $self.Height); $y++) {
                Write-BufferString -X $self.X -Y $y -Text (' ' * $self.Width) -BackgroundColor $self.BackgroundColor
            }
        }
        
        # Draw border if requested
        if ($self.ShowBorder) {
            $borderColor = if ($self.ForegroundColor) { $self.ForegroundColor } else { Get-ThemeColor "Border" -Default Gray }
            Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height -BorderColor $borderColor -Title $self.Title
        }
        
        # Calculate layout
        $layout = & $self.CalculateLayout -self $self
        Write-Log -Level Debug -Message "GridPanel '$($self.Title)' layout calculated: $($layout.Children.Count) children to render"
        
        # Draw grid lines if requested
        if ($self.ShowGridLines) {
            $bounds = & $self.GetContentBounds -self $self
            
            # Vertical lines
            foreach ($offset in $layout.ColumnOffsets[1..($layout.ColumnOffsets.Count - 1)]) {
                $x = $bounds.X + $offset - 1
                if ($x -ge $bounds.X -and $x -lt ($bounds.X + $bounds.Width)) {
                    for ($y = $bounds.Y; $y -lt ($bounds.Y + $bounds.Height); $y++) {
                        Write-BufferString -X $x -Y $y -Text "│" -ForegroundColor $self.GridLineColor
                    }
                }
            }
            
            # Horizontal lines
            foreach ($offset in $layout.RowOffsets[1..($layout.RowOffsets.Count - 1)]) {
                $y = $bounds.Y + $offset - 1
                if ($y -ge $bounds.Y -and $y -lt ($bounds.Y + $bounds.Height)) {
                    Write-BufferString -X $bounds.X -Y $y -Text ("─" * $bounds.Width) -ForegroundColor $self.GridLineColor
                }
            }
        }
        
        # Render children
        foreach ($childLayout in $layout.Children) {
            $child = $childLayout.Component
            
            # Apply calculated position and size
            $child.X = $childLayout.X
            $child.Y = $childLayout.Y
            
            # Only update size if property is settable
            if ($child.PSObject.Properties['Width'] -and $child.Width -ne $childLayout.Width) {
                $child.Width = $childLayout.Width
            }
            if ($child.PSObject.Properties['Height'] -and $child.Height -ne $childLayout.Height) {
                $child.Height = $childLayout.Height
            }
            
            # Render child
            if ($child.Render) {
                & $child.Render -self $child
            }
        }
    }
    
    return $panel
}

# Additional layout panel types for future extension
function global:New-TuiDockPanel {
    param([hashtable]$Props = @{})
    
    $panel = New-BasePanel -Props $Props
    $panel.Type = "DockPanel"
    $panel.Layout = 'Dock'
    $panel.LastChildFill = $Props.LastChildFill ?? $true
    
    # DockPanel implementation would go here
    # For now, fallback to StackPanel behavior
    $stackProps = $Props.Clone()
    $stackProps.Orientation = 'Vertical'
    return New-TuiStackPanel -Props $stackProps
}

function global:New-TuiWrapPanel {
    param([hashtable]$Props = @{})
    
    $panel = New-BasePanel -Props $Props
    $panel.Type = "WrapPanel"
    $panel.Layout = 'Wrap'
    $panel.Orientation = $Props.Orientation ?? 'Horizontal'
    $panel.ItemWidth = $Props.ItemWidth
    $panel.ItemHeight = $Props.ItemHeight
    
    # WrapPanel implementation would go here
    # For now, fallback to StackPanel behavior
    return New-TuiStackPanel -Props $Props
}

Export-ModuleMember -Function "New-BasePanel", "New-TuiStackPanel", "New-TuiGridPanel", "New-TuiDockPanel", "New-TuiWrapPanel"
# TUI Framework Integration Module - COMPLIANT VERSION
# Only contains compliant utility functions - deprecated functions removed

$script:TuiAsyncJobs = @()

function global:Invoke-TuiMethod {
    <#
    .SYNOPSIS
    Safely invokes a method on a TUI component.
    #>
    param(
        [Parameter(Mandatory=$true)]
        [hashtable]$Component,

        [Parameter(Mandatory=$true)]
        [string]$MethodName,

        [Parameter()]
        [hashtable]$Arguments = @{}
    )

    if ($null -eq $Component) { return }
    if (-not $Component.ContainsKey($MethodName)) { return }

    $method = $Component[$MethodName]
    if ($null -eq $method -or $method -isnot [scriptblock]) {
        # The method doesn't exist or is not a scriptblock, so we can't call it.
        # This prevents the "term is not recognized" error.
        return
    }

    # Add the component itself as the 'self' parameter for convenience
    $Arguments['self'] = $Component

    try {
        # Use splatting with the @ operator for robust parameter passing
        return & $method @Arguments
    
        } catch {
        $errorMessage = "Error invoking method '$MethodName' on component '$($Component.Type)': $($_.Exception.Message)"
        Write-Log -Level Error -Message $errorMessage -Data $_
        Request-TuiRefresh
    }
}

# Add 'Invoke-TuiMethod' to the Export-ModuleMember list at the end of the file.

function global:Initialize-TuiFramework {
    <#
    .SYNOPSIS
    Initializes the TUI framework
    #>
    
    # Ensure engine is initialized
    if (-not $global:TuiState) {
        throw "TUI Engine must be initialized before framework"
    }
    
    Write-Verbose "TUI Framework initialized"
}

function global:Invoke-TuiAsync {
    <#
    .SYNOPSIS
    Executes a script block asynchronously with proper job management
    
    .PARAMETER ScriptBlock
    The script block to execute asynchronously
    
    .PARAMETER OnComplete
    Handler to call when the job completes successfully
    
    .PARAMETER OnError
    Handler to call if the job encounters an error
    
    .PARAMETER ArgumentList
    Arguments to pass to the script block
    #>
    param(
        [Parameter(Mandatory = $true)]
        [scriptblock]$ScriptBlock,
        
        [Parameter()]
        [scriptblock]$OnComplete = {},
        
        [Parameter()]
        [scriptblock]$OnError = {},
        
        [Parameter()]
        [array]$ArgumentList = @()
    )
    
    try {
        # Start the job
        $job = Start-Job -ScriptBlock $ScriptBlock -ArgumentList $ArgumentList
        
        # Track the job for cleanup
        $script:TuiAsyncJobs += $job
        
        # Create a timer to check job status
        $timer = New-Object System.Timers.Timer
        $timer.Interval = 100  # Check every 100ms
        $timer.AutoReset = $true
        
        # Use Register-ObjectEvent to handle the timer tick
        $timerEvent = Register-ObjectEvent -InputObject $timer -EventName Elapsed -Action {
            $job = $Event.MessageData.Job
            $onComplete = $Event.MessageData.OnComplete
            $onError = $Event.MessageData.OnError
            $timer = $Event.MessageData.Timer
            
            if ($job.State -eq 'Completed') {
                try {
                    $result = Receive-Job -Job $job -ErrorAction Stop
                    Remove-Job -Job $job -Force
                    
                    # Remove from tracking
                    $script:TuiAsyncJobs = @($script:TuiAsyncJobs | Where-Object { $_ -ne $job })
                    
                    # Stop and dispose timer
                    $timer.Stop()
                    $timer.Dispose()
                    Unregister-Event -SourceIdentifier $Event.SourceIdentifier
                    
                    # Call completion handler on UI thread
                    if ($onComplete) {
                        & $onComplete -Data $result
                        Request-TuiRefresh
                    }
                } catch {
                    Write-Warning "Job receive error: $_"
                }
            }
            elseif ($job.State -eq 'Failed') {
                try {
                    $error = $job.ChildJobs[0].JobStateInfo.Reason
                    Remove-Job -Job $job -Force
                    
                    # Remove from tracking
                    $script:TuiAsyncJobs = @($script:TuiAsyncJobs | Where-Object { $_ -ne $job })
                    
                    # Stop and dispose timer
                    $timer.Stop()
                    $timer.Dispose()
                    Unregister-Event -SourceIdentifier $Event.SourceIdentifier
                    
                    # Call error handler
                    if ($onError) {
                        & $onError -Error $error
                        Request-TuiRefresh
                    }
                } catch {
                    Write-Warning "Job error handling failed: $_"
                }
            }
        } -MessageData @{
            Job = $job
            OnComplete = $OnComplete
            OnError = $OnError
            Timer = $timer
        }
        
        # Start the timer
        $timer.Start()
        
        # Return job info
        return @{
            Job = $job
            Timer = $timer
            EventSubscription = $timerEvent
        }
        
    } catch {
        Write-Warning "Failed to start async operation: $_"
        if ($OnError) {
            & $OnError -Error $_
        }
    }
}

function global:Stop-AllTuiAsyncJobs {
    <#
    .SYNOPSIS
    Stops and cleans up all tracked async jobs
    #>
    
    foreach ($job in $script:TuiAsyncJobs) {
        try {
            if ($job.State -eq 'Running') {
                Stop-Job -Job $job -ErrorAction SilentlyContinue
            }
            Remove-Job -Job $job -Force -ErrorAction SilentlyContinue
        } catch {
            Write-Warning "Failed to stop job: $_"
        }
    }
    
    $script:TuiAsyncJobs = @()
    
    # Clean up any orphaned timer events
    Get-EventSubscriber | Where-Object { $_.SourceObject -is [System.Timers.Timer] } | ForEach-Object {
        try {
            Unregister-Event -SourceIdentifier $_.SourceIdentifier -ErrorAction SilentlyContinue
            if ($_.SourceObject) {
                $_.SourceObject.Stop()
                $_.SourceObject.Dispose()
            }
        } catch { }
    }
}

function global:Create-TuiState {
    <#
    .SYNOPSIS
    Creates a reactive state management system with deep change detection
    
    .PARAMETER InitialState
    The initial state values
    
    .PARAMETER DeepWatch
    Enable deep property change detection (impacts performance)
    #>
    param(
        [Parameter()]
        [hashtable]$InitialState = @{},
        
        [Parameter()]
        [bool]$DeepWatch = $false
    )
    
    $stateManager = @{
        _data = $InitialState.Clone()
        _subscribers = @{}
        _deepWatch = $DeepWatch
        _changeQueue = @()
        _processing = $false
        
        GetValue = {
            param([string]$Path)
            if (-not $Path) { return $this._data }
            
            $parts = $Path -split '\.'
            $current = $this._data
            
            foreach ($part in $parts) {
                if ($null -eq $current) { return $null }
                $current = $current[$part]
            }
            
            return $current
        }
        
        SetValue = {
            param([string]$Path, $Value)
            
            $parts = $Path -split '\.'
            $current = $this._data
            
            # Navigate to parent
            for ($i = 0; $i -lt $parts.Count - 1; $i++) {
                $part = $parts[$i]
                if (-not $current.ContainsKey($part)) {
                    $current[$part] = @{}
                }
                $current = $current[$part]
            }
            
            # Get old value for comparison
            $lastPart = $parts[-1]
            $oldValue = $current[$lastPart]
            
            # Set new value
            $current[$lastPart] = $Value
            
            # Notify if changed
            if (-not (Compare-TuiValue $oldValue $Value)) {
                & $this.NotifySubscribers -Path $Path -OldValue $oldValue -NewValue $Value
                
                # Also notify parent paths
                $parentPath = ""
                for ($i = 0; $i -lt $parts.Count; $i++) {
                    if ($i -gt 0) { $parentPath += "." }
                    $parentPath += $parts[$i]
                    & $this.NotifySubscribers -Path $parentPath -OldValue $null -NewValue (& $this.GetValue $parentPath)
                }
            }
        }
        
        Update = {
            param([hashtable]$Updates)
            
            # Queue changes to batch notifications
            $this._changeQueue = @()
            
            foreach ($key in $Updates.Keys) {
                $oldValue = $this._data[$key]
                $this._data[$key] = $Updates[$key]
                
                if (-not (Compare-TuiValue $oldValue $Updates[$key])) {
                    $this._changeQueue += @{
                        Path = $key
                        OldValue = $oldValue
                        NewValue = $Updates[$key]
                    }
                }
            }
            
            # Process all notifications
            if ($this._changeQueue.Count -gt 0 -and -not $this._processing) {
                $this._processing = $true
                try {
                    foreach ($change in $this._changeQueue) {
                        & $this.NotifySubscribers @change
                    }
                } finally {
                    $this._processing = $false
                    $this._changeQueue = @()
                }
            }
        }
        
        Subscribe = {
            param(
                [string]$Path,
                [scriptblock]$Handler,
                [string]$SubscriptionId = [Guid]::NewGuid().ToString()
            )
            
            if (-not $this._subscribers.ContainsKey($Path)) {
                $this._subscribers[$Path] = @()
            }
            
            $this._subscribers[$Path] += @{
                Id = $SubscriptionId
                Handler = $Handler
            }
            
            # Call handler with current value
            $currentValue = & $this.GetValue $Path
            try {
                & $Handler -NewValue $currentValue -OldValue $null -Path $Path
            } catch {
                Write-Warning "State subscriber error: $_"
            }
            
            return $SubscriptionId
        }
        
        Unsubscribe = {
            param([string]$SubscriptionId)
            
            foreach ($path in @($this._subscribers.Keys)) {
                $this._subscribers[$path] = @($this._subscribers[$path] | Where-Object { $_.Id -ne $SubscriptionId })
                if ($this._subscribers[$path].Count -eq 0) {
                    $this._subscribers.Remove($path)
                }
            }
        }
        
        NotifySubscribers = {
            param([string]$Path, $OldValue, $NewValue)
            
            # Exact path subscribers
            if ($this._subscribers.ContainsKey($Path)) {
                foreach ($sub in $this._subscribers[$Path]) {
                    try {
                        & $sub.Handler -NewValue $NewValue -OldValue $OldValue -Path $Path
                    } catch {
                        Write-Warning "State notification error: $_"
                    }
                }
            }
            
            # Wildcard subscribers (e.g., "user.*")
            foreach ($subPath in $this._subscribers.Keys) {
                if ($subPath.EndsWith('*')) {
                    $basePath = $subPath.TrimEnd('*').TrimEnd('.')
                    if ($Path.StartsWith($basePath)) {
                        foreach ($sub in $this._subscribers[$subPath]) {
                            try {
                                & $sub.Handler -NewValue $NewValue -OldValue $OldValue -Path $Path
                            } catch {
                                Write-Warning "State wildcard notification error: $_"
                            }
                        }
                    }
                }
            }
        }
        
        Reset = {
            param([hashtable]$NewState = @{})
            $oldData = $this._data
            $this._data = $NewState.Clone()
            
            # Notify all subscribers of reset
            foreach ($path in $this._subscribers.Keys) {
                $oldValue = Get-NestedProperty -Object $oldData -Path $path
                $newValue = & $this.GetValue $path
                
                if (-not (Compare-TuiValue $oldValue $newValue)) {
                    & $this.NotifySubscribers -Path $path -OldValue $oldValue -NewValue $newValue
                }
            }
        }
    }
    
    return $stateManager
}

function Compare-TuiValue {
    <#
    .SYNOPSIS
    Compares two values for equality, handling nulls and complex types
    #>
    param($Value1, $Value2)
    
    if ($null -eq $Value1 -and $null -eq $Value2) { return $true }
    if ($null -eq $Value1 -or $null -eq $Value2) { return $false }
    
    if ($Value1 -is [hashtable] -and $Value2 -is [hashtable]) {
        if ($Value1.Count -ne $Value2.Count) { return $false }
        foreach ($key in $Value1.Keys) {
            if (-not $Value2.ContainsKey($key)) { return $false }
            if (-not (Compare-TuiValue $Value1[$key] $Value2[$key])) { return $false }
        }
        return $true
    }
    
    if ($Value1 -is [array] -and $Value2 -is [array]) {
        if ($Value1.Count -ne $Value2.Count) { return $false }
        for ($i = 0; $i -lt $Value1.Count; $i++) {
            if (-not (Compare-TuiValue $Value1[$i] $Value2[$i])) { return $false }
        }
        return $true
    }
    
    return $Value1 -eq $Value2
}

function Get-NestedProperty {
    param($Object, $Path)
    
    $parts = $Path -split '\.'
    $current = $Object
    
    foreach ($part in $parts) {
        if ($null -eq $current) { return $null }
        $current = $current[$part]
    }
    
    return $current
}

function global:Remove-TuiComponent {
    <#
    .SYNOPSIS
    Properly removes a component and cleans up references to prevent memory leaks
    
    .PARAMETER Component
    The component to remove
    #>
    param(
        [Parameter(Mandatory = $true)]
        [hashtable]$Component
    )
    
    try {
        # Remove event handlers if the component has an ID or Name
        $componentId = if ($Component.Id) { $Component.Id } elseif ($Component.Name) { $Component.Name } else { $null }
        
        if ($componentId -and (Get-Command -Name "Remove-ComponentEventHandlers" -ErrorAction SilentlyContinue)) {
            Remove-ComponentEventHandlers -ComponentId $componentId
        }
        
        # Clear focus if this component is focused
        if ($global:TuiState -and $global:TuiState.FocusedComponent -eq $Component) {
            if (Get-Command -Name "Clear-ComponentFocus" -ErrorAction SilentlyContinue) {
                Clear-ComponentFocus
            } else {
                $global:TuiState.FocusedComponent = $null
            }
        }
        
        # Break circular references
        if ($Component.Parent) {
            # Remove from parent's children collection
            if ($Component.Parent._children -and $Component.Name) {
                $Component.Parent._children.Remove($Component.Name)
            }
            if ($Component.Parent.Children) {
                $Component.Parent.Children = @($Component.Parent.Children | Where-Object { $_ -ne $Component })
            }
            $Component.Parent = $null
        }
        
        if ($Component.ParentScreen) {
            # Remove from parent screen's children
            if ($Component.ParentScreen._children -and $Component.Name) {
                $Component.ParentScreen._children.Remove($Component.Name)
            }
            # Remove from focusable names
            if ($Component.ParentScreen._focusableNames) {
                $Component.ParentScreen._focusableNames = @($Component.ParentScreen._focusableNames | Where-Object { $_ -ne $Component.Name })
            }
            $Component.ParentScreen = $null
        }
        
        # Clear children references
        if ($Component.Children) {
            foreach ($child in $Component.Children) {
                if ($child -is [hashtable]) {
                    $child.Parent = $null
                    $child.ParentScreen = $null
                }
            }
            $Component.Children = @()
        }
        
        if ($Component._children) {
            foreach ($childName in @($Component._children.Keys)) {
                $child = $Component._children[$childName]
                if ($child -is [hashtable]) {
                    $child.Parent = $null
                    $child.ParentScreen = $null
                }
            }
            $Component._children.Clear()
        }
        
        # Call component's dispose method if it exists
        if ($Component.Dispose) {
            try {
                & $Component.Dispose -self $Component
            } catch {
                Write-Warning "Component dispose error: $_"
            }
        }
        
        # Clear any async operations or timers
        if ($Component._timers) {
            foreach ($timer in $Component._timers) {
                if ($timer -and $timer.Enabled) {
                    $timer.Stop()
                    $timer.Dispose()
                }
            }
            $Component._timers = @()
        }
        
        # Clear state subscriptions
        if ($Component._stateSubscriptions) {
            foreach ($sub in $Component._stateSubscriptions) {
                if ($sub -and (Get-Command -Name "Unsubscribe-Event" -ErrorAction SilentlyContinue)) {
                    try {
                        Unsubscribe-Event -HandlerId $sub
                    } catch { }
                }
            }
            $Component._stateSubscriptions = @()
        }
        
        # Remove from global component registry if registered
        if ($global:TuiState -and $global:TuiState.Components) {
            $global:TuiState.Components = @($global:TuiState.Components | Where-Object { $_ -ne $Component })
        }
        
        Write-Verbose "Component removed: $componentId"
        
    } catch {
        Write-Warning "Error removing component: $_"
    }
}

# Export all functions
Export-ModuleMember -Function @(
    'Initialize-TuiFramework',
    'Invoke-TuiAsync',
    'Stop-AllTuiAsyncJobs',
    'Create-TuiState',
    'Compare-TuiValue',
    'Remove-TuiComponent',
    'Invoke-TuiMethod'
)
# Rock-Solid TUI Engine v4.0 - Performance & Reliability Edition
# Implements all critical fixes from code review



#region Core TUI State
$script:TuiState = @{
    Running         = $false
    BufferWidth     = 0
    BufferHeight    = 0
    FrontBuffer     = $null
    BackBuffer      = $null
    ScreenStack     = New-Object System.Collections.Stack
    CurrentScreen   = $null
    IsDirty         = $true
    LastActivity    = [DateTime]::Now
    LastRenderTime  = [DateTime]::MinValue
    RenderStats     = @{ LastFrameTime = 0; FrameCount = 0; TotalTime = 0; TargetFPS = 60 }
    Components      = @()
    Layouts         = @{}
    DebugOverlayEnabled = $false
    FocusedComponent = $null
    
    # Thread-safe input queue and runspace management
    InputQueue = $null
    InputRunspace = $null
    InputPowerShell = $null
    InputAsyncResult = $null
    
    # The correct, thread-safe object for signalling shutdown.
    CancellationTokenSource = $null
    
    # Event cleanup tracking
    EventHandlers = @{}
}

# Debug messages removed to prevent screen bleed-through
# Note: Width and Height params are only available inside Initialize-TuiEngine function



# Cell pool to avoid thousands of hashtable allocations
$script:CellPool = @{
    Pool = New-Object System.Collections.Queue
    MaxSize = 1000
}
#endregion

#region Cell Management & Object Pooling

function Get-PooledCell {
    param(
        [char]$Char = ' ',
        [ConsoleColor]$FG = [ConsoleColor]::White,
        [ConsoleColor]$BG = [ConsoleColor]::Black
    )
    
    if ($script:CellPool.Pool.Count -gt 0) {
        $cell = $script:CellPool.Pool.Dequeue()
        $cell.Char = $Char
        $cell.FG = $FG
        $cell.BG = $BG
        return $cell
    }
    
    # Create new cell if pool is empty
    return @{
        Char = $Char
        FG = $FG
        BG = $BG
    }
}

function Return-CellToPool {
    param($Cell)
    if ($script:CellPool.Pool.Count -lt $script:CellPool.MaxSize) {
        $script:CellPool.Pool.Enqueue($Cell)
    }
}

#endregion

#region Engine Lifecycle & Main Loop

function global:Initialize-TuiEngine {
    param(
        [int]$Width = [Console]::WindowWidth,
        [int]$Height = [Console]::WindowHeight - 1
    )

    # Patch: Always set defaults if not passed in
    if (-not $Width) { $Width = [Console]::WindowWidth }
    if (-not $Height) { $Height = [Console]::WindowHeight - 1 }
    
    if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
        Write-Log -Level Info -Message "Initializing TUI Engine: ${Width}x${Height}"
    }

   

    
    
    try {
        if ($Width -le 0 -or $Height -le 0) { throw "Invalid console dimensions: ${Width}x${Height}" }
        
        $script:TuiState.BufferWidth = $Width
        $script:TuiState.BufferHeight = $Height
        
        # Create 2D arrays for buffers
        $script:TuiState.FrontBuffer = New-Object 'object[,]' $Height, $Width
        $script:TuiState.BackBuffer = New-Object 'object[,]' $Height, $Width
        
        # Initialize buffers with empty cells
        $emptyCell = @{ Char = ' '; FG = [ConsoleColor]::White; BG = [ConsoleColor]::Black }
        for ($y = 0; $y -lt $Height; $y++) {
            for ($x = 0; $x -lt $Width; $x++) {
                $script:TuiState.FrontBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = [ConsoleColor]::Black }
                $script:TuiState.BackBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = [ConsoleColor]::Black }
            }
        }
        
        [Console]::CursorVisible = $false
        [Console]::Clear() # Clear console to remove initialization messages
        
        # Initialize subsystems with error handling
        try { 
            Initialize-LayoutEngines 
            if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
                Write-Log -Level Debug -Message "Layout engines initialized"
            }
        } catch { 
            Write-Warning "Layout engines init failed: $_" 
            if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
                Write-Log -Level Error -Message "Layout engines init failed" -Data $_
            }
        }
        try { 
            Initialize-ComponentSystem 
            if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
                Write-Log -Level Debug -Message "Component system initialized"
            }
        } catch { 
            Write-Warning "Component system init failed: $_" 
            if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
                Write-Log -Level Error -Message "Component system init failed" -Data $_
            }
        }
        
        # Track event handlers for cleanup (event system should already be initialized)
        $script:TuiState.EventHandlers = @{}
        
        # --- THE FIX: HOOK CTRL+C *BEFORE* STARTING THE INPUT THREAD ---
        # Temporarily disabled due to compatibility issues
        # TODO: Re-enable with proper PowerShell event handling
        try {
            [Console]::TreatControlCAsInput = $false
            # Ctrl+C handler temporarily disabled - will terminate process normally
        } catch {
            Write-Warning "Could not set console input mode: $_"
        }
        
        # Now it is safe to start the input thread.
        Initialize-InputThread
        
        # Publish initialization event
        Safe-PublishEvent -EventName "System.EngineInitialized" -Data @{ Width = $Width; Height = $Height }
        
        # Export TuiState for global access
        $global:TuiState = $script:TuiState
        
        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            Write-Log -Level Info -Message "TUI Engine initialized successfully"
        }
    }
    catch {
        # --- ENHANCED DIAGNOSTIC BLOCK ---
        # This will now clearly print the root cause of any initialization failure.
        Write-Host "--------------------------------------------------------" -ForegroundColor Red
        Write-Host "IMMEDIATE, ORIGINAL ERROR DETECTED DURING INITIALIZATION" -ForegroundColor Red
        Write-Host "THE *REAL* PROBLEM IS LIKELY THIS:" -ForegroundColor Yellow
        
        if ($_) {
            Write-Host "MESSAGE: $($_.Exception.Message)" -ForegroundColor White
            
            Write-Host "FULL ERROR:" -ForegroundColor Yellow
            if ($_.Exception) {
                $_.Exception | Format-List * -Force
            } else {
                Write-Host "Error details: $_" -ForegroundColor White
            }
        } else {
            Write-Host "Unknown error occurred" -ForegroundColor White
        }
        
        Write-Host "--------------------------------------------------------" -ForegroundColor Red
        
        # Re-throw the exception so the main script's finally block is triggered for cleanup.
        throw "FATAL: TUI Engine initialization failed. See original error details above."
    }
}

function Initialize-InputThread {
    try {
        # Create thread-safe input handling
        $queueType = [System.Collections.Concurrent.ConcurrentQueue[System.ConsoleKeyInfo]]
        $script:TuiState.InputQueue = New-Object $queueType
    } catch {
        Write-Warning "Failed to create ConcurrentQueue, falling back to ArrayList"
        $script:TuiState.InputQueue = [System.Collections.ArrayList]::Synchronized([System.Collections.ArrayList]::new())
    }
    
    # Create the cancellation token source for thread-safe shutdown.
    $script:TuiState.CancellationTokenSource = [System.Threading.CancellationTokenSource]::new()
    $token = $script:TuiState.CancellationTokenSource.Token

    # Create runspace for input handling (fully-qualified .NET types)
    $runspace = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()
    $runspace.Open()
    $runspace.SessionStateProxy.SetVariable('InputQueue', $script:TuiState.InputQueue)
    $runspace.SessionStateProxy.SetVariable('token', $token)
    
    # Create a PowerShell instance in that runspace
    $ps = [System.Management.Automation.PowerShell]::Create()
    $ps.Runspace = $runspace
    
    # This script block will run in the background.
    $ps.AddScript({
        try {
            while (-not $token.IsCancellationRequested) {
                if ([Console]::KeyAvailable) {
                    $keyInfo = [Console]::ReadKey($true)
                    
                    # Handle different queue types
                    if ($InputQueue -is [System.Collections.Concurrent.ConcurrentQueue[System.ConsoleKeyInfo]]) {
                        if ($InputQueue.Count -lt 100) {
                            $InputQueue.Enqueue($keyInfo)
                        }
                    } elseif ($InputQueue -is [System.Collections.ArrayList]) {
                        if ($InputQueue.Count -lt 100) {
                            $InputQueue.Add($keyInfo) | Out-Null
                        }
                    }
                }
                else {
                    Start-Sleep -Milliseconds 20
                }
            }
        }
        catch [System.Management.Automation.PipelineStoppedException] {
            return
        }
        catch {
            Write-Warning "Input thread error: $_"
        }
    }) | Out-Null
    
    # Store for cleanup
    $script:TuiState.InputRunspace   = $runspace
    $script:TuiState.InputPowerShell = $ps
    $script:TuiState.InputAsyncResult = $ps.BeginInvoke()
}

function Process-TuiInput {
    # Process all queued input events
    $processedAny = $false
    # Check if the queue exists before trying to use it.
    if (-not $script:TuiState.InputQueue) { return $false }
    
    if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
        Write-Log -Level Verbose -Message "Processing input queue"
    }

    $keyInfo = $null
    
    # Handle different queue types
    if ($script:TuiState.InputQueue -is [System.Collections.Concurrent.ConcurrentQueue[System.ConsoleKeyInfo]]) {
        $keyInfo = [System.ConsoleKeyInfo]::new([char]0, [System.ConsoleKey]::None, $false, $false, $false)
        while ($script:TuiState.InputQueue.TryDequeue([ref]$keyInfo)) {
            $processedAny = $true
            $script:TuiState.LastActivity = [DateTime]::Now
            Process-SingleKeyInput -keyInfo $keyInfo
        }
    } elseif ($script:TuiState.InputQueue -is [System.Collections.ArrayList]) {
        while ($script:TuiState.InputQueue.Count -gt 0) {
            try {
                $keyInfo = $script:TuiState.InputQueue[0]
                $script:TuiState.InputQueue.RemoveAt(0)
                $processedAny = $true
                $script:TuiState.LastActivity = [DateTime]::Now
                Process-SingleKeyInput -keyInfo $keyInfo
            } catch {
                break
            }
        }
    }
    
    return $processedAny
}

###```focus adddition 
function global:Set-ComponentFocus {
    param(
        [hashtable]$Component
    )
    
    $oldFocusedComponent = $script:TuiState.FocusedComponent
    
    if ($null -ne $oldFocusedComponent -and $oldFocusedComponent -ne $Component) {
        $oldFocusedComponent.IsFocused = $false
        if ($oldFocusedComponent.OnBlur) {
            try { & $oldFocusedComponent.OnBlur -self $oldFocusedComponent }
            catch { Write-Log -Level Warning -Message "OnBlur error: $_" }
        }
    }

    if ($null -eq $Component) {
        $script:TuiState.FocusedComponent = $null
        Request-TuiRefresh
        return
    }

    if ($Component.IsFocusable -ne $true -or $Component.Visible -ne $true) {
        return
    }

    $script:TuiState.FocusedComponent = $Component
    $Component.IsFocused = $true
    
    if ($Component.OnFocus) {
        try { & $Component.OnFocus -self $Component }
        catch { Write-Log -Level Warning -Message "OnFocus error: $_" }
    }
    
    Request-TuiRefresh
}

function global:Handle-TabNavigation {
    param(
        [bool]$Reverse = $false
    )
    
    $currentScreen = $script:TuiState.CurrentScreen
    if (-not $currentScreen) { return }

    $focusable = @()
    $FindFocusableIn = {
        param($component)
        if ($component -and $component.IsFocusable -eq $true -and $component.Visible -eq $true) {
            $script:focusable += $component
        }
        if ($component -and $component.Children) {
            foreach ($child in $component.Children) {
                & $script:FindFocusableIn -component $child
            }
        }
    }
    
    foreach ($compName in $currentScreen.Components.Keys) {
        & $FindFocusableIn -component $currentScreen.Components[$compName]
    }

    if ($focusable.Count -eq 0) { return }

    $sortedFocusable = $focusable | Sort-Object { $_.Y }, { $_.X }

    $currentIndex = [array]::IndexOf($sortedFocusable, $script:TuiState.FocusedComponent)
    
    $nextIndex = 0
    if ($currentIndex -ne -1) {
        $direction = if ($Reverse) { -1 } else { 1 }
        $nextIndex = ($currentIndex + $direction + $sortedFocusable.Count) % $sortedFocusable.Count
    }

    Set-ComponentFocus -Component $sortedFocusable[$nextIndex]
}

function global:Clear-ComponentFocus {
    Set-ComponentFocus -Component $null
}
###```

function Process-SingleKeyInput {
    param($keyInfo)
    
    try {
        # Tab navigation handled by focus manager if available
        if ($keyInfo.Key -eq [ConsoleKey]::Tab) {
            if (Get-Command -Name "Move-Focus" -ErrorAction SilentlyContinue) {
                Move-Focus -Reverse ($keyInfo.Modifiers -band [ConsoleModifiers]::Shift)
            } else {
                # Fallback to old tab navigation
                Handle-TabNavigation -Reverse ($keyInfo.Modifiers -band [ConsoleModifiers]::Shift)
            }
            return
        }
        
        # Dialog system gets first chance at input
        if ((Get-Command -Name "Handle-DialogInput" -ErrorAction SilentlyContinue) -and (Handle-DialogInput -Key $keyInfo)) {
            return
        }
        
        # Get focused component from focus manager if available
        $focusedComponent = if (Get-Command -Name "Get-FocusedComponent" -ErrorAction SilentlyContinue) {
            Get-FocusedComponent
        } else {
            $script:TuiState.FocusedComponent
        }
        
        # Focused component gets the next chance
        if ($focusedComponent -and $focusedComponent.HandleInput) {
            try {
                if (& $focusedComponent.HandleInput -self $focusedComponent -Key $keyInfo) {
                    return
                }
            } catch {
                Write-Warning "Component input handler error: $_"
            }
        }
        
        # Finally, the screen itself gets the key
        $currentScreen = $script:TuiState.CurrentScreen
        if ($currentScreen -and $currentScreen.HandleInput) {
            try {
                $result = & $currentScreen.HandleInput -self $currentScreen -Key $keyInfo
                switch ($result) {
                    "Back" { Pop-Screen }
                    "Quit" { 
                        $script:TuiState.Running = $false
                        if ($script:TuiState.CancellationTokenSource) {
                            $script:TuiState.CancellationTokenSource.Cancel()
                        }
                    }
                }
            } catch {
                Write-Warning "Screen input handler error: $_"
            }
        }
    } catch {
        Write-Warning "Input processing error: $_"
    }
}

function global:Start-TuiLoop {
    param([hashtable]$InitialScreen = $null)

    try {
        # Only initialize if not already initialized
        if (-not $script:TuiState.BufferWidth -or $script:TuiState.BufferWidth -eq 0) {
            Initialize-TuiEngine
        }
        
        if ($InitialScreen) {
            Push-Screen -Screen $InitialScreen
        }
        
        # If no screen is active and no initial screen provided, we can't start
        if (-not $script:TuiState.CurrentScreen -and $script:TuiState.ScreenStack.Count -eq 0) {
            throw "No screen available to display. Push a screen before calling Start-TuiLoop or provide an InitialScreen parameter."
        }

        $script:TuiState.Running = $true
        $frameTime = New-Object System.Diagnostics.Stopwatch
        $targetFrameTime = 1000.0 / $script:TuiState.RenderStats.TargetFPS
        
        while ($script:TuiState.Running) {
            $frameTime.Restart()
            
            try {
                # Process input
                $hadInput = Process-TuiInput
                
                # Update dialog system
                if (Get-Command -Name "Update-DialogSystem" -ErrorAction SilentlyContinue) { 
                    try { Update-DialogSystem } catch { Write-Warning "Dialog update error: $_" }
                }

                # Render if dirty or had input
                if ($script:TuiState.IsDirty -or $hadInput) {
                    Render-Frame
                    $script:TuiState.IsDirty = $false
                }
                
                # Adaptive frame timing
                $elapsed = $frameTime.ElapsedMilliseconds
                if ($elapsed -lt $targetFrameTime) {
                    $sleepTime = [Math]::Max(1, $targetFrameTime - $elapsed)
                    Start-Sleep -Milliseconds $sleepTime
                }
            } catch {
                Write-Warning "Main loop error: $_"
                $script:TuiState.IsDirty = $true  # Force redraw on error
            }
        }
    }
    finally {
        Cleanup-TuiEngine
    }
}

function Render-Frame {
    try {
        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            Write-Log -Level Verbose -Message "Starting frame render"
        }
        
        $bgColor = if (Get-Command -Name "Get-ThemeColor" -ErrorAction SilentlyContinue) {
            Get-ThemeColor "Background"
        } else {
            [ConsoleColor]::Black
        }
        
        # Always clear the back buffer completely
        Clear-BackBuffer -BackgroundColor $bgColor
        
        # Render current screen
        if ($script:TuiState.CurrentScreen -and $script:TuiState.CurrentScreen.Render) {
            try {
                & $script:TuiState.CurrentScreen.Render -self $script:TuiState.CurrentScreen
            } catch {
                $errorMessage = "Screen render error: $($_.Exception.Message)"
                if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
                    Write-Log -Level Error -Message $errorMessage -Data $_
                }
                # Draw error message on screen
                Write-BufferString -X 2 -Y 2 -Text $errorMessage -ForegroundColor Red
            }
        }
        
        # Render dialogs on top
        if (Get-Command -Name "Render-Dialogs" -ErrorAction SilentlyContinue) {
            try {
                Render-Dialogs
            } catch {
                Write-Warning "Dialog render error: $_"
            }
        }
        
        # Perform optimized render
        Render-BufferOptimized
        
        # Force cursor to bottom-right to avoid interference
        [Console]::SetCursorPosition($script:TuiState.BufferWidth - 1, $script:TuiState.BufferHeight - 1)
        
    } catch {
        Write-Warning "Frame render error: $_"
    }
}

function global:Request-TuiRefresh {
    $script:TuiState.IsDirty = $true
}

function Cleanup-TuiEngine {
    try {
        # --- ROBUST CLEANUP ROUTINE ---
        # This sequence is defensive and will not fail even if initialization was partial.
        if ($script:TuiState.CancellationTokenSource) {
            try {
                if (-not $script:TuiState.CancellationTokenSource.IsCancellationRequested) {
                    $script:TuiState.CancellationTokenSource.Cancel()
                }
            } catch { 
                # Ignore errors if CancellationTokenSource is in an invalid state
            }
        }

        if ($script:TuiState.InputPowerShell) {
            if ($script:TuiState.InputAsyncResult) {
                try { $script:TuiState.InputPowerShell.EndInvoke($script:TuiState.InputAsyncResult) } catch { }
            }
            try { $script:TuiState.InputPowerShell.Dispose() } catch { }
        }
        
        if ($script:TuiState.InputRunspace) {
            try { $script:TuiState.InputRunspace.Dispose() } catch { }
        }
        
        if ($script:TuiState.CancellationTokenSource) {
            try { $script:TuiState.CancellationTokenSource.Dispose() } catch { }
        }

        # Clean up background jobs
        if (Get-Command -Name "Stop-AllTuiAsyncJobs" -ErrorAction SilentlyContinue) {
            try { Stop-AllTuiAsyncJobs } catch { }
        }

        Cleanup-EventHandlers
        
        # Only try to reset the console if we are in an interactive session
        if (-not $env:CI -and -not $PSScriptRoot) {
            try {
                if ([System.Environment]::UserInteractive) {
                    [Console]::Write("$([char]27)[0m")
                    [Console]::CursorVisible = $true
                    [Console]::Clear()
                    [Console]::ResetColor()
                }
            } catch {
                # This can fail in non-interactive environments, ignore the error.
            }
        }
    } catch {
        Write-Warning "A secondary error occurred during TUI cleanup: $_"
    }
}

function Cleanup-EventHandlers {
    if (-not (Get-Command -Name "Unsubscribe-Event" -ErrorAction SilentlyContinue)) { return }
    if (-not $script:TuiState.EventHandlers) { return }

    foreach ($handlerId in $script:TuiState.EventHandlers.Values) {
        try { Unsubscribe-Event -HandlerId $handlerId } catch { }
    }
    $script:TuiState.EventHandlers.Clear()
    
    # Clean up any Ctrl+C event handler if it exists
    try {
        Get-EventSubscriber -SourceIdentifier "TuiCtrlC" -ErrorAction SilentlyContinue | Unregister-Event
    } catch { }
}

function Safe-PublishEvent {
    param($EventName, $Data)
    if (Get-Command -Name "Publish-Event" -ErrorAction SilentlyContinue) {
        try { Publish-Event -EventName $EventName -Data $Data } catch { }
    }
}

#endregion

#region Screen Management

function global:Push-Screen {
    param([hashtable]$Screen)
    if (-not $Screen) { return }
    
    if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
        Write-Log -Level Debug -Message "Pushing screen: $($Screen.Name)"
    }
    
    try {
        # Handle focus before switching screens
        if ($script:TuiState.FocusedComponent -and $script:TuiState.FocusedComponent.OnBlur) {
            try {
                & $script:TuiState.FocusedComponent.OnBlur -self $script:TuiState.FocusedComponent
            } catch {
                Write-Warning "Component blur error: $_"
            }
        }
        
        if ($script:TuiState.CurrentScreen) {
            if ($script:TuiState.CurrentScreen.OnExit) { 
                try {
                    & $script:TuiState.CurrentScreen.OnExit -self $script:TuiState.CurrentScreen
                } catch {
                    Write-Warning "Screen exit error: $_"
                }
            }
            $script:TuiState.ScreenStack.Push($script:TuiState.CurrentScreen)
        }
        
        $script:TuiState.CurrentScreen = $Screen
        $script:TuiState.FocusedComponent = $null  # Clear focus when changing screens
        
        if ($Screen.Init) { 
            try {
                & $Screen.Init -self $Screen 
            } catch {
                Write-Warning "Screen init error: $_"
            }
        }
        
        Request-TuiRefresh
        Safe-PublishEvent -EventName "Screen.Pushed" -Data @{ ScreenName = $Screen.Name }
        
    } catch {
        Write-Warning "Push screen error: $_"
    }
}

function global:Pop-Screen {
    if ($script:TuiState.ScreenStack.Count -eq 0) { return $false }
    
    if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
        Write-Log -Level Debug -Message "Popping screen"
    }
    
    try {
        # Handle focus before switching screens
        if ($script:TuiState.FocusedComponent -and $script:TuiState.FocusedComponent.OnBlur) {
            try {
                & $script:TuiState.FocusedComponent.OnBlur -self $script:TuiState.FocusedComponent
            } catch {
                Write-Warning "Component blur error: $_"
            }
        }
        
        # Store the screen to exit before changing CurrentScreen
        $screenToExit = $script:TuiState.CurrentScreen
        
        # Pop the new screen from the stack
        $script:TuiState.CurrentScreen = $script:TuiState.ScreenStack.Pop()
        $script:TuiState.FocusedComponent = $null  # Clear focus when changing screens
        
        # Call lifecycle hooks in correct order
        if ($screenToExit -and $screenToExit.OnExit) { 
            try {
                & $screenToExit.OnExit -self $screenToExit
            } catch {
                Write-Warning "Screen exit error: $_"
            }
        }
        if ($script:TuiState.CurrentScreen -and $script:TuiState.CurrentScreen.OnResume) { 
            try {
                & $script:TuiState.CurrentScreen.OnResume -self $script:TuiState.CurrentScreen
            } catch {
                Write-Warning "Screen resume error: $_"
            }
        }
        
        # Restore focus if the screen tracks it
        if ($script:TuiState.CurrentScreen.LastFocusedComponent) {
            Set-ComponentFocus -Component $script:TuiState.CurrentScreen.LastFocusedComponent
        }
        
        Request-TuiRefresh
        Safe-PublishEvent -EventName "Screen.Popped" -Data @{ ScreenName = $script:TuiState.CurrentScreen.Name }
        
        return $true
        
    } catch {
        Write-Warning "Pop screen error: $_"
        return $false
    }
}

#endregion

#region Buffer and Rendering

# GetBufferIndex no longer needed - using 2D arrays directly

function global:Clear-BackBuffer {
    param([ConsoleColor]$BackgroundColor = [ConsoleColor]::Black)
    
    # Create a new cell for each position to ensure proper clearing
    for ($y = 0; $y -lt $script:TuiState.BufferHeight; $y++) {
        for ($x = 0; $x -lt $script:TuiState.BufferWidth; $x++) {
            $script:TuiState.BackBuffer[$y, $x] = @{ 
                Char = ' '
                FG = [ConsoleColor]::White
                BG = $BackgroundColor 
            }
        }
    }
}

function global:Write-BufferString {
    param(
        [int]$X, 
        [int]$Y, 
        [string]$Text, 
        [ConsoleColor]$ForegroundColor = [ConsoleColor]::White, 
        [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black
    )
    if ($Y -lt 0 -or $Y -ge $script:TuiState.BufferHeight) { return }
    if ([string]::IsNullOrEmpty($Text)) { return }
    
    $currentX = $X
    foreach ($char in $Text.ToCharArray()) {
        if ($currentX -ge $script:TuiState.BufferWidth) { break }

        if ($currentX -ge 0) {
            $script:TuiState.BackBuffer[$Y, $currentX] = @{ 
                Char = $char
                FG = $ForegroundColor
                BG = $BackgroundColor 
            }
        }
        
        # Pragmatic check for CJK/wide characters. A full implementation is library-dependent.
        if ($char -match '[\u1100-\u11FF\u2E80-\uA4CF\uAC00-\uD7A3\uF900-\uFAFF\uFE30-\uFE4F\uFF00-\uFFEF]') {
            $currentX += 2
            # Also fill the next cell with a space for wide characters to prevent overlap
            if ($currentX -lt $script:TuiState.BufferWidth -and $currentX -gt 0) {
                $script:TuiState.BackBuffer[$Y, $currentX - 1] = @{ 
                    Char = ' '
                    FG = $ForegroundColor
                    BG = $BackgroundColor 
                }
            }
        } else {
            $currentX++
        }
    }
}

function global:Write-BufferBox {
    param(
        [int]$X, 
        [int]$Y, 
        [int]$Width, 
        [int]$Height, 
        [string]$BorderStyle = "Single", 
        [ConsoleColor]$BorderColor = [ConsoleColor]::White, 
        [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black, 
        [string]$Title = ""
    )
    $borders = Get-BorderChars -Style $BorderStyle
    
    # Top border
    Write-BufferString -X $X -Y $Y -Text "$($borders.TopLeft)$($borders.Horizontal * ($Width - 2))$($borders.TopRight)" -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    
    # Title
    if ($Title) {
        $titleText = " $Title "
        if ($titleText.Length -gt ($Width - 2)) {
            # FIX: Ensure the length for Substring is never negative.
            $maxLength = [Math]::Max(0, $Width - 5)
            $titleText = " $($Title.Substring(0, $maxLength))... "
        }
        $titleX = $X + [Math]::Floor(($Width - $titleText.Length) / 2)
       Write-BufferString -X $titleX -Y $Y -Text $titleText -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    
    # Sides and Fill
    for ($i = 1; $i -lt ($Height - 1); $i++) {
        Write-BufferString -X $X -Y ($Y + $i) -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
        Write-BufferString -X ($X + 1) -Y ($Y + $i) -Text (' ' * ($Width - 2)) -BackgroundColor $BackgroundColor
        Write-BufferString -X ($X + $Width - 1) -Y ($Y + $i) -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    
    # Bottom border
    Write-BufferString -X $X -Y ($Y + $Height - 1) -Text "$($borders.BottomLeft)$($borders.Horizontal * ($Width - 2))$($borders.BottomRight)" -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
}

function global:Render-BufferOptimized {
    $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()
    $outputBuilder = New-Object System.Text.StringBuilder -ArgumentList 20000
    $lastFG = -1
    $lastBG = -1
    
    # Force full render on first frame or if requested
    $forceFullRender = $script:TuiState.RenderStats.FrameCount -eq 0
    
    try {
        # Build ANSI output with change detection
        for ($y = 0; $y -lt $script:TuiState.BufferHeight; $y++) {
            # Position cursor at start of line
            $outputBuilder.Append("$([char]27)[$($y + 1);1H") | Out-Null
            
            for ($x = 0; $x -lt $script:TuiState.BufferWidth; $x++) {
                $backCell = $script:TuiState.BackBuffer[$y, $x]
                $frontCell = $script:TuiState.FrontBuffer[$y, $x]
                
                # Skip if cell hasn't changed (unless forcing full render)
                if (-not $forceFullRender -and
                    $backCell.Char -eq $frontCell.Char -and 
                    $backCell.FG -eq $frontCell.FG -and 
                    $backCell.BG -eq $frontCell.BG) {
                    continue
                }
                
                # Position cursor if we skipped cells
                if ($x -gt 0 -and $outputBuilder.Length -gt 0) {
                    $outputBuilder.Append("$([char]27)[$($y + 1);$($x + 1)H") | Out-Null
                }
                
                # Update colors if changed
                if ($backCell.FG -ne $lastFG -or $backCell.BG -ne $lastBG) {
                    $fgCode = Get-AnsiColorCode $backCell.FG
                    $bgCode = Get-AnsiColorCode $backCell.BG -IsBackground $true
                    $outputBuilder.Append("$([char]27)[${fgCode};${bgCode}m") | Out-Null
                    $lastFG = $backCell.FG
                    $lastBG = $backCell.BG
                }
                
                # Append character
                $outputBuilder.Append($backCell.Char) | Out-Null
                
                # Update front buffer
                $script:TuiState.FrontBuffer[$y, $x] = @{
                    Char = $backCell.Char
                    FG = $backCell.FG
                    BG = $backCell.BG
                }
            }
        }
        
        # Reset ANSI formatting at the end
        $outputBuilder.Append("$([char]27)[0m") | Out-Null
        
        # Write to console
        if ($outputBuilder.Length -gt 0) {
            [Console]::Write($outputBuilder.ToString())
        }
        
    } catch {
        Write-Warning "Render error: $_"
    }
    
    # Update stats
    $stopwatch.Stop()
    $script:TuiState.RenderStats.LastFrameTime = $stopwatch.ElapsedMilliseconds
    $script:TuiState.RenderStats.FrameCount++
    $script:TuiState.RenderStats.TotalTime += $stopwatch.ElapsedMilliseconds
}

#endregion

#region Component System

function Initialize-ComponentSystem {
    $script:TuiState.Components = @()
    $script:TuiState.FocusedComponent = $null
}

function global:Register-Component {
    param([hashtable]$Component)
    
    # Add to component registry
    $script:TuiState.Components += $Component
    
    # Initialize component with error handling
    if ($Component.Init) {
        try {
            & $Component.Init -self $Component
        } catch {
            Write-Warning "Component init error: $_"
        }
    }
    
    return $Component
}

function global:Set-ComponentFocus {
    param([hashtable]$Component)
    
    # Don't focus disabled components
    if ($Component -and ($Component.IsEnabled -eq $false -or $Component.Disabled -eq $true)) {
        return
    }
    
    # Blur previous component with error handling
    if ($script:TuiState.FocusedComponent -and $script:TuiState.FocusedComponent.OnBlur) {
        try {
            & $script:TuiState.FocusedComponent.OnBlur -self $script:TuiState.FocusedComponent
        } catch {
            Write-Warning "Component blur error: $_"
        }
    }
    
    # Track focus on current screen
    if ($script:TuiState.CurrentScreen) {
        $script:TuiState.CurrentScreen.LastFocusedComponent = $Component
    }
    
    # Focus new component with error handling
    $script:TuiState.FocusedComponent = $Component
    if ($Component -and $Component.OnFocus) {
        try {
            & $Component.OnFocus -self $Component
        } catch {
            Write-Warning "Component focus error: $_"
        }
    }
    
    Request-TuiRefresh
}

function global:Clear-ComponentFocus {
    <#
    .SYNOPSIS
    Clears focus from the current component
    #>
    if ($script:TuiState.FocusedComponent -and $script:TuiState.FocusedComponent.OnBlur) {
        try {
            & $script:TuiState.FocusedComponent.OnBlur -self $script:TuiState.FocusedComponent
        } catch {
            Write-Warning "Component blur error: $_"
        }
    }
    
    $script:TuiState.FocusedComponent = $null
    
    # Clear tracked focus on current screen
    if ($script:TuiState.CurrentScreen) {
        $script:TuiState.CurrentScreen.LastFocusedComponent = $null
    }
    
    Request-TuiRefresh
}

function global:Get-NextFocusableComponent {
    <#
    .SYNOPSIS
    Gets the next focusable component in tab order
    #>
    param(
        [hashtable]$CurrentComponent,
        [bool]$Reverse = $false
    )
    
    if (-not $script:TuiState.CurrentScreen) { return $null }
    
    # Get all focusable components
    $focusableComponents = @()
    
    # Recursive function to find focusable components
    function Find-FocusableComponents {
        param($Component)
        
        # Check using the correct properties that our components actually have
        if ($Component.IsFocusable -eq $true -and 
            $Component.Visible -ne $false) {
            $focusableComponents += $Component
        }
        
        if ($Component.Children) {
            foreach ($child in $Component.Children) {
                Find-FocusableComponents -Component $child
            }
        }
    }
    
    # Start from screen components
    if ($script:TuiState.CurrentScreen.Components) {
        if ($script:TuiState.CurrentScreen.Components -is [hashtable]) {
            foreach ($comp in $script:TuiState.CurrentScreen.Components.Values) {
                Find-FocusableComponents -Component $comp
            }
        } elseif ($script:TuiState.CurrentScreen.Components -is [array]) {
            foreach ($comp in $script:TuiState.CurrentScreen.Components) {
                Find-FocusableComponents -Component $comp
            }
        }
    }
    
    if ($focusableComponents.Count -eq 0) { return $null }
    
    # Sort by TabIndex or position
    $sorted = $focusableComponents | Sort-Object {
        if ($null -ne $_.TabIndex) { $_.TabIndex }
        else { $_.Y * 1000 + $_.X }
    }
    
    if ($Reverse) {
        [Array]::Reverse($sorted)
    }
    
    # Find current index
    $currentIndex = -1
    for ($i = 0; $i -lt $sorted.Count; $i++) {
        if ($sorted[$i] -eq $CurrentComponent) {
            $currentIndex = $i
            break
        }
    }
    
    # Get next component
    if ($currentIndex -ge 0) {
        $nextIndex = ($currentIndex + 1) % $sorted.Count
        return $sorted[$nextIndex]
    } else {
        return $sorted[0]
    }
}

function global:Handle-TabNavigation {
    <#
    .SYNOPSIS
    Handles Tab key navigation between components  
    #>
    param([bool]$Reverse = $false)
    
    if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
        Write-Log -Level Debug -Message "Handle-TabNavigation called, Reverse=$Reverse"
    }
    
    $next = Get-NextFocusableComponent -CurrentComponent $script:TuiState.FocusedComponent -Reverse $Reverse
    if ($next) {
        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            Write-Log -Level Debug -Message "Setting focus to component: Type=$($next.Type), Name=$($next.Name)"
        }
        Set-ComponentFocus -Component $next
    }
}

function global:New-Component {
    param(
        [string]$Type = "Base",
        [int]$X = 0,
        [int]$Y = 0,
        [int]$Width = 10,
        [int]$Height = 1,
        [hashtable]$Props = @{}
    )
    
    $component = @{
        Type = $Type
        X = $X
        Y = $Y
        Width = $Width
        Height = $Height
        Visible = $true
        Focused = $false
        Parent = $null
        Children = @()
        Props = $Props
        State = @{}
        
        # Lifecycle methods
        Init = { param($self) }
        Render = { param($self) }
        HandleInput = { param($self, $Key) return $false }
        OnFocus = { param($self) $self.Focused = $true }
        OnBlur = { param($self) $self.Focused = $false }
        Dispose = { param($self) }
    }
    
    # Merge with type-specific properties
    switch ($Type) {
        "TextInput" { $component = Merge-Hashtables $component (Get-TextInputComponent) }
        "Button" { $component = Merge-Hashtables $component (Get-ButtonComponent) }
        "List" { $component = Merge-Hashtables $component (Get-ListComponent) }
        "Table" { $component = Merge-Hashtables $component (Get-TableComponent) }
    }
    
    return $component
}

function Merge-Hashtables {
    param($Base, $Override)
    $result = $Base.Clone()
    foreach ($key in $Override.Keys) {
        $result[$key] = $Override[$key]
    }
    return $result
}

#endregion

#region Layout Management

function Initialize-LayoutEngines {
    $script:TuiState.Layouts = @{
        Grid = Get-GridLayout
        Stack = Get-StackLayout
        Dock = Get-DockLayout
    }
}

function global:Apply-Layout {
    param(
        [string]$LayoutType,
        [hashtable[]]$Components,
        [hashtable]$Options = @{}
    )
    
    if ($script:TuiState.Layouts.ContainsKey($LayoutType)) {
        $layout = $script:TuiState.Layouts[$LayoutType]
        try {
            & $layout.Apply -Components $Components -Options $Options
        } catch {
            Write-Warning "Layout error: $_"
        }
    }
}

function Get-GridLayout {
    return @{
        Apply = {
            param($Components, $Options)
            $cols = if ($Options.Columns) { $Options.Columns } else { 2 }
            $rows = [Math]::Ceiling($Components.Count / $cols)
            $cellWidth = [Math]::Floor($script:TuiState.BufferWidth / $cols)
            $cellHeight = [Math]::Floor($script:TuiState.BufferHeight / $rows)
            
            for ($i = 0; $i -lt $Components.Count; $i++) {
                $col = $i % $cols
                $row = [Math]::Floor($i / $cols)
                $Components[$i].X = $col * $cellWidth
                $Components[$i].Y = $row * $cellHeight
                $Components[$i].Width = $cellWidth - 1
                $Components[$i].Height = $cellHeight - 1
            }
        }
    }
}

function Get-StackLayout {
    return @{
        Apply = {
            param($Components, $Options)
            $orientation = if ($Options.Orientation) { $Options.Orientation } else { "Vertical" }
            $spacing = if ($null -ne $Options.Spacing) { $Options.Spacing } else { 1 }
            $x = if ($null -ne $Options.X) { $Options.X } else { 0 }
            $y = if ($null -ne $Options.Y) { $Options.Y } else { 0 }
            
            foreach ($component in $Components) {
                $component.X = $x
                $component.Y = $y
                
                if ($orientation -eq "Vertical") {
                    $y += $component.Height + $spacing
                } else {
                    $x += $component.Width + $spacing
                }
            }
        }
    }
}

function Get-DockLayout {
    return @{
        Apply = {
            param($Components, $Options)
            
            # Container bounds
            $containerX = if ($null -ne $Options.X) { $Options.X } else { 0 }
            $containerY = if ($null -ne $Options.Y) { $Options.Y } else { 0 }
            $containerWidth = if ($Options.Width) { $Options.Width } else { $script:TuiState.BufferWidth }
            $containerHeight = if ($Options.Height) { $Options.Height } else { $script:TuiState.BufferHeight }
            
            # Current available area
            $availableX = $containerX
            $availableY = $containerY
            $availableWidth = $containerWidth
            $availableHeight = $containerHeight
            
            # Process components by dock position
            $topComponents = $Components | Where-Object { $_.Props.Dock -eq "Top" }
            $bottomComponents = $Components | Where-Object { $_.Props.Dock -eq "Bottom" }
            $leftComponents = $Components | Where-Object { $_.Props.Dock -eq "Left" }
            $rightComponents = $Components | Where-Object { $_.Props.Dock -eq "Right" }
            $fillComponents = $Components | Where-Object { $_.Props.Dock -eq "Fill" -or -not $_.Props.Dock }
            
            # Dock top components
            foreach ($comp in $topComponents) {
                $comp.X = $availableX
                $comp.Y = $availableY
                $comp.Width = $availableWidth
                $availableY += $comp.Height
                $availableHeight -= $comp.Height
            }
            
            # Dock bottom components
            foreach ($comp in $bottomComponents) {
                $comp.X = $availableX
                $comp.Y = $availableY + $availableHeight - $comp.Height
                $comp.Width = $availableWidth
                $availableHeight -= $comp.Height
            }
            
            # Dock left components
            foreach ($comp in $leftComponents) {
                $comp.X = $availableX
                $comp.Y = $availableY
                $comp.Height = $availableHeight
                $availableX += $comp.Width
                $availableWidth -= $comp.Width
            }
            
            # Dock right components
            foreach ($comp in $rightComponents) {
                $comp.X = $availableX + $availableWidth - $comp.Width
                $comp.Y = $availableY
                $comp.Height = $availableHeight
                $availableWidth -= $comp.Width
            }
            
            # Fill remaining space
            foreach ($comp in $fillComponents) {
                $comp.X = $availableX
                $comp.Y = $availableY
                $comp.Width = $availableWidth
                $comp.Height = $availableHeight
            }
        }
    }
}

#endregion

#region Utility Functions

function global:Get-BorderChars { 
    param([string]$Style) 
    $styles = @{ 
        Single = @{ 
            TopLeft='┌'; TopRight='┐'; BottomLeft='└'; BottomRight='┘'
            Horizontal='─'; Vertical='│' 
        }
        Double = @{ 
            TopLeft='╔'; TopRight='╗'; BottomLeft='╚'; BottomRight='╝'
            Horizontal='═'; Vertical='║' 
        }
        Rounded = @{ 
            TopLeft='╭'; TopRight='╮'; BottomLeft='╰'; BottomRight='╯'
            Horizontal='─'; Vertical='│' 
        } 
    }
    if ($styles.ContainsKey($Style)) { 
        return $styles[$Style] 
    } else { 
        return $styles.Single 
    }
}

function Get-AnsiColorCode { 
    param([ConsoleColor]$Color, [bool]$IsBackground) 
    $map = @{ 
        Black=30; DarkBlue=34; DarkGreen=32; DarkCyan=36
        DarkRed=31; DarkMagenta=35; DarkYellow=33; Gray=37
        DarkGray=90; Blue=94; Green=92; Cyan=96
        Red=91; Magenta=95; Yellow=93; White=97 
    }
    $code = $map[$Color.ToString()]
    if ($IsBackground) { 
        return $code + 10 
    } else { 
        return $code 
    } 
}

function Get-ThemeColorFallback {
    param($ColorName, $Default = [ConsoleColor]::White)
    # This is a fallback function for when theme manager isn't available
    # The theme manager will override this with its own global Get-ThemeColor
    return $Default
}

# Only define global Get-ThemeColor if it doesn't already exist
if (-not (Get-Command -Name "Get-ThemeColor" -ErrorAction SilentlyContinue)) {
    function global:Get-ThemeColor {
        param($ColorName, $Default = [ConsoleColor]::White)
        return Get-ThemeColorFallback -ColorName $ColorName -Default $Default
    }
}

function global:Write-StatusLine { 
    param(
        [string]$Text, 
        [ConsoleColor]$ForegroundColor = 'White', 
        [ConsoleColor]$BackgroundColor = 'DarkBlue'
    ) 
    try { 
        $y = $script:TuiState.BufferHeight
        [Console]::SetCursorPosition(0, $y)
        [Console]::ForegroundColor = $ForegroundColor
        [Console]::BackgroundColor = $BackgroundColor
        [Console]::Write($Text.PadRight([Console]::WindowWidth))
        [Console]::ResetColor() 
    } catch {
        Write-Warning "Status line error: $_"
    } 
}

function global:Subscribe-TuiEvent {
    param($EventName, $Handler)
    if (Get-Command -Name "Subscribe-Event" -ErrorAction SilentlyContinue) {
        $handlerId = Subscribe-Event -EventName $EventName -Handler $Handler
        # Track for cleanup
        $script:TuiState.EventHandlers[$EventName] = $handlerId
        return $handlerId
    }
}

#endregion

#region Component Definitions

function Get-TextInputComponent {
    return @{
        # State
        Value = ""
        CursorPosition = 0
        MaxLength = 50
        
        # Methods
        Render = {
            param($self)
            try {
                $borderColor = if ($self.Focused) { 
                    Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
                } else { 
                    Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
                }
                
                # Draw input box
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor -BackgroundColor ([ConsoleColor]::Black)
                
                # Draw focus indicator
                if ($self.Focused) {
                    # Left bracket
                    Write-BufferString -X ($self.X - 1) -Y ($self.Y + [Math]::Floor($self.Height / 2)) `
                        -Text "[" -ForegroundColor ([ConsoleColor]::Yellow)
                    # Right bracket
                    Write-BufferString -X ($self.X + $self.Width) -Y ($self.Y + [Math]::Floor($self.Height / 2)) `
                        -Text "]" -ForegroundColor ([ConsoleColor]::Yellow)
                }
                
                # Draw text
                $displayText = $self.Value
                if ($displayText.Length > ($self.Width - 3)) {
                    $displayText = $displayText.Substring($displayText.Length - ($self.Width - 3))
                }
                Write-BufferString -X ($self.X + 1) -Y ($self.Y + 1) -Text $displayText
                
                # Draw cursor if focused
                if ($self.Focused -and $self.CursorPosition -lt ($self.Width - 3)) {
                    Write-BufferString -X ($self.X + 1 + $self.CursorPosition) -Y ($self.Y + 1) `
                        -Text "_" -ForegroundColor ([ConsoleColor]::Yellow)
                }
            } catch {
                Write-Warning "TextInput render error: $_"
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                switch ($Key.Key) {
                    ([ConsoleKey]::Backspace) {
                        if ($self.Value.Length -gt 0 -and $self.CursorPosition -gt 0) {
                            $self.Value = $self.Value.Remove($self.CursorPosition - 1, 1)
                            $self.CursorPosition--
                        }
                        return $true
                    }
                    ([ConsoleKey]::Delete) {
                        if ($self.CursorPosition -lt $self.Value.Length) {
                            $self.Value = $self.Value.Remove($self.CursorPosition, 1)
                        }
                        return $true
                    }
                    ([ConsoleKey]::LeftArrow) {
                        if ($self.CursorPosition -gt 0) {
                            $self.CursorPosition--
                        }
                        return $true
                    }
                    ([ConsoleKey]::RightArrow) {
                        if ($self.CursorPosition -lt $self.Value.Length) {
                            $self.CursorPosition++
                        }
                        return $true
                    }
                    ([ConsoleKey]::Home) {
                        $self.CursorPosition = 0
                        return $true
                    }
                    ([ConsoleKey]::End) {
                        $self.CursorPosition = $self.Value.Length
                        return $true
                    }
                    default {
                        if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar) -and 
                            $self.Value.Length -lt $self.MaxLength) {
                            $self.Value = $self.Value.Insert($self.CursorPosition, $Key.KeyChar)
                            $self.CursorPosition++
                            return $true
                        }
                    }
                }
            } catch {
                Write-Warning "TextInput input error: $_"
            }
            return $false
        }
    }
}

function Get-ButtonComponent {
    return @{
        # State
        Text = "Button"
        
        # Methods
        Render = {
            param($self)
            try {
                $bgColor = if ($self.Focused) { 
                    Get-ThemeColor "Accent" -Default ([ConsoleColor]::DarkCyan)
                } else { 
                    Get-ThemeColor "Primary" -Default ([ConsoleColor]::DarkGray)
                }
                
                $text = " $($self.Text) "
                if ($text.Length > $self.Width) {
                    $text = $text.Substring(0, $self.Width)
                }
                
                $x = $self.X + [Math]::Floor(($self.Width - $text.Length) / 2)
                Write-BufferString -X $x -Y $self.Y -Text $text `
                    -ForegroundColor ([ConsoleColor]::White) -BackgroundColor $bgColor
                
                # Draw focus indicator
                if ($self.Focused) {
                    # Left bracket
                    if ($x -gt 0) {
                        Write-BufferString -X ($x - 1) -Y $self.Y `
                            -Text "[" -ForegroundColor ([ConsoleColor]::Yellow)
                    }
                    # Right bracket
                    if (($x + $text.Length) -lt $script:TuiState.BufferWidth) {
                        Write-BufferString -X ($x + $text.Length) -Y $self.Y `
                            -Text "]" -ForegroundColor ([ConsoleColor]::Yellow)
                    }
                }
            } catch {
                Write-Warning "Button render error: $_"
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                if ($Key.Key -eq [ConsoleKey]::Enter -or $Key.Key -eq [ConsoleKey]::Spacebar) {
                    if ($self.OnClick) {
                        & $self.OnClick -self $self
                    }
                    return $true
                }
            } catch {
                Write-Warning "Button input error: $_"
            }
            return $false
        }
    }
}

function Get-TableComponent {
    return @{
        # State
        Data = @()
        Columns = @()
        SelectedRow = 0
        ScrollOffset = 0
        
        # Methods
        Render = {
            param($self)
            try {
                # Simplified table rendering
                $y = $self.Y
                
                # Header
                $headerText = ""
                foreach ($col in $self.Columns) {
                    $headerText += $col.Name.PadRight($col.Width)
                }
                Write-BufferString -X $self.X -Y $y -Text $headerText `
                    -ForegroundColor (Get-ThemeColor "Header" -Default ([ConsoleColor]::Cyan))
                $y++
                
                # Data rows
                $visibleRows = $self.Data | Select-Object -Skip $self.ScrollOffset -First ($self.Height - 1)
                $rowIndex = $self.ScrollOffset
                foreach ($row in $visibleRows) {
                    $rowText = ""
                    foreach ($col in $self.Columns) {
                        $value = if ($row.($col.Property)) { $row.($col.Property) } else { "" }
                        $rowText += $value.ToString().PadRight($col.Width)
                    }
                    
                    $fg = if ($rowIndex -eq $self.SelectedRow) {
                        Get-ThemeColor "Selection" -Default ([ConsoleColor]::Yellow)
                    } else {
                        Get-ThemeColor "Primary" -Default ([ConsoleColor]::White)
                    }
                    
                    Write-BufferString -X $self.X -Y $y -Text $rowText -ForegroundColor $fg
                    $y++
                    $rowIndex++
                }
            } catch {
                Write-Warning "Table render error: $_"
            }
        }
    }
}

#endregion

#region Word Wrap Helper
function global:Get-WordWrappedLines {
    param(
        [string]$Text,
        [int]$MaxWidth
    )
    
    if ([string]::IsNullOrEmpty($Text) -or $MaxWidth -le 0) { return @() }
    
    $lines = @()
    $words = $Text -split '\s+'
    $sb = New-Object System.Text.StringBuilder
    
    foreach ($word in $words) {
        if ($sb.Length -eq 0) {
            [void]$sb.Append($word)
        } elseif (($sb.Length + 1 + $word.Length) -le $MaxWidth) {
            [void]$sb.Append(' ')
            [void]$sb.Append($word)
        } else {
            $lines += $sb.ToString()
            [void]$sb.Clear()
            [void]$sb.Append($word)
        }
    }
    
    if ($sb.Length -gt 0) {
        $lines += $sb.ToString()
    }
    
    return $lines
}
#endregion

# Build export list dynamically
$exportFunctions = @(
    'Start-TuiLoop', 'Request-TuiRefresh', 'Push-Screen', 'Pop-Screen',
    'Write-BufferString', 'Write-BufferBox', 'Clear-BackBuffer',
    'Write-StatusLine', 'Get-BorderChars',
    'Register-Component', 'Set-ComponentFocus', 'Clear-ComponentFocus', 
    'Get-NextFocusableComponent', 'Handle-TabNavigation', 
    'New-Component', 'Apply-Layout',
    'Get-WordWrappedLines', 'Subscribe-TuiEvent'
)

# Only export Get-ThemeColor if we defined it
if (Get-Command -Name "Get-ThemeColor" -ErrorAction SilentlyContinue | Where-Object { $_.Source -eq "tui-engine-v2" }) {
    $exportFunctions += 'Get-ThemeColor'
}

Export-ModuleMember -Function $exportFunctions -Variable @('TuiState')
# Theme Manager Module
# Provides theming and color management for the TUI

$script:CurrentTheme = $null
$script:Themes = @{
    Modern = @{
        Name = "Modern"
        Colors = @{
            # Base colors
            Background = [ConsoleColor]::Black
            Foreground = [ConsoleColor]::White
            
            # UI elements
            Primary = [ConsoleColor]::White
            Secondary = [ConsoleColor]::Gray
            Accent = [ConsoleColor]::Cyan
            Success = [ConsoleColor]::Green
            Warning = [ConsoleColor]::Yellow
            Error = [ConsoleColor]::Red
            Info = [ConsoleColor]::Blue
            
            # Special elements
            Header = [ConsoleColor]::Cyan
            Border = [ConsoleColor]::DarkGray
            Selection = [ConsoleColor]::Yellow
            Highlight = [ConsoleColor]::Cyan
            Subtle = [ConsoleColor]::DarkGray
            
            # Syntax highlighting
            Keyword = [ConsoleColor]::Blue
            String = [ConsoleColor]::Green
            Number = [ConsoleColor]::Magenta
            Comment = [ConsoleColor]::DarkGray
        }
    }
    
    Dark = @{
        Name = "Dark"
        Colors = @{
            Background = [ConsoleColor]::Black
            Foreground = [ConsoleColor]::Gray
            Primary = [ConsoleColor]::Gray
            Secondary = [ConsoleColor]::DarkGray
            Accent = [ConsoleColor]::DarkCyan
            Success = [ConsoleColor]::DarkGreen
            Warning = [ConsoleColor]::DarkYellow
            Error = [ConsoleColor]::DarkRed
            Info = [ConsoleColor]::DarkBlue
            Header = [ConsoleColor]::DarkCyan
            Border = [ConsoleColor]::DarkGray
            Selection = [ConsoleColor]::Yellow
            Highlight = [ConsoleColor]::Cyan
            Subtle = [ConsoleColor]::DarkGray
            Keyword = [ConsoleColor]::DarkBlue
            String = [ConsoleColor]::DarkGreen
            Number = [ConsoleColor]::DarkMagenta
            Comment = [ConsoleColor]::DarkGray
        }
    }
    
    Light = @{
        Name = "Light"
        Colors = @{
            Background = [ConsoleColor]::White
            Foreground = [ConsoleColor]::Black
            Primary = [ConsoleColor]::Black
            Secondary = [ConsoleColor]::DarkGray
            Accent = [ConsoleColor]::Blue
            Success = [ConsoleColor]::Green
            Warning = [ConsoleColor]::DarkYellow
            Error = [ConsoleColor]::Red
            Info = [ConsoleColor]::Blue
            Header = [ConsoleColor]::Blue
            Border = [ConsoleColor]::Gray
            Selection = [ConsoleColor]::Cyan
            Highlight = [ConsoleColor]::Yellow
            Subtle = [ConsoleColor]::Gray
            Keyword = [ConsoleColor]::Blue
            String = [ConsoleColor]::Green
            Number = [ConsoleColor]::Magenta
            Comment = [ConsoleColor]::Gray
        }
    }
    
    Retro = @{
        Name = "Retro"
        Colors = @{
            Background = [ConsoleColor]::Black
            Foreground = [ConsoleColor]::Green
            Primary = [ConsoleColor]::Green
            Secondary = [ConsoleColor]::DarkGreen
            Accent = [ConsoleColor]::Yellow
            Success = [ConsoleColor]::Green
            Warning = [ConsoleColor]::Yellow
            Error = [ConsoleColor]::Red
            Info = [ConsoleColor]::Cyan
            Header = [ConsoleColor]::Yellow
            Border = [ConsoleColor]::DarkGreen
            Selection = [ConsoleColor]::Yellow
            Highlight = [ConsoleColor]::White
            Subtle = [ConsoleColor]::DarkGreen
            Keyword = [ConsoleColor]::Yellow
            String = [ConsoleColor]::Cyan
            Number = [ConsoleColor]::White
            Comment = [ConsoleColor]::DarkGreen
        }
    }
}

function global:Initialize-ThemeManager {
    <#
    .SYNOPSIS
    Initializes the theme manager
    #>
    
    # Set default theme
    Set-TuiTheme -ThemeName "Modern"
    
    Write-Verbose "Theme manager initialized"
}

function global:Set-TuiTheme {
    <#
    .SYNOPSIS
    Sets the current theme
    
    .PARAMETER ThemeName
    The name of the theme to set
    #>
    param(
        [Parameter(Mandatory = $true)]
        [ValidateSet("Modern", "Dark", "Light", "Retro")]
        [string]$ThemeName
    )
    
    if ($script:Themes.ContainsKey($ThemeName)) {
        $script:CurrentTheme = $script:Themes[$ThemeName]
        
        # --- FIX ---
        # Defensively check if RawUI exists. In some environments (like the VS Code
        # Integrated Console), it can be $null and cause a crash.
        if ($Host.UI.RawUI) {
            # Apply console colors
            $Host.UI.RawUI.BackgroundColor = $script:CurrentTheme.Colors.Background
            $Host.UI.RawUI.ForegroundColor = $script:CurrentTheme.Colors.Foreground
        }
        
        Write-Verbose "Theme set to: $ThemeName"
        
        # Publish theme change event
        # Check if Publish-Event exists before calling it
        if (Get-Command -Name Publish-Event -ErrorAction SilentlyContinue) {
            Publish-Event -EventName "Theme.Changed" -Data @{ 
                ThemeName = $ThemeName
                Theme = $script:CurrentTheme 
            }
        }
    } else {
        Write-Warning "Theme not found: $ThemeName"
    }
}

function global:Get-ThemeColor {
    <#
    .SYNOPSIS
    Gets a color from the current theme
    
    .PARAMETER ColorName
    The name of the color to get
    
    .PARAMETER Default
    Default color if not found
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$ColorName,
        
        [Parameter()]
        [ConsoleColor]$Default = [ConsoleColor]::Gray
    )
    
    if ($script:CurrentTheme -and $script:CurrentTheme.Colors.ContainsKey($ColorName)) {
        return $script:CurrentTheme.Colors[$ColorName]
    } else {
        return $Default
    }
}

function global:Get-TuiTheme {
    <#
    .SYNOPSIS
    Gets the current theme
    #>
    
    return $script:CurrentTheme
}

function global:Get-AvailableThemes {
    <#
    .SYNOPSIS
    Gets all available themes
    #>
    
    return $script:Themes.Keys | Sort-Object
}

function global:New-TuiTheme {
    <#
    .SYNOPSIS
    Creates a new theme
    
    .PARAMETER Name
    The name of the new theme
    
    .PARAMETER BaseTheme
    The name of the theme to base this on
    
    .PARAMETER Colors
    Hashtable of color overrides
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$Name,
        
        [Parameter()]
        [string]$BaseTheme = "Modern",
        
        [Parameter()]
        [hashtable]$Colors = @{}
    )
    
    # Clone base theme
    $newTheme = @{
        Name = $Name
        Colors = @{}
    }
    
    if ($script:Themes.ContainsKey($BaseTheme)) {
        foreach ($colorKey in $script:Themes[$BaseTheme].Colors.Keys) {
            $newTheme.Colors[$colorKey] = $script:Themes[$BaseTheme].Colors[$colorKey]
        }
    }
    
    # Apply overrides
    foreach ($colorKey in $Colors.Keys) {
        $newTheme.Colors[$colorKey] = $Colors[$colorKey]
    }
    
    # Save theme
    $script:Themes[$Name] = $newTheme
    
    Write-Verbose "Created new theme: $Name"
    
    return $newTheme
}

function global:Export-TuiTheme {
    <#
    .SYNOPSIS
    Exports a theme to JSON
    
    .PARAMETER ThemeName
    The name of the theme to export
    
    .PARAMETER Path
    The path to save the theme
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$ThemeName,
        
        [Parameter(Mandatory = $true)]
        [string]$Path
    )
    
    if ($script:Themes.ContainsKey($ThemeName)) {
        $theme = $script:Themes[$ThemeName]
        
        # Convert ConsoleColor enums to strings for JSON
        $exportTheme = @{
            Name = $theme.Name
            Colors = @{}
        }
        
        foreach ($colorKey in $theme.Colors.Keys) {
            $exportTheme.Colors[$colorKey] = $theme.Colors[$colorKey].ToString()
        }
        
        $exportTheme | ConvertTo-Json -Depth 3 | Set-Content -Path $Path
        
        Write-Verbose "Exported theme to: $Path"
    } else {
        Write-Warning "Theme not found: $ThemeName"
    }
}

function global:Import-TuiTheme {
    <#
    .SYNOPSIS
    Imports a theme from JSON
    
    .PARAMETER Path
    The path to the theme file
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$Path
    )
    
    if (Test-Path $Path) {
        try {
            $importedTheme = Get-Content $Path -Raw | ConvertFrom-Json
            
            $theme = @{
                Name = $importedTheme.Name
                Colors = @{}
            }
            
            # Convert string color names back to ConsoleColor enums
            foreach ($colorProp in $importedTheme.Colors.PSObject.Properties) {
                $theme.Colors[$colorProp.Name] = [ConsoleColor]$colorProp.Value
            }
            
            $script:Themes[$theme.Name] = $theme
            
            Write-Verbose "Imported theme: $($theme.Name)"
            
            return $theme
        } catch {
            Write-Error "Failed to import theme: $_"
        }
    } else {
        Write-Warning "Theme file not found: $Path"
    }
}

# Export functions
Export-ModuleMember -Function @(
    'Initialize-ThemeManager',
    'Set-TuiTheme',
    'Get-ThemeColor',
    'Get-TuiTheme',
    'Get-AvailableThemes',
    'New-TuiTheme',
    'Export-TuiTheme',
    'Import-TuiTheme'
)
# Text Resources Module
# Simple text management without external dependencies

$script:TextResources = @{
    # Common UI strings
    Common = @{
        OK = "OK"
        Cancel = "Cancel"
        Save = "Save"
        Delete = "Delete"
        Edit = "Edit"
        Add = "Add"
        Remove = "Remove"
        Back = "Back"
        Next = "Next"
        Previous = "Previous"
        Close = "Close"
        Error = "Error"
        Warning = "Warning"
        Info = "Information"
        Success = "Success"
        Loading = "Loading..."
        PleaseWait = "Please wait..."
    }
    
    # Dashboard specific
    Dashboard = @{
        Title = "PMC Terminal Dashboard"
        QuickActions = "Quick Actions"
        ActiveTimers = "Active Timers"
        TodaysTasks = "Today's Tasks"
        Stats = "Statistics"
        NoTimersActive = "No active timers"
        NoTasksToday = "No tasks for today"
    }
    
    # Task screen specific
    Tasks = @{
        Title = "Task Management"
        AddTask = "Add Task"
        EditTask = "Edit Task"
        DeleteConfirm = "Are you sure you want to delete this task?"
        FilterAll = "All"
        FilterActive = "Active"
        FilterCompleted = "Completed"
        SortByPriority = "Priority"
        SortByDueDate = "Due Date"
        SortByCreated = "Created"
    }
    
    # Form labels
    Forms = @{
        Title = "Title"
        Description = "Description"
        Category = "Category"
        Priority = "Priority"
        DueDate = "Due Date"
        Status = "Status"
        Project = "Project"
        Hours = "Hours"
        Date = "Date"
    }
    
    # Validation messages
    Validation = @{
        Required = "{0} is required"
        MinLength = "{0} must be at least {1} characters"
        MaxLength = "{0} cannot exceed {1} characters"
        InvalidDate = "Invalid date format"
        InvalidNumber = "Must be a valid number"
    }
    
    # Status messages
    Status = @{
        Saved = "Changes saved successfully"
        Deleted = "Item deleted successfully"
        Updated = "Item updated successfully"
        Created = "Item created successfully"
        Error = "An error occurred: {0}"
    }
}

function global:Get-Text {
    <#
    .SYNOPSIS
    Retrieves a text resource by key path
    
    .PARAMETER Key
    Dot-separated path to the text resource (e.g., "Common.OK")
    
    .PARAMETER Format
    Optional format arguments for string interpolation
    
    .EXAMPLE
    Get-Text "Common.OK"
    Get-Text "Validation.Required" -Format "Username"
    Get-Text "Status.Error" -Format $_.Exception.Message
    #>
    param(
        [Parameter(Mandatory=$true)]
        [string]$Key,
        
        [Parameter(ValueFromRemainingArguments=$true)]
        [object[]]$Format
    )
    
    # Navigate the nested hashtable
    $parts = $Key -split '\.'
    $current = $script:TextResources
    
    foreach ($part in $parts) {
        if ($current -is [hashtable] -and $current.ContainsKey($part)) {
            $current = $current[$part]
        } else {
            Write-Warning "Text resource not found: '$Key'"
            return $Key  # Return the key as fallback
        }
    }
    
    # Format the string if arguments provided
    if ($Format -and $Format.Count -gt 0) {
        try {
            return $current -f $Format
        } catch {
            Write-Warning "Failed to format text resource '$Key': $_"
            return $current
        }
    }
    
    return $current
}

function global:Set-TextResource {
    <#
    .SYNOPSIS
    Sets or updates a text resource
    
    .PARAMETER Key
    Dot-separated path to the text resource
    
    .PARAMETER Value
    The text value to set
    
    .EXAMPLE
    Set-TextResource "Custom.WelcomeMessage" "Welcome to my app!"
    #>
    param(
        [Parameter(Mandatory=$true)]
        [string]$Key,
        
        [Parameter(Mandatory=$true)]
        [string]$Value
    )
    
    $parts = $Key -split '\.'
    $current = $script:TextResources
    
    # Navigate to the parent
    for ($i = 0; $i -lt $parts.Count - 1; $i++) {
        $part = $parts[$i]
        if (-not $current.ContainsKey($part)) {
            $current[$part] = @{}
        }
        $current = $current[$part]
    }
    
    # Set the value
    $current[$parts[-1]] = $Value
}

function global:Get-TextResources {
    <#
    .SYNOPSIS
    Gets all text resources (useful for export/import)
    #>
    return $script:TextResources.Clone()
}

function global:Import-TextResources {
    <#
    .SYNOPSIS
    Imports text resources from a file
    
    .PARAMETER Path
    Path to JSON file containing text resources
    #>
    param(
        [Parameter(Mandatory=$true)]
        [string]$Path
    )
    
    if (Test-Path $Path) {
        try {
            $imported = Get-Content $Path -Raw | ConvertFrom-Json -AsHashtable
            $script:TextResources = $imported
            Write-Host "Text resources imported successfully"
        } catch {
            Write-Error "Failed to import text resources: $_"
        }
    } else {
        Write-Error "File not found: $Path"
    }
}

function global:Export-TextResources {
    <#
    .SYNOPSIS
    Exports text resources to a file
    
    .PARAMETER Path
    Path to save the JSON file
    #>
    param(
        [Parameter(Mandatory=$true)]
        [string]$Path
    )
    
    try {
        $script:TextResources | ConvertTo-Json -Depth 10 | Set-Content $Path
        Write-Host "Text resources exported successfully"
    } catch {
        Write-Error "Failed to export text resources: $_"
    }
}

# Export functions
Export-ModuleMember -Function @(
    'Get-Text',
    'Set-TextResource',
    'Get-TextResources',
    'Import-TextResources',
    'Export-TextResources'
)
# State Manager Module
# Simple, practical reactive state management for PowerShell TUI

function global:New-TuiState {
    <#
    .SYNOPSIS
    Creates a reactive state object for managing application or screen state
    
    .DESCRIPTION
    This creates a PowerShell object that tracks state changes and notifies
    subscribers when values change. It's designed to be simple and practical.
    
    .PARAMETER InitialState
    Hashtable of initial state values
    
    .PARAMETER Actions
    Hashtable of named actions (methods) that can mutate the state
    
    .EXAMPLE
    $state = New-TuiState -InitialState @{ count = 0; name = "Test" } -Actions @{
        Increment = { $this.count++ }
        SetName = { param($name) $this.name = $name }
    }
    $state.Subscribe('count', { param($new, $old) Write-Host "Count changed from $old to $new" })
    $state.Increment()
    #>
    param(
        [hashtable]$InitialState = @{},
        [hashtable]$Actions = @{}
    )
    
    # Create the state object
    $stateObject = [PSCustomObject]@{
        # Private properties
        _data = $InitialState.Clone()
        _subscribers = @{}
        _suspendNotifications = $false
    }
    
    # Add dynamic properties for each state key
    foreach ($key in $InitialState.Keys) {
        $stateObject | Add-Member -MemberType ScriptProperty -Name $key -Value {
            # Getter
            $this._data[$key]
        }.GetNewClosure() -SecondValue {
            # Setter
            param($value)
            $this.SetValue($key, $value)
        }.GetNewClosure()
    }
    
    # Core methods
    $stateObject | Add-Member -MemberType ScriptMethod -Name 'SetValue' -Value {
        param([string]$key, $value)
        
        $oldValue = $this._data[$key]
        
        # Skip if value hasn't changed
        if ($oldValue -eq $value) { return }
        
        # Update the value
        $this._data[$key] = $value
        
        # Notify subscribers unless suspended
        if (-not $this._suspendNotifications) {
            $this._NotifySubscribers($key, $value, $oldValue)
        }
    }
    
    $stateObject | Add-Member -MemberType ScriptMethod -Name 'GetValue' -Value {
        param([string]$key)
        return $this._data[$key]
    }
    
    $stateObject | Add-Member -MemberType ScriptMethod -Name 'Subscribe' -Value {
        param(
            [string]$key,
            [scriptblock]$handler
        )
        
        if (-not $this._subscribers.ContainsKey($key)) {
            $this._subscribers[$key] = @()
        }
        
        # Generate unique ID for this subscription
        $subscriptionId = [Guid]::NewGuid().ToString()
        
        $this._subscribers[$key] += @{
            Id = $subscriptionId
            Handler = $handler
        }
        
        # Call handler immediately with current value
        try {
            & $handler $this._data[$key] $null
        } catch {
            Write-Warning "State subscription handler error: $_"
        }
        
        # Return subscription ID for unsubscribing
        return $subscriptionId
    }
    
    $stateObject | Add-Member -MemberType ScriptMethod -Name 'Unsubscribe' -Value {
        param([string]$subscriptionId)
        
        foreach ($key in $this._subscribers.Keys) {
            $this._subscribers[$key] = @($this._subscribers[$key] | Where-Object { $_.Id -ne $subscriptionId })
        }
    }
    
    $stateObject | Add-Member -MemberType ScriptMethod -Name 'Update' -Value {
        param([hashtable]$updates)
        
        # Suspend notifications during bulk update
        $this._suspendNotifications = $true
        
        try {
            foreach ($key in $updates.Keys) {
                $this.SetValue($key, $updates[$key])
            }
        } finally {
            $this._suspendNotifications = $false
        }
        
        # Notify all affected keys
        foreach ($key in $updates.Keys) {
            if ($this._data[$key] -ne $this._data[$key]) { # Check if changed
                $this._NotifySubscribers($key, $this._data[$key], $null)
            }
        }
    }
    
    $stateObject | Add-Member -MemberType ScriptMethod -Name 'GetState' -Value {
        # Return a copy of the current state
        return $this._data.Clone()
    }
    
    $stateObject | Add-Member -MemberType ScriptMethod -Name '_NotifySubscribers' -Value {
        param($key, $newValue, $oldValue)
        
        # Notify specific key subscribers
        if ($this._subscribers.ContainsKey($key)) {
            foreach ($subscription in $this._subscribers[$key]) {
                try {
                    & $subscription.Handler $newValue $oldValue
                } catch {
                    Write-Warning "State notification error for key '$key': $_"
                }
            }
        }
        
        # Notify wildcard subscribers
        if ($this._subscribers.ContainsKey('*')) {
            foreach ($subscription in $this._subscribers['*']) {
                try {
                    & $subscription.Handler @{
                        Key = $key
                        NewValue = $newValue
                        OldValue = $oldValue
                    }
                } catch {
                    Write-Warning "Wildcard state notification error: $_"
                }
            }
        }
    }
    
    # Add user-defined actions as methods
    foreach ($actionName in $Actions.Keys) {
        $stateObject | Add-Member -MemberType ScriptMethod -Name $actionName -Value $Actions[$actionName]
    }
    
    return $stateObject
}

function global:New-ComputedState {
    <#
    .SYNOPSIS
    Creates a computed/derived state value that updates automatically
    
    .PARAMETER Source
    The source state object to derive from
    
    .PARAMETER Keys
    Array of state keys to watch for changes
    
    .PARAMETER Compute
    Scriptblock that computes the derived value
    
    .EXAMPLE
    $filtered = New-ComputedState -Source $state -Keys @('tasks', 'filter') -Compute {
        param($state)
        $state.tasks | Where-Object { $_.Status -eq $state.filter }
    }
    #>
    param(
        [PSCustomObject]$Source,
        [string[]]$Keys,
        [scriptblock]$Compute
    )
    
    $computed = [PSCustomObject]@{
        _source = $Source
        _value = $null
        _compute = $Compute
        _subscriptions = @()
    }
    
    # Add Value property
    $computed | Add-Member -MemberType ScriptProperty -Name 'Value' -Value {
        $this._value
    }
    
    # Recompute method
    $computed | Add-Member -MemberType ScriptMethod -Name '_Recompute' -Value {
        try {
            $this._value = & $this._compute $this._source
        } catch {
            Write-Warning "Computed state error: $_"
        }
    }
    
    # Initial computation
    $computed._Recompute()
    
    # Subscribe to changes
    foreach ($key in $Keys) {
        $subId = $Source.Subscribe($key, {
            $computed._Recompute()
        })
        $computed._subscriptions += $subId
    }
    
    # Cleanup method
    $computed | Add-Member -MemberType ScriptMethod -Name 'Dispose' -Value {
        foreach ($subId in $this._subscriptions) {
            $this._source.Unsubscribe($subId)
        }
    }
    
    return $computed
}

# Export functions
Export-ModuleMember -Function @('New-TuiState', 'New-ComputedState')
# Simple Logger Module for PMC Terminal
# Provides basic logging functionality

$script:LogPath = $null
$script:LogLevel = "Info"
$script:LogQueue = @()
$script:MaxLogSize = 1MB
$script:LogInitialized = $false

function global:Initialize-Logger {
    param(
        [string]$LogDirectory = (Join-Path $env:TEMP "PMCTerminal"),
        [string]$LogFileName = "pmc_terminal_{0:yyyy-MM-dd}.log" -f (Get-Date),
        [string]$Level = "Info"
    )
    
    try {
        # Create log directory if it doesn't exist
        if (-not (Test-Path $LogDirectory)) {
            New-Item -ItemType Directory -Path $LogDirectory -Force | Out-Null
        }
        
        $script:LogPath = Join-Path $LogDirectory $LogFileName
        $script:LogLevel = $Level
        $script:LogInitialized = $true
        
        # Write initialization message
        Write-Log -Level Info -Message "Logger initialized at $($script:LogPath)"
        
    } catch {
        Write-Warning "Failed to initialize logger: $_"
        $script:LogInitialized = $false
    }
}

function global:Write-Log {
    param(
        [ValidateSet("Debug", "Verbose", "Info", "Warning", "Error")]
        [string]$Level = "Info",
        [Parameter(Mandatory)]
        [string]$Message,
        [object]$Data = $null
    )
    
    # Skip if logger not initialized or if level is below threshold
    if (-not $script:LogInitialized) { return }
    
    $levelPriority = @{
        Debug = 0
        Verbose = 1
        Info = 2
        Warning = 3
        Error = 4
    }
    
    if ($levelPriority[$Level] -lt $levelPriority[$script:LogLevel]) { return }
    
    try {
        $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss.fff"
        $logEntry = "$timestamp [$Level] $Message"
        
        if ($Data) {
            $dataStr = if ($Data -is [Exception]) {
                "`n  Exception: $($Data.Message)`n  StackTrace: $($Data.StackTrace)"
            } else {
                "`n  Data: $($Data | ConvertTo-Json -Compress -Depth 2)"
            }
            $logEntry += $dataStr
        }
        
        # Add to in-memory queue (for debug screen)
        $script:LogQueue += @{
            Timestamp = $timestamp
            Level = $Level
            Message = $Message
            Data = $Data
        }
        
        # Keep only last 1000 entries in memory
        if ($script:LogQueue.Count -gt 1000) {
            $script:LogQueue = $script:LogQueue[-1000..-1]
        }
        
        # Write to file
        if ($script:LogPath) {
            # Check file size and rotate if needed
            if ((Test-Path $script:LogPath) -and (Get-Item $script:LogPath).Length -gt $script:MaxLogSize) {
                $archivePath = $script:LogPath -replace '\.log$', "_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
                Move-Item $script:LogPath $archivePath -Force
            }
            
            Add-Content -Path $script:LogPath -Value $logEntry -Encoding UTF8
        }
        
    } catch {
        # Silently fail - we don't want logging errors to break the application
    }
}

function global:Get-LogEntries {
    param(
        [int]$Count = 100,
        [string]$Level = $null
    )
    
    $entries = $script:LogQueue
    
    if ($Level) {
        $entries = $entries | Where-Object { $_.Level -eq $Level }
    }
    
    return $entries | Select-Object -Last $Count
}

function global:Clear-LogQueue {
    $script:LogQueue = @()
}

function global:Set-LogLevel {
    param(
        [ValidateSet("Debug", "Verbose", "Info", "Warning", "Error")]
        [string]$Level
    )
    
    $script:LogLevel = $Level
    Write-Log -Level Info -Message "Log level changed to $Level"
}

function global:Get-LogPath {
    return $script:LogPath
}

Export-ModuleMember -Function @(
    'Initialize-Logger',
    'Write-Log',
    'Get-LogEntries',
    'Clear-LogQueue',
    'Set-LogLevel',
    'Get-LogPath'
)
# Event System Module
# Provides pub/sub event functionality for decoupled communication

$script:EventHandlers = @{}
$script:EventHistory = @()
$script:MaxEventHistory = 100

function global:Initialize-EventSystem {
    <#
    .SYNOPSIS
    Initializes the event system for the application
    #>
    $script:EventHandlers = @{}
    $script:EventHistory = @()
    Write-Verbose "Event system initialized"
}

function global:Publish-Event {
    <#
    .SYNOPSIS
    Publishes an event to all registered handlers
    
    .PARAMETER EventName
    The name of the event to publish
    
    .PARAMETER Data
    Optional data to pass to event handlers
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$EventName,
        
        [Parameter()]
        [hashtable]$Data = @{}
    )
    
    # Record event in history
    $eventRecord = @{
        EventName = $EventName
        Data = $Data
        Timestamp = Get-Date
    }
    
    $script:EventHistory += $eventRecord
    if ($script:EventHistory.Count -gt $script:MaxEventHistory) {
        $script:EventHistory = $script:EventHistory[-$script:MaxEventHistory..-1]
    }
    
    # Execute handlers
    if ($script:EventHandlers.ContainsKey($EventName)) {
        foreach ($handler in $script:EventHandlers[$EventName]) {
            try {
                $eventData = @{
                    EventName = $EventName
                    Data = $Data
                    Timestamp = $eventRecord.Timestamp
                }
                
                & $handler.ScriptBlock -EventData $eventData
            } catch {
                Write-Warning "Error in event handler for '$EventName': $_"
            }
        }
    }
    
    Write-Verbose "Published event: $EventName"
}

function global:Subscribe-Event {
    <#
    .SYNOPSIS
    Subscribes to an event with a handler
    
    .PARAMETER EventName
    The name of the event to subscribe to
    
    .PARAMETER Handler
    The script block to execute when the event is published
    
    .PARAMETER HandlerId
    Optional unique identifier for the handler
    
    .PARAMETER Source
    Optional source component ID for cleanup tracking
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$EventName,
        
        [Parameter(Mandatory = $true)]
        [scriptblock]$Handler,
        
        [Parameter()]
        [string]$HandlerId = [Guid]::NewGuid().ToString(),
        
        [Parameter()]
        [string]$Source = $null
    )
    
    if (-not $script:EventHandlers.ContainsKey($EventName)) {
        $script:EventHandlers[$EventName] = @()
    }
    
    $handlerInfo = @{
        HandlerId = $HandlerId
        ScriptBlock = $Handler
        SubscribedAt = Get-Date
        Source = $Source
    }
    
    $script:EventHandlers[$EventName] += $handlerInfo
    
    Write-Verbose "Subscribed to event: $EventName (Handler: $HandlerId)"
    
    # Only return handler ID, don't print it
    return $HandlerId
}

function global:Unsubscribe-Event {
    <#
    .SYNOPSIS
    Unsubscribes from an event
    
    .PARAMETER EventName
    The name of the event to unsubscribe from (optional if HandlerId is provided)
    
    .PARAMETER HandlerId
    The unique identifier of the handler to remove
    #>
    param(
        [Parameter()]
        [string]$EventName,
        
        [Parameter(Mandatory = $true)]
        [string]$HandlerId
    )
    
    if ($EventName) {
        # Fast path when event name is known
        if ($script:EventHandlers.ContainsKey($EventName)) {
            $script:EventHandlers[$EventName] = @($script:EventHandlers[$EventName] | Where-Object { $_.HandlerId -ne $HandlerId })
            
            if ($script:EventHandlers[$EventName].Count -eq 0) {
                $script:EventHandlers.Remove($EventName)
            }
            
            Write-Verbose "Unsubscribed from event: $EventName (Handler: $HandlerId)"
        }
    } else {
        # Search all events for the handler ID
        $found = $false
        foreach ($eventKey in @($script:EventHandlers.Keys)) {
            $handlers = $script:EventHandlers[$eventKey]
            $newHandlers = @($handlers | Where-Object { $_.HandlerId -ne $HandlerId })
            
            if ($newHandlers.Count -lt $handlers.Count) {
                $found = $true
                if ($newHandlers.Count -eq 0) {
                    $script:EventHandlers.Remove($eventKey)
                } else {
                    $script:EventHandlers[$eventKey] = $newHandlers
                }
                Write-Verbose "Unsubscribed from event: $eventKey (Handler: $HandlerId)"
                break
            }
        }
        
        if (-not $found) {
            Write-Warning "Handler ID not found: $HandlerId"
        }
    }
}

function global:Get-EventHandlers {
    <#
    .SYNOPSIS
    Gets all registered event handlers
    
    .PARAMETER EventName
    Optional event name to filter by
    #>
    param(
        [Parameter()]
        [string]$EventName
    )
    
    if ($EventName) {
        if ($script:EventHandlers.ContainsKey($EventName)) {
            return $script:EventHandlers[$EventName]
        } else {
            return @()
        }
    } else {
        return $script:EventHandlers
    }
}

function global:Clear-EventHandlers {
    <#
    .SYNOPSIS
    Clears all event handlers for a specific event or all events
    
    .PARAMETER EventName
    Optional event name to clear handlers for
    #>
    param(
        [Parameter()]
        [string]$EventName
    )
    
    if ($EventName) {
        if ($script:EventHandlers.ContainsKey($EventName)) {
            $script:EventHandlers.Remove($EventName)
            Write-Verbose "Cleared handlers for event: $EventName"
        }
    } else {
        $script:EventHandlers = @{}
        Write-Verbose "Cleared all event handlers"
    }
}

function global:Get-EventHistory {
    <#
    .SYNOPSIS
    Gets the event history
    
    .PARAMETER EventName
    Optional event name to filter by
    
    .PARAMETER Last
    Number of recent events to return
    #>
    param(
        [Parameter()]
        [string]$EventName,
        
        [Parameter()]
        [int]$Last = 0
    )
    
    $history = $script:EventHistory
    
    if ($EventName) {
        $history = $history | Where-Object { $_.EventName -eq $EventName }
    }
    
    if ($Last -gt 0) {
        $history = $history | Select-Object -Last $Last
    }
    
    return $history
}

function global:Remove-ComponentEventHandlers {
    <#
    .SYNOPSIS
    Removes all event handlers associated with a specific component
    
    .PARAMETER ComponentId
    The ID of the component whose handlers should be removed
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$ComponentId
    )
    
    $removedCount = 0
    
    # Iterate through all events and remove handlers with matching component ID
    foreach ($eventName in @($script:EventHandlers.Keys)) {
        $handlers = $script:EventHandlers[$eventName]
        $newHandlers = @()
        
        foreach ($handler in $handlers) {
            # Check if handler has Source property matching ComponentId
            if ($handler.Source -ne $ComponentId) {
                $newHandlers += $handler
            } else {
                $removedCount++
            }
        }
        
        if ($newHandlers.Count -eq 0) {
            $script:EventHandlers.Remove($eventName)
        } else {
            $script:EventHandlers[$eventName] = $newHandlers
        }
    }
    
    Write-Verbose "Removed $removedCount event handlers for component: $ComponentId"
}

# Export functions
Export-ModuleMember -Function @(
    'Initialize-EventSystem',
    'Publish-Event',
    'Subscribe-Event',
    'Unsubscribe-Event',
    'Get-EventHandlers',
    'Clear-EventHandlers',
    'Get-EventHistory',
    'Remove-ComponentEventHandlers'
)

# Dialog System Module - FIXED VERSION
# Uses engine's word wrap helper and respects the framework

$script:DialogState = @{
    CurrentDialog = $null
    DialogStack   = [System.Collections.Stack]::new()
}

#region --- Public API & Factory Functions ---

function global:Show-TuiDialog {
    <# .SYNOPSIS Internal function to display a dialog component. #>
    param([hashtable]$DialogComponent)
    
    if ($script:DialogState.CurrentDialog) {
        $script:DialogState.DialogStack.Push($script:DialogState.CurrentDialog)
    }
    $script:DialogState.CurrentDialog = $DialogComponent
    Request-TuiRefresh
}

function global:Close-TuiDialog {
    <# .SYNOPSIS Closes the current dialog and restores the previous one, if any. #>
    if ($script:DialogState.DialogStack.Count -gt 0) {
        $script:DialogState.CurrentDialog = $script:DialogState.DialogStack.Pop()
    } else {
        $script:DialogState.CurrentDialog = $null
    }
    Request-TuiRefresh
}

function global:Show-ConfirmDialog {
    <# .SYNOPSIS Displays a standard Yes/No confirmation dialog. #>
    param(
        [string]$Title = "Confirm",
        [string]$Message,
        [scriptblock]$OnConfirm,
        [scriptblock]$OnCancel = {}
    )
    
    $dialog = New-TuiDialog -Props @{
        Title         = $Title
        Message       = $Message
        Buttons       = @("Yes", "No")
        Width         = [Math]::Min(80, [Math]::Max(50, $Message.Length + 10))
        Height        = 10
        OnButtonClick = {
            param($Button, $Index)
            Close-TuiDialog
            if ($Index -eq 0) { & $OnConfirm } else { & $OnCancel }
        }
        OnCancel      = { Close-TuiDialog; & $OnCancel }
    }
    Show-TuiDialog -DialogComponent $dialog
}

function global:Show-AlertDialog {
    <# .SYNOPSIS Displays a simple alert with an OK button. #>
    param(
        [string]$Title = "Alert",
        [string]$Message
    )
    
    $dialog = New-TuiDialog -Props @{
        Title         = $Title
        Message       = $Message
        Buttons       = @("OK")
        Width         = [Math]::Min(80, [Math]::Max(40, $Message.Length + 10))
        Height        = 10
        OnButtonClick = { Close-TuiDialog }
        OnCancel      = { Close-TuiDialog }
    }
    Show-TuiDialog -DialogComponent $dialog
}

function global:Show-InputDialog {
    <# .SYNOPSIS Displays a dialog to get text input from the user. #>
    param(
        [string]$Title = "Input",
        [string]$Prompt,
        [string]$DefaultValue = "",
        [scriptblock]$OnSubmit,
        [scriptblock]$OnCancel = {}
    )

    # Create a screen that contains the input components
    $inputScreen = @{
        Name = "InputDialog"
        State = @{
            InputValue = $DefaultValue
            FocusedIndex = 0  # Start with textbox focused
        }
        _focusableNames = @("InputTextBox", "OKButton", "CancelButton")
        _focusedIndex = 0
        
        Render = {
            param($self)
            
            # Calculate dialog dimensions
            $dialogWidth = [Math]::Min(70, [Math]::Max(50, $Prompt.Length + 10))
            $dialogHeight = 10
            $dialogX = [Math]::Floor(($global:TuiState.BufferWidth - $dialogWidth) / 2)
            $dialogY = [Math]::Floor(($global:TuiState.BufferHeight - $dialogHeight) / 2)
            
            # Draw dialog box
            Write-BufferBox -X $dialogX -Y $dialogY -Width $dialogWidth -Height $dialogHeight `
                -Title " $Title " -BorderColor (Get-ThemeColor "Accent")
            
            # Draw prompt
            $promptX = $dialogX + 2
            $promptY = $dialogY + 2
            Write-BufferString -X $promptX -Y $promptY -Text $Prompt
            
            # Draw text input
            $inputY = $promptY + 2
            $inputWidth = $dialogWidth - 4
            $isFocused = ($self._focusedIndex -eq 0)
            $borderColor = if ($isFocused) { Get-ThemeColor "Warning" } else { Get-ThemeColor "Primary" }
            
            Write-BufferBox -X $promptX -Y $inputY -Width $inputWidth -Height 3 `
                -BorderColor $borderColor
            
            # Draw input value
            $displayText = $self.State.InputValue
            if ($displayText.Length > ($inputWidth - 3)) {
                $displayText = $displayText.Substring($displayText.Length - ($inputWidth - 3))
            }
            Write-BufferString -X ($promptX + 1) -Y ($inputY + 1) -Text $displayText
            
            # Draw cursor if textbox is focused
            if ($isFocused) {
                $cursorPos = [Math]::Min($self.State.InputValue.Length, $inputWidth - 3)
                Write-BufferString -X ($promptX + 1 + $cursorPos) -Y ($inputY + 1) `
                    -Text "_" -ForegroundColor (Get-ThemeColor "Warning")
            }
            
            # Draw buttons
            $buttonY = $dialogY + $dialogHeight - 2
            $buttonSpacing = 15
            $buttonsWidth = $buttonSpacing * 2
            $buttonX = $dialogX + [Math]::Floor(($dialogWidth - $buttonsWidth) / 2)
            
            # OK button
            $okFocused = ($self._focusedIndex -eq 1)
            $okText = if ($okFocused) { "[ OK ]" } else { "  OK  " }
            $okColor = if ($okFocused) { Get-ThemeColor "Warning" } else { Get-ThemeColor "Primary" }
            Write-BufferString -X $buttonX -Y $buttonY -Text $okText -ForegroundColor $okColor
            
            # Cancel button
            $cancelFocused = ($self._focusedIndex -eq 2)
            $cancelText = if ($cancelFocused) { "[ Cancel ]" } else { "  Cancel  " }
            $cancelColor = if ($cancelFocused) { Get-ThemeColor "Warning" } else { Get-ThemeColor "Primary" }
            Write-BufferString -X ($buttonX + $buttonSpacing) -Y $buttonY -Text $cancelText -ForegroundColor $cancelColor
        }
        
        HandleInput = {
            param($self, $Key)
            
            # Handle Tab navigation
            if ($Key.Key -eq [ConsoleKey]::Tab) {
                $direction = if ($Key.Modifiers -band [ConsoleModifiers]::Shift) { -1 } else { 1 }
                $self._focusedIndex = ($self._focusedIndex + $direction + 3) % 3
                Request-TuiRefresh
                return $true
            }
            
            # Handle Escape
            if ($Key.Key -eq [ConsoleKey]::Escape) {
                Close-TuiDialog
                & $OnCancel
                return $true
            }
            
            # Handle based on focused element
            switch ($self._focusedIndex) {
                0 {  # TextBox
                    switch ($Key.Key) {
                        ([ConsoleKey]::Enter) {
                            Close-TuiDialog
                            & $OnSubmit -Value $self.State.InputValue
                            return $true
                        }
                        ([ConsoleKey]::Backspace) {
                            if ($self.State.InputValue.Length -gt 0) {
                                $self.State.InputValue = $self.State.InputValue.Substring(0, $self.State.InputValue.Length - 1)
                                Request-TuiRefresh
                            }
                            return $true
                        }
                        default {
                            if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar)) {
                                $self.State.InputValue += $Key.KeyChar
                                Request-TuiRefresh
                                return $true
                            }
                        }
                    }
                }
                1 {  # OK Button
                    if ($Key.Key -eq [ConsoleKey]::Enter -or $Key.Key -eq [ConsoleKey]::Spacebar) {
                        Close-TuiDialog
                        & $OnSubmit -Value $self.State.InputValue
                        return $true
                    }
                }
                2 {  # Cancel Button
                    if ($Key.Key -eq [ConsoleKey]::Enter -or $Key.Key -eq [ConsoleKey]::Spacebar) {
                        Close-TuiDialog
                        & $OnCancel
                        return $true
                    }
                }
            }
            
            return $false
        }
    }
    
    $script:DialogState.CurrentDialog = $inputScreen
    Request-TuiRefresh
}

#endregion

#region --- Engine Integration & Initialization ---

function global:Initialize-DialogSystem {
    <# .SYNOPSIS Subscribes to high-level application events to show dialogs. #>
    
    Subscribe-Event -EventName "Confirm.Request" -Handler {
        param($EventData)
        $dialogParams = $EventData.Data
        Show-ConfirmDialog @dialogParams
    }
    
    Subscribe-Event -EventName "Alert.Show" -Handler {
        param($EventData)
        $dialogParams = $EventData.Data
        Show-AlertDialog @dialogParams
    }
    
    Subscribe-Event -EventName "Input.Request" -Handler {
        param($EventData)
        $dialogParams = $EventData.Data
        Show-InputDialog @dialogParams
    }
    
    Write-Verbose "Dialog System initialized and event handlers registered."
}

function global:Render-Dialogs {
    <# .SYNOPSIS Engine Hook: Renders the current dialog over the screen. #>
    if ($script:DialogState.CurrentDialog) {
        # If it's a component with its own render method
        if ($script:DialogState.CurrentDialog.Render) {
            & $script:DialogState.CurrentDialog.Render -self $script:DialogState.CurrentDialog
        }
    }
}

function global:Handle-DialogInput {
    <# .SYNOPSIS Engine Hook: Intercepts input if a dialog is active. #>
    param($Key)
    
    if ($script:DialogState.CurrentDialog) {
        if ($script:DialogState.CurrentDialog.HandleInput) {
            return & $script:DialogState.CurrentDialog.HandleInput -self $script:DialogState.CurrentDialog -Key $Key
        }
    }
    return $false
}

function global:Update-DialogSystem {
    <# .SYNOPSIS Engine Hook: Updates dialog system state. #>
    # Placeholder for any periodic updates needed
}

function global:New-TuiDialog {
    <# .SYNOPSIS Creates a simple dialog component. #>
    param([hashtable]$Props = @{})
    
    $dialog = @{
        Type = "Dialog"
        Title = if ($Props.Title) { $Props.Title } else { "Dialog" }
        Message = if ($Props.Message) { $Props.Message } else { "" }
        Buttons = if ($Props.Buttons) { $Props.Buttons } else { @("OK") }
        SelectedButton = 0
        Width = if ($Props.Width) { $Props.Width } else { 50 }
        Height = if ($Props.Height) { $Props.Height } else { 10 }
        X = 0
        Y = 0
        OnButtonClick = if ($Props.OnButtonClick) { $Props.OnButtonClick } else { {} }
        OnCancel = if ($Props.OnCancel) { $Props.OnCancel } else { {} }
        
        Render = {
            param($self)
            
            # Center the dialog
            $self.X = [Math]::Floor(($global:TuiState.BufferWidth - $self.Width) / 2)
            $self.Y = [Math]::Floor(($global:TuiState.BufferHeight - $self.Height) / 2)
            
            # Draw dialog box
            Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                -Title $self.Title -BorderColor (Get-ThemeColor "Accent")
            
            # Use engine's word wrap helper
            $messageY = $self.Y + 2
            $messageX = $self.X + 2
            $maxWidth = $self.Width - 4
            
            $wrappedLines = Get-WordWrappedLines -Text $self.Message -MaxWidth $maxWidth
            
            foreach ($line in $wrappedLines) {
                if ($messageY -ge ($self.Y + $self.Height - 3)) { break }  # Don't overwrite buttons
                Write-BufferString -X $messageX -Y $messageY -Text $line -ForegroundColor (Get-ThemeColor "Primary")
                $messageY++
            }
            
            # Buttons
            $buttonY = $self.Y + $self.Height - 3
            $totalButtonWidth = ($self.Buttons.Count * 12) + (($self.Buttons.Count - 1) * 2)
            $buttonX = $self.X + [Math]::Floor(($self.Width - $totalButtonWidth) / 2)
            
            for ($i = 0; $i -lt $self.Buttons.Count; $i++) {
                $isSelected = ($i -eq $self.SelectedButton)
                $buttonText = if ($isSelected) { "[ $($self.Buttons[$i]) ]" } else { "  $($self.Buttons[$i])  " }
                $color = if ($isSelected) { Get-ThemeColor "Warning" } else { Get-ThemeColor "Primary" }
                
                Write-BufferString -X $buttonX -Y $buttonY -Text $buttonText -ForegroundColor $color
                $buttonX += 14
            }
        }
        
        HandleInput = {
            param($self, $Key)
            
            switch ($Key.Key) {
                ([ConsoleKey]::LeftArrow) {
                    $self.SelectedButton = [Math]::Max(0, $self.SelectedButton - 1)
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::RightArrow) {
                    $self.SelectedButton = [Math]::Min($self.Buttons.Count - 1, $self.SelectedButton + 1)
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::Tab) {
                    $self.SelectedButton = ($self.SelectedButton + 1) % $self.Buttons.Count
                    Request-TuiRefresh
                    return $true
                }
                
                ([ConsoleKey]::Enter) {
                    & $self.OnButtonClick -Button $self.Buttons[$self.SelectedButton] -Index $self.SelectedButton
                    return $true
                }
                ([ConsoleKey]::Spacebar) {
                    & $self.OnButtonClick -Button $self.Buttons[$self.SelectedButton] -Index $self.SelectedButton
                    return $true
                }
                ([ConsoleKey]::Escape) {
                    & $self.OnCancel
                    return $true
                }
            }
            
            return $false
        }
    }
    
    return $dialog
}

function global:Show-ProgressDialog {
    <# .SYNOPSIS Shows a progress dialog with updating percentage. #>
    param(
        [string]$Title = "Progress",
        [string]$Message = "Processing...",
        [int]$PercentComplete = 0,
        [switch]$ShowCancel
    )
    
    $dialog = @{
        Type = "ProgressDialog"
        Title = $Title
        Message = $Message
        PercentComplete = $PercentComplete
        Width = 60
        Height = 8
        ShowCancel = $ShowCancel
        IsCancelled = $false
        
        Render = {
            param($self)
            
            # Center the dialog
            $x = [Math]::Floor(($global:TuiState.BufferWidth - $self.Width) / 2)
            $y = [Math]::Floor(($global:TuiState.BufferHeight - $self.Height) / 2)
            
            # Draw dialog box
            Write-BufferBox -X $x -Y $y -Width $self.Width -Height $self.Height `
                -Title " $($self.Title) " -BorderColor (Get-ThemeColor "Accent")
            
            # Draw message
            Write-BufferString -X ($x + 2) -Y ($y + 2) -Text $self.Message
            
            # Draw progress bar
            $barY = $y + 4
            $barWidth = $self.Width - 4
            $filledWidth = [Math]::Floor($barWidth * ($self.PercentComplete / 100))
            
            # Progress bar background
            Write-BufferString -X ($x + 2) -Y $barY `
                -Text ("─" * $barWidth) -ForegroundColor (Get-ThemeColor "Border")
            
            # Progress bar fill
            if ($filledWidth -gt 0) {
                Write-BufferString -X ($x + 2) -Y $barY `
                    -Text ("█" * $filledWidth) -ForegroundColor (Get-ThemeColor "Success")
            }
            
            # Percentage text
            $percentText = "$($self.PercentComplete)%"
            $percentX = $x + [Math]::Floor(($self.Width - $percentText.Length) / 2)
            Write-BufferString -X $percentX -Y $barY -Text $percentText
            
            # Cancel button if requested
            if ($self.ShowCancel) {
                $buttonY = $y + $self.Height - 2
                $buttonText = if ($self.IsCancelled) { "[ Cancelling... ]" } else { "[ Cancel ]" }
                $buttonX = $x + [Math]::Floor(($self.Width - $buttonText.Length) / 2)
                Write-BufferString -X $buttonX -Y $buttonY -Text $buttonText `
                    -ForegroundColor (Get-ThemeColor "Warning")
            }
        }
        
        HandleInput = {
            param($self, $Key)
            
            if ($self.ShowCancel -and -not $self.IsCancelled) {
                if ($Key.Key -eq [ConsoleKey]::Escape -or 
                    $Key.Key -eq [ConsoleKey]::Enter -or 
                    $Key.Key -eq [ConsoleKey]::Spacebar) {
                    $self.IsCancelled = $true
                    Request-TuiRefresh
                    return $true
                }
            }
            
            return $false
        }
        
        UpdateProgress = {
            param($self, [int]$PercentComplete, [string]$Message = $null)
            $self.PercentComplete = [Math]::Min(100, [Math]::Max(0, $PercentComplete))
            if ($Message) { $self.Message = $Message }
            Request-TuiRefresh
        }
    }
    
    $script:DialogState.CurrentDialog = $dialog
    Request-TuiRefresh
    return $dialog
}

function global:Show-ListDialog {
    <# .SYNOPSIS Shows a dialog with a selectable list of items. #>
    param(
        [string]$Title = "Select Item",
        [string]$Prompt = "Choose an item:",
        [array]$Items,
        [scriptblock]$OnSelect,
        [scriptblock]$OnCancel = {},
        [switch]$AllowMultiple
    )
    
    $dialog = @{
        Type = "ListDialog"
        Title = $Title
        Prompt = $Prompt
        Items = $Items
        SelectedIndex = 0
        SelectedItems = @()
        Width = 60
        Height = [Math]::Min(20, $Items.Count + 8)
        AllowMultiple = $AllowMultiple
        
        Render = {
            param($self)
            
            $x = [Math]::Floor(($global:TuiState.BufferWidth - $self.Width) / 2)
            $y = [Math]::Floor(($global:TuiState.BufferHeight - $self.Height) / 2)
            
            # Draw dialog box
            Write-BufferBox -X $x -Y $y -Width $self.Width -Height $self.Height `
                -Title " $($self.Title) " -BorderColor (Get-ThemeColor "Accent")
            
            # Draw prompt
            Write-BufferString -X ($x + 2) -Y ($y + 2) -Text $self.Prompt
            
            # Calculate list area
            $listY = $y + 4
            $listHeight = $self.Height - 7
            $listWidth = $self.Width - 4
            
            # Draw scrollable list
            $startIndex = [Math]::Max(0, $self.SelectedIndex - [Math]::Floor($listHeight / 2))
            $endIndex = [Math]::Min($self.Items.Count - 1, $startIndex + $listHeight - 1)
            
            for ($i = $startIndex; $i -le $endIndex; $i++) {
                $itemY = $listY + ($i - $startIndex)
                $item = $self.Items[$i]
                $isSelected = ($i -eq $self.SelectedIndex)
                $isChecked = $self.SelectedItems -contains $i
                
                # Selection indicator
                $prefix = ""
                if ($self.AllowMultiple) {
                    $prefix = if ($isChecked) { "[X] " } else { "[ ] " }
                }
                
                $itemText = "$prefix$item"
                if ($itemText.Length -gt $listWidth - 2) {
                    $itemText = $itemText.Substring(0, $listWidth - 5) + "..."
                }
                
                $bgColor = if ($isSelected) { Get-ThemeColor "Selection" } else { $null }
                $fgColor = if ($isSelected) { Get-ThemeColor "Background" } else { Get-ThemeColor "Primary" }
                
                Write-BufferString -X ($x + 2) -Y $itemY -Text $itemText `
                    -ForegroundColor $fgColor -BackgroundColor $bgColor
            }
            
            # Draw scrollbar if needed
            if ($self.Items.Count -gt $listHeight) {
                $scrollbarX = $x + $self.Width - 2
                $scrollbarHeight = $listHeight
                $thumbSize = [Math]::Max(1, [Math]::Floor($scrollbarHeight * $listHeight / $self.Items.Count))
                $thumbPos = [Math]::Floor($scrollbarHeight * $self.SelectedIndex / $self.Items.Count)
                
                for ($i = 0; $i -lt $scrollbarHeight; $i++) {
                    $char = if ($i -ge $thumbPos -and $i -lt ($thumbPos + $thumbSize)) { "█" } else { "│" }
                    Write-BufferString -X $scrollbarX -Y ($listY + $i) -Text $char `
                        -ForegroundColor (Get-ThemeColor "Border")
                }
            }
            
            # Draw buttons
            $buttonY = $y + $self.Height - 2
            if ($self.AllowMultiple) {
                $okText = "[ OK ]"
                $cancelText = "[ Cancel ]"
                $buttonSpacing = 15
                $totalWidth = 30
                $startX = $x + [Math]::Floor(($self.Width - $totalWidth) / 2)
                
                Write-BufferString -X $startX -Y $buttonY -Text $okText `
                    -ForegroundColor (Get-ThemeColor "Success")
                Write-BufferString -X ($startX + $buttonSpacing) -Y $buttonY -Text $cancelText `
                    -ForegroundColor (Get-ThemeColor "Primary")
            }
        }
        
        HandleInput = {
            param($self, $Key)
            
            switch ($Key.Key) {
                ([ConsoleKey]::UpArrow) {
                    $self.SelectedIndex = [Math]::Max(0, $self.SelectedIndex - 1)
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::DownArrow) {
                    $self.SelectedIndex = [Math]::Min($self.Items.Count - 1, $self.SelectedIndex + 1)
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::Spacebar) {
                    if ($self.AllowMultiple) {
                        if ($self.SelectedItems -contains $self.SelectedIndex) {
                            $self.SelectedItems = $self.SelectedItems | Where-Object { $_ -ne $self.SelectedIndex }
                        } else {
                            $self.SelectedItems += $self.SelectedIndex
                        }
                        Request-TuiRefresh
                        return $true
                    }
                }
                ([ConsoleKey]::Enter) {
                    Close-TuiDialog
                    if ($self.AllowMultiple) {
                        $selectedValues = $self.SelectedItems | ForEach-Object { $self.Items[$_] }
                        & $OnSelect -Selected $selectedValues
                    } else {
                        & $OnSelect -Selected $self.Items[$self.SelectedIndex]
                    }
                    return $true
                }
                ([ConsoleKey]::Escape) {
                    Close-TuiDialog
                    & $OnCancel
                    return $true
                }
            }
            
            return $false
        }
    }
    
    $script:DialogState.CurrentDialog = $dialog
    Request-TuiRefresh
}

#endregion

# Export all public functions
Export-ModuleMember -Function @(
    'Initialize-DialogSystem',
    'Show-TuiDialog',
    'Close-TuiDialog',
    'Show-ConfirmDialog',
    'Show-AlertDialog',
    'Show-InputDialog',
    'Show-ProgressDialog',
    'Show-ListDialog',
    'Render-Dialogs',
    'Handle-DialogInput',
    'Update-DialogSystem',
    'New-TuiDialog'
)
# Data Manager Module
# Unified data persistence and CRUD operations with event integration

$script:Data = @{
    Projects = @{}
    Tasks = @()
    TimeEntries = @()
    ActiveTimers = @{}
    TodoTemplates = @{}
    Settings = @{
        DefaultView = "Dashboard"
        Theme = "Modern"
        AutoSave = $true
        BackupCount = 5
    }
}

$script:DataPath = Join-Path ([Environment]::GetFolderPath("LocalApplicationData")) "PMCTerminal\pmc-data.json"
$script:BackupPath = Join-Path ([Environment]::GetFolderPath("LocalApplicationData")) "PMCTerminal\backups"
$script:LastSaveTime = $null
$script:DataModified = $false

function global:Initialize-DataManager {
    <#
    .SYNOPSIS
    Initializes the data management system
    #>
    
    # Ensure data directory exists
    $dataDir = Split-Path $script:DataPath -Parent
    if (-not (Test-Path $dataDir)) {
        New-Item -ItemType Directory -Path $dataDir -Force | Out-Null
    }
    
    # Ensure backup directory exists
    if (-not (Test-Path $script:BackupPath)) {
        New-Item -ItemType Directory -Path $script:BackupPath -Force | Out-Null
    }
    
    # Initialize event handlers
    Initialize-DataEventHandlers
    
    # Make data globally accessible
    $global:Data = $script:Data
    
    Write-Verbose "Data manager initialized"
}

function global:Load-UnifiedData {
    <#
    .SYNOPSIS
    Loads data from the persistent storage
    #>
    
    if (Test-Path $script:DataPath) {
        try {
            $jsonContent = Get-Content $script:DataPath -Raw
            # Use -Depth to ensure deeply nested objects are properly deserialized
            $loadedData = $jsonContent | ConvertFrom-Json -AsHashtable -Depth 20
            
            # Merge with default structure to ensure all keys exist
            foreach ($key in $loadedData.Keys) {
                $script:Data[$key] = $loadedData[$key]
            }
            
            $script:LastSaveTime = (Get-Item $script:DataPath).LastWriteTime
            Write-Verbose "Data loaded from $script:DataPath"
            
            # Publish event
            Publish-Event -EventName "Data.Loaded" -Data @{ 
                Path = $script:DataPath
                ItemCount = @{
                    Projects = $script:Data.Projects.Count
                    Tasks = $script:Data.Tasks.Count
                    TimeEntries = $script:Data.TimeEntries.Count
                    ActiveTimers = $script:Data.ActiveTimers.Count
                }
            }
        } catch {
            Write-Warning "Failed to load data: $_"
            Write-Warning "Using default data structure"
        }
    } else {
        Write-Verbose "No existing data file found at $script:DataPath"
        # Initialize with sample data
        Initialize-SampleData
    }
    
    # Sync global variable
    $global:Data = $script:Data
}

function global:Save-UnifiedData {
    <#
    .SYNOPSIS
    Saves data to persistent storage with backup
    #>
    
    try {
        # Create backup if file exists
        if (Test-Path $script:DataPath) {
            $backupName = "pmc-data_$(Get-Date -Format 'yyyyMMdd_HHmmss').json"
            $backupFile = Join-Path $script:BackupPath $backupName
            Copy-Item $script:DataPath $backupFile -Force
            
            # Clean old backups
            $backups = Get-ChildItem $script:BackupPath -Filter "pmc-data_*.json" | 
                       Sort-Object LastWriteTime -Descending
            
            if ($backups.Count -gt $script:Data.Settings.BackupCount) {
                $backups | Select-Object -Skip $script:Data.Settings.BackupCount | 
                          Remove-Item -Force
            }
        }
        
        # Save data with increased depth to handle nested objects
        # Use -Compress to reduce file size and -WarningAction to suppress depth warnings
        $jsonContent = $script:Data | ConvertTo-Json -Depth 20 -Compress -WarningAction SilentlyContinue
        Set-Content -Path $script:DataPath -Value $jsonContent -Force
        
        $script:LastSaveTime = Get-Date
        $script:DataModified = $false
        
        Write-Verbose "Data saved to $script:DataPath"
        
        # Publish event
        Publish-Event -EventName "Data.Saved" -Data @{ Path = $script:DataPath }
        
    } catch {
        Write-Error "Failed to save data: $_"
        Publish-Event -EventName "Data.SaveError" -Data @{ Error = $_.ToString() }
    }
}

function global:Initialize-DataEventHandlers {
    <#
    .SYNOPSIS
    Sets up event handlers for data operations
    #>
    
    # Time Entry Creation
    $null = Subscribe-Event -EventName "Data.Create.TimeEntry" -Handler {
        param($EventData)
        $data = $EventData.Data
        
        try {
            # Validate required fields
            if (-not $data.Project) { throw "Project is required" }
            if (-not $data.Hours -or $data.Hours -le 0) { throw "Valid hours required" }
            
            $newEntry = @{
                Id = New-Guid
                ProjectKey = $data.Project
                Hours = [double]$data.Hours
                Description = if ($data.Description) { $data.Description } else { "" }
                Date = if ($data.Date) { $data.Date } else { (Get-Date).ToString("yyyy-MM-dd") }
                EnteredAt = (Get-Date).ToString("o")
                TaskId = $data.TaskId
            }
            
            $script:Data.TimeEntries += $newEntry
            $script:DataModified = $true
            
            if ($script:Data.Settings.AutoSave) {
                Save-UnifiedData
            }
            
            Publish-Event -EventName "Notification.Show" -Data @{ 
                Text = "Time entry saved: $($data.Hours)h for $($data.Project)"
                Type = "Success" 
            }
            
            Publish-Event -EventName "Data.TimeEntry.Created" -Data @{ Entry = $newEntry }
            
        } catch {
            Publish-Event -EventName "Notification.Show" -Data @{ 
                Text = "Failed to create time entry: $_"
                Type = "Error" 
            }
        }
    }
    
    # Project Creation
    $null = Subscribe-Event -EventName "Data.Create.Project" -Handler {
        param($EventData)
        $data = $EventData.Data
        
        try {
            if (-not $data.Key) { throw "Project key is required" }
            if (-not $data.Name) { throw "Project name is required" }
            
            if ($script:Data.Projects.ContainsKey($data.Key)) {
                throw "Project key '$($data.Key)' already exists"
            }
            
            $newProject = @{
                Key = $data.Key
                Name = $data.Name
                Client = if ($data.Client) { $data.Client } else { "" }
                BillingType = if ($data.BillingType) { $data.BillingType } else { "NonBillable" }
                Rate = [double](if ($data.Rate) { $data.Rate } else { 0 })
                Budget = [double](if ($data.Budget) { $data.Budget } else { 0 })
                Id1 = if ($data.Id1) { $data.Id1 } else { "" }
                Id2 = if ($data.Id2) { $data.Id2 } else { "" }
                CreatedAt = (Get-Date).ToString("o")
                Active = $true
            }
            
            $script:Data.Projects[$data.Key] = $newProject
            $script:DataModified = $true
            
            if ($script:Data.Settings.AutoSave) {
                Save-UnifiedData
            }
            
            Publish-Event -EventName "Notification.Show" -Data @{ 
                Text = "Project created: $($data.Name)"
                Type = "Success" 
            }
            
            Publish-Event -EventName "Data.Project.Created" -Data @{ Project = $newProject }
            
        } catch {
            Publish-Event -EventName "Notification.Show" -Data @{ 
                Text = "Failed to create project: $_"
                Type = "Error" 
            }
        }
    }
    
    # Task Creation
    $null = Subscribe-Event -EventName "Data.Create.Task" -Handler {
        param($EventData)
        $data = $EventData.Data
        
        try {
            if (-not $data.Description) { throw "Task description is required" }
            
            $newTask = @{
                Id = New-Guid
                Description = $data.Description
                ProjectKey = $data.ProjectKey
                Priority = if ($data.Priority) { $data.Priority } else { "Medium" }
                DueDate = $data.DueDate
                Tags = @(if ($data.Tags) { $data.Tags } else { @() })
                Completed = $false
                CreatedAt = (Get-Date).ToString("o")
                Progress = 0
            }
            
            $script:Data.Tasks += $newTask
            $script:DataModified = $true
            
            if ($script:Data.Settings.AutoSave) {
                Save-UnifiedData
            }
            
            Publish-Event -EventName "Notification.Show" -Data @{ 
                Text = "Task created: $($data.Description)"
                Type = "Success" 
            }
            
            Publish-Event -EventName "Data.Task.Created" -Data @{ Task = $newTask }
            
        } catch {
            Publish-Event -EventName "Notification.Show" -Data @{ 
                Text = "Failed to create task: $_"
                Type = "Error" 
            }
        }
    }
    
    # Timer Start
    $null = Subscribe-Event -EventName "Data.Timer.Start" -Handler {
        param($EventData)
        $data = $EventData.Data
        
        try {
            if (-not $data.ProjectKey) { throw "Project is required to start timer" }
            
            $timerKey = "$($data.ProjectKey)_$(Get-Date -Format 'yyyyMMddHHmmss')"
            
            $newTimer = @{
                Key = $timerKey
                ProjectKey = $data.ProjectKey
                TaskId = $data.TaskId
                Description = if ($data.Description) { $data.Description } else { "" }
                StartTime = (Get-Date).ToString("o")
            }
            
            $script:Data.ActiveTimers[$timerKey] = $newTimer
            $script:DataModified = $true
            
            if ($script:Data.Settings.AutoSave) {
                Save-UnifiedData
            }
            
            $project = $script:Data.Projects[$data.ProjectKey]
            Publish-Event -EventName "Notification.Show" -Data @{ 
                Text = "Timer started for: $($project.Name)"
                Type = "Success" 
            }
            
            Publish-Event -EventName "Data.Timer.Started" -Data @{ Timer = $newTimer }
            
        } catch {
            Publish-Event -EventName "Notification.Show" -Data @{ 
                Text = "Failed to start timer: $_"
                Type = "Error" 
            }
        }
    }
    
    # Timer Stop
    $null = Subscribe-Event -EventName "Data.Timer.Stop" -Handler {
        param($EventData)
        $data = $EventData.Data
        
        try {
            if (-not $data.TimerKey) { throw "Timer key is required" }
            
            if (-not $script:Data.ActiveTimers.ContainsKey($data.TimerKey)) {
                throw "Timer not found: $($data.TimerKey)"
            }
            
            $timer = $script:Data.ActiveTimers[$data.TimerKey]
            $startTime = [DateTime]$timer.StartTime
            $elapsed = (Get-Date) - $startTime
            
            # Create time entry from timer
            $timeEntry = @{
                Id = New-Guid
                ProjectKey = $timer.ProjectKey
                Hours = [Math]::Round($elapsed.TotalHours, 2)
                Description = $timer.Description
                Date = $startTime.ToString("yyyy-MM-dd")
                EnteredAt = (Get-Date).ToString("o")
                TaskId = $timer.TaskId
                FromTimer = $true
            }
            
            $script:Data.TimeEntries += $timeEntry
            $script:Data.ActiveTimers.Remove($data.TimerKey)
            $script:DataModified = $true
            
            if ($script:Data.Settings.AutoSave) {
                Save-UnifiedData
            }
            
            Publish-Event -EventName "Notification.Show" -Data @{ 
                Text = "Timer stopped: $([Math]::Round($elapsed.TotalHours, 2))h recorded"
                Type = "Success" 
            }
            
            Publish-Event -EventName "Data.Timer.Stopped" -Data @{ 
                Timer = $timer
                TimeEntry = $timeEntry 
            }
            
        } catch {
            Publish-Event -EventName "Notification.Show" -Data @{ 
                Text = "Failed to stop timer: $_"
                Type = "Error" 
            }
        }
    }
    
    # Stop All Timers
    $null = Subscribe-Event -EventName "Data.Timer.StopAll" -Handler {
        param($EventData)
        
        $timerKeys = @($script:Data.ActiveTimers.Keys)
        foreach ($timerKey in $timerKeys) {
            Publish-Event -EventName "Data.Timer.Stop" -Data @{ TimerKey = $timerKey }
        }
    }
}

function global:Get-ProjectOrTemplate {
    <#
    .SYNOPSIS
    Gets a project or template by key
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$Key
    )
    
    if ($script:Data.Projects.ContainsKey($Key)) {
        return $script:Data.Projects[$Key]
    } elseif ($script:Data.TodoTemplates.ContainsKey($Key)) {
        return $script:Data.TodoTemplates[$Key]
    } else {
        return @{ 
            Key = $Key
            Name = $Key
            Client = ""
            BillingType = "NonBillable"
            Rate = 0
        }
    }
}

function global:New-Guid {
    <#
    .SYNOPSIS
    Generates a new unique identifier
    #>
    return [Guid]::NewGuid().ToString()
}

function Initialize-SampleData {
    <#
    .SYNOPSIS
    Initializes sample data for first-time users
    #>
    
    # Sample projects
    $script:Data.Projects["INTERNAL"] = @{
        Key = "INTERNAL"
        Name = "Internal Work"
        Client = "Company"
        BillingType = "NonBillable"
        Rate = 0
        Budget = 0
        Active = $true
        CreatedAt = (Get-Date).ToString("o")
    }
    
    $script:Data.Projects["SAMPLE"] = @{
        Key = "SAMPLE"
        Name = "Sample Project"
        Client = "Sample Client"
        BillingType = "Billable"
        Rate = 100
        Budget = 10000
        Active = $true
        CreatedAt = (Get-Date).ToString("o")
    }
    
    # Sample todo templates
    $script:Data.TodoTemplates["PERSONAL"] = @{
        Key = "PERSONAL"
        Name = "Personal Tasks"
        Client = ""
        BillingType = "NonBillable"
        Rate = 0
        IsTemplate = $true
    }
    
    Write-Verbose "Sample data initialized"
}

# Helper function to get week dates
function global:Get-WeekDates {
    param([DateTime]$Date)
    
    $monday = $Date.AddDays(1 - [int]$Date.DayOfWeek)
    if ($Date.DayOfWeek -eq [DayOfWeek]::Sunday) {
        $monday = $monday.AddDays(-7)
    }
    
    return @(
        @{ Name = "Monday"; Date = $monday.Date }
        @{ Name = "Tuesday"; Date = $monday.AddDays(1).Date }
        @{ Name = "Wednesday"; Date = $monday.AddDays(2).Date }
        @{ Name = "Thursday"; Date = $monday.AddDays(3).Date }
        @{ Name = "Friday"; Date = $monday.AddDays(4).Date }
    )
}

function global:Get-WeekStart {
    param([DateTime]$Date)
    
    $monday = $Date.AddDays(1 - [int]$Date.DayOfWeek)
    if ($Date.DayOfWeek -eq [DayOfWeek]::Sunday) {
        $monday = $monday.AddDays(-7)
    }
    
    return $monday.Date
}

# Export functions
Export-ModuleMember -Function @(
    'Initialize-DataManager',
    'Load-UnifiedData',
    'Save-UnifiedData',
    'Initialize-DataEventHandlers',
    'Get-ProjectOrTemplate',
    'New-Guid',
    'Get-WeekDates',
    'Get-WeekStart'
) -Variable @('Data')
# Task Management Screen - Helios Service-Based Version
# Uses the new service architecture with app store, navigation, and layout panels

function global:Get-TaskManagementScreen {
    $screen = @{
        Name = "TaskScreen"
        Components = @{}
        _subscriptions = @()
        _formVisible = $false
        _editingTaskId = $null
        
        Init = {
            param($self)
            
            Write-Log -Level Debug -Message "Task screen Init started (Helios version)"
            
            try {
                # Access services
                $services = $global:Services
                if (-not $services) {
                    Write-Log -Level Error -Message "Services not initialized"
                    return
                }
                
                # Create root layout
                $rootPanel = New-TuiStackPanel -Props @{
                    X = 1
                    Y = 1
                    Width = ($global:TuiState.BufferWidth - 2)
                    Height = ($global:TuiState.BufferHeight - 2)
                    ShowBorder = $false
                    Orientation = "Vertical"
                    Spacing = 1
                }
                $self.Components.rootPanel = $rootPanel
                
                # Header
                $headerLabel = New-TuiLabel -Props @{
                    Text = "Task Management"
                    Height = 1
                }
                & $rootPanel.AddChild -self $rootPanel -Child $headerLabel
                
                # Toolbar
                $toolbarLabel = New-TuiLabel -Props @{
                    Text = "Filter: [1]All [2]Active [3]Completed | Sort: [P]riority [D]ue Date [C]reated"
                    Height = 1
                }
                & $rootPanel.AddChild -self $rootPanel -Child $toolbarLabel
                
                # Task table panel
                $tablePanel = New-TuiStackPanel -Props @{
                    Title = " Tasks "
                    ShowBorder = $true
                    Padding = 1
                    Height = ($global:TuiState.BufferHeight - 10)  # Leave room for status bar
                }
                
                $taskTable = New-TuiDataTable -Props @{
                    Name = "taskTable"
                    IsFocusable = $true
                    ShowBorder = $false
                    Columns = @(
                        @{ Name = "Status"; Width = 3 }
                        @{ Name = "Priority"; Width = 10 }
                        @{ Name = "Title"; Width = 35 }
                        @{ Name = "Category"; Width = 12 }
                        @{ Name = "DueDate"; Width = 10 }
                    )
                    Data = @()
                    AllowSort = $false  # We handle sorting through the store
                    OnRowSelect = {
                        param($SelectedData, $SelectedIndex)
                        if ($SelectedData -and $SelectedData.Id) {
                            # Access services from global registry
                            $globalServices = $global:Services
                            if ($globalServices -and $globalServices.Store) {
                                & $globalServices.Store.Dispatch -self $globalServices.Store -actionName "TASK_TOGGLE_STATUS" -payload @{ TaskId = $SelectedData.Id }
                            }
                        }
                    }
                }
                
                & $tablePanel.AddChild -self $tablePanel -Child $taskTable
                & $rootPanel.AddChild -self $rootPanel -Child $tablePanel
                
                # Store references
                $self._taskTable = $taskTable
                $self._rootPanel = $rootPanel
                
                # Create form panel (initially hidden)
                $self._CreateFormPanel()
                
                # Subscribe to store updates
                $self._subscriptions += & $services.Store.Subscribe -self $services.Store -path "tasks" -handler {
                    param($data)
                    if ($self._taskTable) {
                        $self._taskTable.Data = $data.NewValue
                        if ($self._taskTable.ProcessData) {
                            & $self._taskTable.ProcessData -self $self._taskTable
                        }
                    }
                }
                
                $self._subscriptions += & $services.Store.Subscribe -self $services.Store -path "taskFilter" -handler {
                    param($data)
                    & $services.Store.Dispatch -self $services.Store -actionName "TASKS_REFRESH"
                }
                
                $self._subscriptions += & $services.Store.Subscribe -self $services.Store -path "taskSort" -handler {
                    param($data)
                    & $services.Store.Dispatch -self $services.Store -actionName "TASKS_REFRESH"
                }
                
                # Register store actions
                if (-not $services.Store._actions.ContainsKey("TASKS_REFRESH")) {
                    & $services.Store.RegisterAction -self $services.Store -actionName "TASKS_REFRESH" -scriptBlock {
                        param($Context)
                        
                        $filter = & $Context.GetState -path "taskFilter" ?? "all"
                        $sort = & $Context.GetState -path "taskSort" ?? "priority"
                        
                        # Get raw tasks
                        $tasks = @()
                        if ($global:Data -and $global:Data.tasks) {
                            $tasks = $global:Data.tasks
                        }
                        
                        # Apply filter
                        $filtered = switch ($filter) {
                            "active" { $tasks | Where-Object { -not $_.completed } }
                            "completed" { $tasks | Where-Object { $_.completed } }
                            default { $tasks }
                        }
                        
                        # Apply sort
                        $sorted = switch ($sort) {
                            "priority" {
                                $filtered | Sort-Object @{
                                    Expression = {
                                        switch ($_.priority) {
                                            "Critical" { 0 }
                                            "High" { 1 }
                                            "Medium" { 2 }
                                            "Low" { 3 }
                                            default { 4 }
                                        }
                                    }
                                }, created
                            }
                            "dueDate" { $filtered | Sort-Object dueDate, priority }
                            "created" { $filtered | Sort-Object created -Descending }
                            default { $filtered }
                        }
                        
                        # Transform for display
                        $displayTasks = @($sorted | ForEach-Object {
                            @{
                                Id = $_.id ?? [Guid]::NewGuid().ToString()
                                Status = if ($_.completed) { "✓" } else { " " }
                                Priority = $_.priority ?? "Medium"
                                Title = $_.title ?? "Untitled"
                                Category = $_.category ?? "General"
                                DueDate = if ($_.dueDate) { 
                                    try { [DateTime]::Parse($_.dueDate).ToString("yyyy-MM-dd") } 
                                    catch { $_.dueDate }
                                } else { "" }
                            }
                        })
                        
                        $Context.UpdateState(@{ tasks = $displayTasks })
                    }
                    
                    & $services.Store.RegisterAction -self $services.Store -actionName "TASK_TOGGLE_STATUS" -scriptBlock {
                        param($Context, $Payload)
                        
                        if ($global:Data -and $global:Data.tasks -and $Payload.TaskId) {
                            $task = $global:Data.tasks | Where-Object { $_.id -eq $Payload.TaskId }
                            if ($task) {
                                $task.completed = -not $task.completed
                                $task.completedDate = if ($task.completed) { Get-Date } else { $null }
                                
                                # Save data
                                if (Get-Command Save-UnifiedData -ErrorAction SilentlyContinue) {
                                    Save-UnifiedData
                                }
                                
                                # Refresh display
                                & $Context.Dispatch -actionName "TASKS_REFRESH"
                            }
                        }
                    }
                    
                    & $services.Store.RegisterAction -self $services.Store -actionName "TASK_CREATE" -scriptBlock {
                        param($Context, $Payload)
                        
                        if (-not $global:Data) { $global:Data = @{} }
                        if (-not $global:Data.tasks) { $global:Data.tasks = @() }
                        
                        $newTask = @{
                            id = [Guid]::NewGuid().ToString()
                            title = $Payload.Title
                            description = $Payload.Description
                            category = $Payload.Category
                            priority = $Payload.Priority
                            dueDate = $Payload.DueDate
                            created = Get-Date
                            completed = $false
                        }
                        
                        $global:Data.tasks += $newTask
                        
                        # Save data
                        if (Get-Command Save-UnifiedData -ErrorAction SilentlyContinue) {
                            Save-UnifiedData
                        }
                        
                        # Refresh display
                        & $Context.Dispatch -actionName "TASKS_REFRESH"
                    }
                    
                    & $services.Store.RegisterAction -self $services.Store -actionName "TASK_UPDATE" -scriptBlock {
                        param($Context, $Payload)
                        
                        if ($global:Data -and $global:Data.tasks -and $Payload.TaskId) {
                            $task = $global:Data.tasks | Where-Object { $_.id -eq $Payload.TaskId }
                            if ($task) {
                                $task.title = $Payload.Title
                                $task.description = $Payload.Description
                                $task.category = $Payload.Category
                                $task.priority = $Payload.Priority
                                $task.dueDate = $Payload.DueDate
                                
                                # Save data
                                if (Get-Command Save-UnifiedData -ErrorAction SilentlyContinue) {
                                    Save-UnifiedData
                                }
                                
                                # Refresh display
                                & $Context.Dispatch -actionName "TASKS_REFRESH"
                            }
                        }
                    }
                    
                    & $services.Store.RegisterAction -self $services.Store -actionName "TASK_DELETE" -scriptBlock {
                        param($Context, $Payload)
                        
                        if ($global:Data -and $global:Data.tasks -and $Payload.TaskId) {
                            $global:Data.tasks = @($global:Data.tasks | Where-Object { $_.id -ne $Payload.TaskId })
                            
                            # Save data
                            if (Get-Command Save-UnifiedData -ErrorAction SilentlyContinue) {
                                Save-UnifiedData
                            }
                            
                            # Refresh display
                            & $Context.Dispatch -actionName "TASKS_REFRESH"
                        }
                    }
                }
                
                # Initialize filter and sort state
                & $services.Store.Dispatch -self $services.Store -actionName "UPDATE_STATE" -payload @{
                    taskFilter = "all"
                    taskSort = "priority"
                }
                
                # Load initial data
                & $services.Store.Dispatch -self $services.Store -actionName "TASKS_REFRESH"
                
                Write-Log -Level Debug -Message "Task screen Init completed"
                
            } catch {
                Write-Log -Level Error -Message "Task screen Init error: $_" -Data $_
            }
        }
        
        _CreateFormPanel = {
            # Calculate centered position
            $formWidth = 60
            $formHeight = 20
            $formX = [Math]::Floor(($global:TuiState.BufferWidth - $formWidth) / 2)
            $formY = [Math]::Floor(($global:TuiState.BufferHeight - $formHeight) / 2)
            
            $formPanel = New-TuiGridPanel -Props @{
                X = $formX
                Y = $formY
                Width = $formWidth
                Height = $formHeight
                ShowBorder = $true
                Title = " New Task "
                Visible = $false
                BackgroundColor = (Get-ThemeColor "Background" -Default Black)
                RowDefinitions = @("3", "3", "3", "3", "3", "3", "1*")  # Fixed rows + flexible bottom
                ColumnDefinitions = @("15", "1*")  # Label column + input column
            }
            
            # Title field
            $titleLabel = New-TuiLabel -Props @{ Text = "Title:"; Height = 1 }
            $titleInput = New-TuiTextBox -Props @{
                Name = "formTitle"
                IsFocusable = $true
                Height = 3
                Placeholder = "Enter task title..."
            }
            & $formPanel.AddChild -self $formPanel -Child $titleLabel -LayoutProps @{ "Grid.Row" = 0; "Grid.Column" = 0 }
            & $formPanel.AddChild -self $formPanel -Child $titleInput -LayoutProps @{ "Grid.Row" = 0; "Grid.Column" = 1 }
            
            # Description field
            $descLabel = New-TuiLabel -Props @{ Text = "Description:"; Height = 1 }
            $descInput = New-TuiTextBox -Props @{
                Name = "formDescription"
                IsFocusable = $true
                Height = 3
                Placeholder = "Enter description..."
            }
            & $formPanel.AddChild -self $formPanel -Child $descLabel -LayoutProps @{ "Grid.Row" = 1; "Grid.Column" = 0 }
            & $formPanel.AddChild -self $formPanel -Child $descInput -LayoutProps @{ "Grid.Row" = 1; "Grid.Column" = 1 }
            
            # Category dropdown
            $catLabel = New-TuiLabel -Props @{ Text = "Category:"; Height = 1 }
            $catDropdown = New-TuiDropdown -Props @{
                Name = "formCategory"
                IsFocusable = $true
                Height = 3
                Options = @("Work", "Personal", "Urgent", "Projects") | ForEach-Object { @{ Display = $_; Value = $_ } }
                Value = "Work"
            }
            & $formPanel.AddChild -self $formPanel -Child $catLabel -LayoutProps @{ "Grid.Row" = 2; "Grid.Column" = 0 }
            & $formPanel.AddChild -self $formPanel -Child $catDropdown -LayoutProps @{ "Grid.Row" = 2; "Grid.Column" = 1 }
            
            # Priority dropdown
            $priLabel = New-TuiLabel -Props @{ Text = "Priority:"; Height = 1 }
            $priDropdown = New-TuiDropdown -Props @{
                Name = "formPriority"
                IsFocusable = $true
                Height = 3
                Options = @("Critical", "High", "Medium", "Low") | ForEach-Object { @{ Display = $_; Value = $_ } }
                Value = "Medium"
            }
            & $formPanel.AddChild -self $formPanel -Child $priLabel -LayoutProps @{ "Grid.Row" = 3; "Grid.Column" = 0 }
            & $formPanel.AddChild -self $formPanel -Child $priDropdown -LayoutProps @{ "Grid.Row" = 3; "Grid.Column" = 1 }
            
            # Due date picker
            $dueLabel = New-TuiLabel -Props @{ Text = "Due Date:"; Height = 1 }
            $duePicker = New-TuiDatePicker -Props @{
                Name = "formDueDate"
                IsFocusable = $true
                Height = 3
                Value = (Get-Date).AddDays(7)
            }
            & $formPanel.AddChild -self $formPanel -Child $dueLabel -LayoutProps @{ "Grid.Row" = 4; "Grid.Column" = 0 }
            & $formPanel.AddChild -self $formPanel -Child $duePicker -LayoutProps @{ "Grid.Row" = 4; "Grid.Column" = 1 }
            
            # Buttons
            $buttonPanel = New-TuiStackPanel -Props @{
                Orientation = "Horizontal"
                HorizontalAlignment = "Center"
                Spacing = 2
                Height = 3
            }
            
            $saveButton = New-TuiButton -Props @{
                Text = "Save"
                Width = 12
                Height = 3
                IsFocusable = $true
                OnClick = { & $self._SaveTask }
            }
            
            $cancelButton = New-TuiButton -Props @{
                Text = "Cancel"
                Width = 12
                Height = 3
                IsFocusable = $true
                OnClick = { & $self._HideForm }
            }
            
            & $buttonPanel.AddChild -self $buttonPanel -Child $saveButton
            & $buttonPanel.AddChild -self $buttonPanel -Child $cancelButton
            & $formPanel.AddChild -self $formPanel -Child $buttonPanel -LayoutProps @{ 
                "Grid.Row" = 6
                "Grid.Column" = 0
                "Grid.ColumnSpan" = 2
            }
            
            # Store form panel and references
            $self.Components.formPanel = $formPanel
            $self._formFields = @{
                Title = $titleInput
                Description = $descInput
                Category = $catDropdown
                Priority = $priDropdown
                DueDate = $duePicker
            }
        }
        
        _ShowForm = {
            param($taskId = $null)
            
            Write-Log -Level Debug -Message "Showing task form, taskId: $taskId"
            
            $self._formVisible = $true
            $self._editingTaskId = $taskId
            
            # Update form title
            $self.Components.formPanel.Title = if ($taskId) { " Edit Task " } else { " New Task " }
            
            # Populate form if editing
            if ($taskId -and $global:Data -and $global:Data.tasks) {
                $task = $global:Data.tasks | Where-Object { $_.id -eq $taskId }
                if ($task) {
                    $self._formFields.Title.Text = $task.title ?? ""
                    $self._formFields.Description.Text = $task.description ?? ""
                    $self._formFields.Category.Value = $task.category ?? "Work"
                    $self._formFields.Priority.Value = $task.priority ?? "Medium"
                    if ($task.dueDate) {
                        try {
                            $self._formFields.DueDate.Value = [DateTime]::Parse($task.dueDate)
                        } catch {
                            $self._formFields.DueDate.Value = (Get-Date).AddDays(7)
                        }
                    }
                }
            } else {
                # Clear form for new task
                $self._formFields.Title.Text = ""
                $self._formFields.Description.Text = ""
                $self._formFields.Category.Value = "Work"
                $self._formFields.Priority.Value = "Medium"
                $self._formFields.DueDate.Value = (Get-Date).AddDays(7)
            }
            
            # Show form
            & $self.Components.formPanel.Show -self $self.Components.formPanel
            
            # Focus first field
            if (Get-Command Request-Focus -ErrorAction SilentlyContinue) {
                Request-Focus -Component $self._formFields.Title
            }
            
            Request-TuiRefresh
        }
        
        _HideForm = {
            Write-Log -Level Debug -Message "Hiding task form"
            
            $self._formVisible = $false
            $self._editingTaskId = $null
            
            # Hide form
            & $self.Components.formPanel.Hide -self $self.Components.formPanel
            
            # Return focus to table
            if (Get-Command Request-Focus -ErrorAction SilentlyContinue) {
                Request-Focus -Component $self._taskTable
            }
            
            # Force full redraw to clear artifacts
            $global:TuiState.RenderStats.FrameCount = 0
            Request-TuiRefresh
        }
        
        _SaveTask = {
            Write-Log -Level Debug -Message "Saving task"
            
            $formData = @{
                Title = $self._formFields.Title.Text
                Description = $self._formFields.Description.Text
                Category = $self._formFields.Category.Value
                Priority = $self._formFields.Priority.Value
                DueDate = if ($self._formFields.DueDate.Value -is [DateTime]) {
                    $self._formFields.DueDate.Value.ToString("yyyy-MM-dd")
                } else {
                    $self._formFields.DueDate.Value
                }
            }
            
            # Validate
            if ([string]::IsNullOrWhiteSpace($formData.Title)) {
                Show-AlertDialog -Title "Validation Error" -Message "Task title is required"
                return
            }
            
            # Dispatch appropriate action
            $services = $global:Services
            if ($self._editingTaskId) {
                $formData.TaskId = $self._editingTaskId
                & $services.Store.Dispatch -self $services.Store -actionName "TASK_UPDATE" -payload $formData
            } else {
                & $services.Store.Dispatch -self $services.Store -actionName "TASK_CREATE" -payload $formData
            }
            
            & $self._HideForm
        }
        
        Render = {
            param($self)
            
            try {
                # Render main layout
                if ($self.Components.rootPanel -and $self.Components.rootPanel.Render) {
                    & $self.Components.rootPanel.Render -self $self.Components.rootPanel
                }
                
                # Render form on top if visible
                if ($self._formVisible -and $self.Components.formPanel -and $self.Components.formPanel.Render) {
                    # Clear area behind form
                    $panel = $self.Components.formPanel
                    for ($y = $panel.Y; $y -lt ($panel.Y + $panel.Height); $y++) {
                        Write-BufferString -X $panel.X -Y $y -Text (" " * $panel.Width) -BackgroundColor Black
                    }
                    
                    # Render form
                    & $self.Components.formPanel.Render -self $self.Components.formPanel
                }
                
                # Status bar
                $statusY = $global:TuiState.BufferHeight - 1
                $statusText = if ($self._formVisible) {
                    "Tab: Next Field | Esc: Cancel"
                } else {
                    "N: New | E: Edit | D: Delete | Space: Toggle | Q: Back"
                }
                Write-BufferString -X 2 -Y $statusY -Text $statusText -ForegroundColor (Get-ThemeColor "Subtle" -Default DarkGray)
                
            } catch {
                Write-Log -Level Error -Message "Task screen Render error: $_" -Data $_
                Write-BufferString -X 2 -Y 2 -Text "Error rendering task screen: $_" -ForegroundColor Red
            }
        }
        
        HandleInput = {
            param($self, $Key)
            
            try {
                $services = $global:Services
                if (-not $services) {
                    return $false
                }
                
                # Form mode input handling
                if ($self._formVisible) {
                    if ((& $services.Keybindings.IsAction -self $services.Keybindings -ActionName "Form.Cancel" -KeyInfo $Key) -or $Key.Key -eq [ConsoleKey]::Escape) {
                        & $self._HideForm
                        return $true
                    }
                    return $false  # Let focus manager handle tab navigation
                }
                
                # List mode input handling
                switch ($Key.KeyChar) {
                    'n' { & $self._ShowForm; return $true }
                    'e' {
                        $selected = $self._taskTable.SelectedRow
                        if ($selected -ge 0 -and $selected -lt $self._taskTable.ProcessedData.Count) {
                            $taskId = $self._taskTable.ProcessedData[$selected].Id
                            & $self._ShowForm -taskId $taskId
                        }
                        return $true
                    }
                    'd' {
                        $selected = $self._taskTable.SelectedRow
                        if ($selected -ge 0 -and $selected -lt $self._taskTable.ProcessedData.Count) {
                            $taskId = $self._taskTable.ProcessedData[$selected].Id
                            Show-ConfirmDialog -Title "Delete Task" -Message "Are you sure you want to delete this task?" -OnConfirm {
                                & $services.Store.Dispatch -self $services.Store -actionName "TASK_DELETE" -payload @{ TaskId = $taskId }
                            }
                        }
                        return $true
                    }
                    'q' { return "Back" }
                    
                    # Filter keys
                    '1' { & $services.Store.Dispatch -self $services.Store -actionName "UPDATE_STATE" -payload @{ taskFilter = "all" }; return $true }
                    '2' { & $services.Store.Dispatch -self $services.Store -actionName "UPDATE_STATE" -payload @{ taskFilter = "active" }; return $true }
                    '3' { & $services.Store.Dispatch -self $services.Store -actionName "UPDATE_STATE" -payload @{ taskFilter = "completed" }; return $true }
                    
                    # Sort keys
                    'p' { & $services.Store.Dispatch -self $services.Store -actionName "UPDATE_STATE" -payload @{ taskSort = "priority" }; return $true }
                    'd' { & $services.Store.Dispatch -self $services.Store -actionName "UPDATE_STATE" -payload @{ taskSort = "dueDate" }; return $true }
                    'c' { & $services.Store.Dispatch -self $services.Store -actionName "UPDATE_STATE" -payload @{ taskSort = "created" }; return $true }
                }
                
                # Check global keybindings
                $action = & $services.Keybindings.HandleKey -self $services.Keybindings -KeyInfo $Key
                if ($action -eq "App.Back") {
                    return "Back"
                }
                
                return $false
                
            } catch {
                Write-Log -Level Error -Message "Task screen HandleInput error: $_" -Data $_
                return $false
            }
        }
        
        OnExit = {
            param($self)
            
            Write-Log -Level Debug -Message "Task screen exiting"
            
            # Unsubscribe from store
            $services = $global:Services
            if ($services -and $services.Store) {
                foreach ($subId in $self._subscriptions) {
                    & $services.Store.Unsubscribe -self $services.Store -subId $subId
                }
            }
        }
        
        OnResume = {
            param($self)
            
            Write-Log -Level Debug -Message "Task screen resuming"
            
            # Force complete redraw
            if ($global:TuiState -and $global:TuiState.RenderStats) {
                $global:TuiState.RenderStats.FrameCount = 0
            }
            
            # Refresh data
            $services = $global:Services
            if ($services -and $services.Store) {
                & $services.Store.Dispatch -self $services.Store -actionName "TASKS_REFRESH"
            }
            
            Request-TuiRefresh
        }
    }
    
    return $screen
}

# Alias for backward compatibility
function global:Get-TaskScreen {
    return Get-TaskManagementScreen
}

Export-ModuleMember -Function Get-TaskManagementScreen, Get-TaskScreen
# Dashboard Screen - Helios Service-Based Version
# Uses the new service architecture with app store and navigation

function global:Get-DashboardScreen {
    $screen = @{
        Name = "DashboardScreen"
        Components = @{}
        _subscriptions = @()
        
        Init = {
            param($self)
            
            Write-Log -Level Debug -Message "Dashboard Init started (Helios version)"
            
            try {
                # Access services from global registry
                $services = $global:Services
                if (-not $services) {
                    Write-Log -Level Error -Message "Services not initialized"
                    return
                }
                
                # Create the main grid layout
                $rootPanel = New-TuiGridPanel -Props @{
                    X = 1
                    Y = 2
                    Width = ($global:TuiState.BufferWidth - 2)
                    Height = ($global:TuiState.BufferHeight - 4)
                    ShowBorder = $false
                    RowDefinitions = @("14", "1*")  # Top row fixed, bottom row flexible
                    ColumnDefinitions = @("37", "42", "1*")  # Fixed widths for consistency
                }
                $self.Components.rootPanel = $rootPanel
                
                # Quick Actions Panel
                $quickActionsPanel = New-TuiStackPanel -Props @{
                    Name = "quickActionsPanel"
                    Title = " Quick Actions "
                    ShowBorder = $true
                    BorderStyle = "Single"
                    Padding = 1
                }
                
                $quickActions = New-TuiDataTable -Props @{
                    Name = "quickActions"
                    Title = "Quick Actions"  # Add title for debugging
                    IsFocusable = $true
                    ShowBorder = $false
                    ShowHeader = $false
                    ShowFooter = $false
                    Columns = @(
                        @{ Name = "Action"; Width = 32 }
                    )
                    Data = @(  # Initialize with data immediately
                        @{ Action = "1. Add Time Entry" },
                        @{ Action = "2. Start Timer" },
                        @{ Action = "3. Manage Tasks" },
                        @{ Action = "4. Manage Projects" },
                        @{ Action = "5. View Reports" },
                        @{ Action = "6. Settings" }
                    )
                    OnRowSelect = {
                        param($SelectedData, $SelectedIndex)
                        Write-Log -Level Debug -Message "Quick action selected: $SelectedIndex"
                        
                        # Use navigation service for routing
                        $routes = @("/time-entry", "/timer/start", "/tasks", "/projects", "/reports", "/settings")
                        if ($SelectedIndex -ge 0 -and $SelectedIndex -lt $routes.Count) {
                            # Access services from global registry
                            $globalServices = $global:Services
                            if ($globalServices -and $globalServices.Navigation) {
                                & $globalServices.Navigation.GoTo -self $globalServices.Navigation -Path $routes[$SelectedIndex]
                            }
                        }
                    }
                }
                
                # Process initial data
                if ($quickActions.ProcessData) {
                    & $quickActions.ProcessData -self $quickActions
                }
                
                & $quickActionsPanel.AddChild -self $quickActionsPanel -Child $quickActions
                & $rootPanel.AddChild -self $rootPanel -Child $quickActionsPanel -LayoutProps @{ 
                    "Grid.Row" = 0
                    "Grid.Column" = 0 
                }
                
                # Active Timers Panel
                $timersPanel = New-TuiStackPanel -Props @{
                    Name = "timersPanel"
                    Title = " Active Timers "
                    ShowBorder = $true
                    BorderStyle = "Single"
                    Padding = 1
                }
                
                $activeTimers = New-TuiDataTable -Props @{
                    Name = "activeTimers"
                    IsFocusable = $true
                    ShowBorder = $false
                    ShowFooter = $false
                    Columns = @(
                        @{ Name = "Project"; Width = 20 }
                        @{ Name = "Time"; Width = 10 }
                    )
                    Data = @()
                }
                
                # Process initial data
                if ($activeTimers.ProcessData) {
                    & $activeTimers.ProcessData -self $activeTimers
                }
                
                & $timersPanel.AddChild -self $timersPanel -Child $activeTimers
                & $rootPanel.AddChild -self $rootPanel -Child $timersPanel -LayoutProps @{ 
                    "Grid.Row" = 0
                    "Grid.Column" = 1 
                }
                
                # Stats Panel
                $statsPanel = New-TuiStackPanel -Props @{
                    Name = "statsPanel"
                    Title = " Stats "
                    ShowBorder = $true
                    BorderStyle = "Single"
                    Padding = 1
                    Orientation = "Vertical"
                    Spacing = 1
                }
                
                # Create stat labels
                $todayLabel = New-TuiLabel -Props @{
                    Name = "todayHoursLabel"
                    Text = "Today: 0h"
                    Height = 1
                }
                $weekLabel = New-TuiLabel -Props @{
                    Name = "weekHoursLabel"
                    Text = "Week: 0h"
                    Height = 1
                }
                $tasksLabel = New-TuiLabel -Props @{
                    Name = "activeTasksLabel"
                    Text = "Tasks: 0"
                    Height = 1
                }
                $timersLabel = New-TuiLabel -Props @{
                    Name = "runningTimersLabel"
                    Text = "Timers: 0"
                    Height = 1
                }
                
                & $statsPanel.AddChild -self $statsPanel -Child $todayLabel
                & $statsPanel.AddChild -self $statsPanel -Child $weekLabel
                & $statsPanel.AddChild -self $statsPanel -Child $tasksLabel
                & $statsPanel.AddChild -self $statsPanel -Child $timersLabel
                
                & $rootPanel.AddChild -self $rootPanel -Child $statsPanel -LayoutProps @{ 
                    "Grid.Row" = 0
                    "Grid.Column" = 2 
                }
                
                # Today's Tasks Panel (spans all columns)
                $tasksPanel = New-TuiStackPanel -Props @{
                    Name = "tasksPanel"
                    Title = " Today's Tasks "
                    ShowBorder = $true
                    BorderStyle = "Single"
                    Padding = 1
                }
                
                $todaysTasks = New-TuiDataTable -Props @{
                    Name = "todaysTasks"
                    IsFocusable = $true
                    ShowBorder = $false
                    ShowFooter = $false
                    Columns = @(
                        @{ Name = "Priority"; Width = 8 }
                        @{ Name = "Task"; Width = 45 }
                        @{ Name = "Project"; Width = 15 }
                    )
                    Data = @()
                    AllowSort = $true
                }
                
                # Process initial data
                if ($todaysTasks.ProcessData) {
                    & $todaysTasks.ProcessData -self $todaysTasks
                }
                
                & $tasksPanel.AddChild -self $tasksPanel -Child $todaysTasks
                & $rootPanel.AddChild -self $rootPanel -Child $tasksPanel -LayoutProps @{ 
                    "Grid.Row" = 1
                    "Grid.Column" = 0
                    "Grid.ColumnSpan" = 3
                }
                
                # Store references for easy access
                $self._quickActions = $quickActions
                $self._activeTimers = $activeTimers
                $self._todaysTasks = $todaysTasks
                $self._todayLabel = $todayLabel
                $self._weekLabel = $weekLabel
                $self._tasksLabel = $tasksLabel
                $self._timersLabel = $timersLabel
                
                # Subscribe to app store updates
                $self._subscriptions += & $services.Store.Subscribe -self $services.Store -path "quickActions" -handler {
                    param($data)
                    if ($self._quickActions) {
                        $self._quickActions.Data = $data.NewValue
                        if ($self._quickActions.ProcessData) {
                            & $self._quickActions.ProcessData -self $self._quickActions
                        }
                    }
                }
                
                $self._subscriptions += & $services.Store.Subscribe -self $services.Store -path "activeTimers" -handler {
                    param($data)
                    if ($self._activeTimers) {
                        $self._activeTimers.Data = $data.NewValue
                        if ($self._activeTimers.ProcessData) {
                            & $self._activeTimers.ProcessData -self $self._activeTimers
                        }
                    }
                }
                
                $self._subscriptions += & $services.Store.Subscribe -self $services.Store -path "todaysTasks" -handler {
                    param($data)
                    if ($self._todaysTasks) {
                        $self._todaysTasks.Data = $data.NewValue
                        if ($self._todaysTasks.ProcessData) {
                            & $self._todaysTasks.ProcessData -self $self._todaysTasks
                        }
                    }
                }
                
                $self._subscriptions += & $services.Store.Subscribe -self $services.Store -path "stats.todayHours" -handler {
                    param($data)
                    if ($self._todayLabel) {
                        $self._todayLabel.Text = "Today: $($data.NewValue)h"
                    }
                }
                
                $self._subscriptions += & $services.Store.Subscribe -self $services.Store -path "stats.weekHours" -handler {
                    param($data)
                    if ($self._weekLabel) {
                        $self._weekLabel.Text = "Week: $($data.NewValue)h"
                    }
                }
                
                $self._subscriptions += & $services.Store.Subscribe -self $services.Store -path "stats.activeTasks" -handler {
                    param($data)
                    if ($self._tasksLabel) {
                        $self._tasksLabel.Text = "Tasks: $($data.NewValue)"
                    }
                }
                
                $self._subscriptions += & $services.Store.Subscribe -self $services.Store -path "stats.runningTimers" -handler {
                    param($data)
                    if ($self._timersLabel) {
                        $self._timersLabel.Text = "Timers: $($data.NewValue)"
                    }
                }
                
                # Register store actions if not already registered
                if (-not $services.Store._actions.ContainsKey("DASHBOARD_REFRESH")) {
                    & $services.Store.RegisterAction -self $services.Store -actionName "DASHBOARD_REFRESH" -scriptBlock {
                        param($Context)
                        
                        # Quick Actions
                        $quickActions = @(
                            @{ Action = "1. Add Time Entry" },
                            @{ Action = "2. Start Timer" },
                            @{ Action = "3. Manage Tasks" },
                            @{ Action = "4. Manage Projects" },
                            @{ Action = "5. View Reports" },
                            @{ Action = "6. Settings" }
                        )
                        $Context.UpdateState(@{ quickActions = $quickActions })
                        
                        # Active Timers
                        $timerData = @()
                        if ($global:Data -and $global:Data.active_timers) {
                            foreach ($timerEntry in $global:Data.active_timers.GetEnumerator()) {
                                $timer = $timerEntry.Value
                                if ($timer -and $timer.start_time) {
                                    $elapsed = (Get-Date) - [DateTime]$timer.start_time
                                    $project = if ($global:Data.projects -and $timer.project_key) { 
                                        $global:Data.projects[$timer.project_key].name 
                                    } else { 
                                        "Unknown" 
                                    }
                                    
                                    $timerData += @{
                                        Project = $project
                                        Time = "{0:00}:{1:00}:{2:00}" -f [Math]::Floor($elapsed.TotalHours), $elapsed.Minutes, $elapsed.Seconds
                                    }
                                }
                            }
                        }
                        $Context.UpdateState(@{ activeTimers = $timerData })
                        
                        # Today's Tasks
                        $taskData = @()
                        if ($global:Data -and $global:Data.tasks) {
                            $today = (Get-Date).ToString("yyyy-MM-dd")
                            foreach ($task in $global:Data.tasks) {
                                if ($task -and -not $task.completed -and ($task.due_date -eq $today -or [string]::IsNullOrEmpty($task.due_date))) {
                                    $project = if ($global:Data.projects -and $task.project_key) { 
                                        $global:Data.projects[$task.project_key].name 
                                    } else { 
                                        "None" 
                                    }
                                    
                                    $taskData += @{
                                        Priority = $task.priority ?? "Medium"
                                        Task = $task.description ?? $task.title ?? "Untitled"
                                        Project = $project
                                    }
                                }
                            }
                        }
                        $Context.UpdateState(@{ todaysTasks = $taskData })
                        
                        # Calculate Stats
                        $stats = @{
                            todayHours = 0
                            weekHours = 0
                            activeTasks = 0
                            runningTimers = 0
                        }
                        
                        if ($global:Data) {
                            $today = (Get-Date).ToString("yyyy-MM-dd")
                            
                            if ($global:Data.time_entries) {
                                $todayEntries = @($global:Data.time_entries | Where-Object { $_ -and $_.date -eq $today })
                                $stats.todayHours = [Math]::Round(($todayEntries | Measure-Object -Property hours -Sum).Sum, 2)
                                
                                $weekStart = (Get-Date).AddDays(-[int](Get-Date).DayOfWeek).Date
                                $weekEntries = @($global:Data.time_entries | Where-Object { 
                                    $_ -and $_.date -and ([DateTime]::Parse($_.date) -ge $weekStart)
                                })
                                $stats.weekHours = [Math]::Round(($weekEntries | Measure-Object -Property hours -Sum).Sum, 2)
                            }
                            
                            if ($global:Data.tasks) {
                                $stats.activeTasks = @($global:Data.tasks | Where-Object { $_ -and -not $_.completed }).Count
                            }
                            
                            if ($global:Data.active_timers) {
                                $stats.runningTimers = $global:Data.active_timers.Count
                            }
                        }
                        
                        $Context.UpdateState(@{ stats = $stats })
                    }
                }
                
                # Initial data load
                & $services.Store.Dispatch -self $services.Store -actionName "DASHBOARD_REFRESH"
                
                # Set initial focus on quick actions
                if ($quickActions.IsFocusable -and (Get-Command Request-Focus -ErrorAction SilentlyContinue)) {
                    Request-Focus -Component $quickActions
                } elseif (Get-Command Set-ComponentFocus -ErrorAction SilentlyContinue) {
                    Set-ComponentFocus -Component $quickActions
                }
                
                # Set up auto-refresh timer and store the subscription for cleanup
                $self._refreshTimer = [System.Timers.Timer]::new(5000)  # 5 seconds
                $self._timerSubscription = Register-ObjectEvent -InputObject $self._refreshTimer -EventName Elapsed -Action {
                    if ($global:Services -and $global:Services.Store) {
                        & $global:Services.Store.Dispatch -self $global:Services.Store -actionName "DASHBOARD_REFRESH"
                    }
                }
                $self._refreshTimer.Start()
                
                Write-Log -Level Debug -Message "Dashboard Init completed"
                
            } catch {
                Write-Log -Level Error -Message "Dashboard Init error: $_" -Data $_
            }
        }
        
        Render = {
            param($self)
            
            try {
                # Header
                $headerColor = Get-ThemeColor "Header" -Default Cyan
                $currentTime = Get-Date -Format 'dddd, MMMM dd, yyyy HH:mm:ss'
                Write-BufferString -X 2 -Y 1 -Text "PMC Terminal Dashboard - $currentTime" -ForegroundColor $headerColor
                
                # Debug logging
                Write-Log -Level Debug -Message "Dashboard Render: Starting"
                Write-Log -Level Debug -Message "  rootPanel exists: $($null -ne $self.Components.rootPanel)"
                if ($self.Components.rootPanel) {
                    Write-Log -Level Debug -Message "  rootPanel visible: $($self.Components.rootPanel.Visible)"
                    Write-Log -Level Debug -Message "  rootPanel has Render: $($null -ne $self.Components.rootPanel.Render)"
                }
                
                # Active timer indicator
                $store = $global:Services.Store
                if ($store) {
                    $timers = & $store.GetState -self $store -path "stats.runningTimers"
                    if ($timers -gt 0) {
                        $timerText = "● TIMER ACTIVE"
                        $timerX = $global:TuiState.BufferWidth - $timerText.Length - 2
                        Write-BufferString -X $timerX -Y 1 -Text $timerText -ForegroundColor Red
                    }
                }
                
                # Render the root panel (which renders all children)
                if ($self.Components.rootPanel -and $self.Components.rootPanel.Render) {
                    Write-Log -Level Debug -Message "Dashboard Render: Calling rootPanel.Render"
                    & $self.Components.rootPanel.Render -self $self.Components.rootPanel
                } else {
                    Write-Log -Level Warning -Message "Dashboard Render: rootPanel or its Render method not found"
                }
                
                # Status bar
                $subtleColor = Get-ThemeColor "Subtle" -Default DarkGray
                $statusY = $global:TuiState.BufferHeight - 2
                Write-BufferString -X 2 -Y $statusY -Text "Tab: Switch Focus | Enter: Select | R: Refresh | Q: Quit | F12: Debug Log" -ForegroundColor $subtleColor
                
            } catch {
                Write-Log -Level Error -Message "Dashboard Render error: $_" -Data $_
                Write-BufferString -X 2 -Y 2 -Text "Error rendering dashboard: $_" -ForegroundColor Red
            }
        }
        
        HandleInput = {
            param($self, $Key)
            
            try {
                $services = $global:Services
                if (-not $services) {
                    return $false
                }
                
                # Check keybinding service
                $action = & $services.Keybindings.HandleKey -self $services.Keybindings -KeyInfo $Key
                
                switch ($action) {
                    "App.Refresh" { 
                        & $services.Store.Dispatch -self $services.Store -actionName "DASHBOARD_REFRESH"
                        return $true
                    }
                    "App.DebugLog" {
                        & $services.Navigation.GoTo -self $services.Navigation -Path "/log"
                        return $true
                    }
                    "App.Quit" {
                        return "Quit"
                    }
                    "App.Back" {
                        return "Quit"  # Dashboard is root, so back = quit
                    }
                }
                
                # Number keys for quick navigation
                if ($Key.KeyChar -ge '1' -and $Key.KeyChar -le '6') {
                    $index = [int]$Key.KeyChar.ToString() - 1
                    $routes = @("/time-entry", "/timer/start", "/tasks", "/projects", "/reports", "/settings")
                    if ($index -ge 0 -and $index -lt $routes.Count) {
                        & $services.Navigation.GoTo -self $services.Navigation -Path $routes[$index]
                        return $true
                    }
                }
                
                return $false
                
            } catch {
                Write-Log -Level Error -Message "HandleInput error: $_" -Data $_
                return $false
            }
        }
        
        OnExit = {
            param($self)
            
            Write-Log -Level Debug -Message "Dashboard screen exiting"
            
            # Properly stop the timer AND unregister the event handler
            if ($self._refreshTimer) {
                $self._refreshTimer.Stop()
                $self._refreshTimer.Dispose()
            }
            if ($self._timerSubscription) {
                Unregister-Event -SubscriptionId $self._timerSubscription.Id -ErrorAction SilentlyContinue
                $self._timerSubscription = $null
            }
            
            # Unsubscribe from store updates
            $services = $global:Services
            if ($services -and $services.Store) {
                foreach ($subId in $self._subscriptions) {
                    & $services.Store.Unsubscribe -self $services.Store -subId $subId
                }
            }
        }
        
        OnResume = {
            param($self)
            
            Write-Log -Level Debug -Message "Dashboard screen resuming"
            
            # Force complete redraw
            if ($global:TuiState -and $global:TuiState.RenderStats) {
                $global:TuiState.RenderStats.FrameCount = 0
            }
            
            # Refresh data
            $services = $global:Services
            if ($services -and $services.Store) {
                & $services.Store.Dispatch -self $services.Store -actionName "DASHBOARD_REFRESH"
            }
            
            Request-TuiRefresh
        }
    }
    
    return $screen
}

Export-ModuleMember -Function Get-DashboardScreen
@{
    # Module manifest for app-store service
    RootModule = 'app-store.psm1'
    ModuleVersion = '1.0.0'
    GUID = 'a1b2c3d4-5e6f-7a8b-9c0d-1e2f3a4b5c6d'
    Author = 'PMC Terminal Team'
    CompanyName = 'PMC Terminal'
    Copyright = '(c) 2025 PMC Terminal. All rights reserved.'
    Description = 'Centralized state management service using Redux-like pattern for PMC Terminal'
    
    # Minimum PowerShell version
    PowerShellVersion = '5.1'
    
    # Functions to export
    FunctionsToExport = @('Initialize-AppStore')
    
    # Variables to export
    VariablesToExport = @()
    
    # Aliases to export
    AliasesToExport = @()
    
    # Cmdlets to export
    CmdletsToExport = @()
    
    # Required modules
    RequiredModules = @(
        @{ ModuleName = 'tui-framework'; ModuleVersion = '1.0.0' }
    )
    
    # Module dependencies that must be loaded
    NestedModules = @()
    
    # Private data
    PrivateData = @{
        PSData = @{
            Tags = @('StateManagement', 'Redux', 'TUI', 'PMC')
            ProjectUri = 'https://github.com/pmc-terminal/pmc-terminal'
            ReleaseNotes = 'Initial release of centralized state management service'
        }
    }
}
# FILE: services/app-store.psm1
# PURPOSE: Provides a single, reactive source of truth for all shared application state using a Redux-like pattern.

function Initialize-AppStore {
    param(
        [hashtable]$InitialData = @{},
        [bool]$EnableDebugLogging = $false
    )
    
    # Ensure Create-TuiState exists
    if (-not (Get-Command -Name "Create-TuiState" -ErrorAction SilentlyContinue)) {
        throw "Create-TuiState not found. Ensure tui-framework.psm1 is loaded first."
    }
    
    $store = @{
        _state = (Create-TuiState -InitialState $InitialData)
        _actions = @{}
        _middleware = @()
        _history = @()  # For time-travel debugging
        _enableDebugLogging = $EnableDebugLogging
        
        GetState = { 
            param($self, [string]$path = $null) 
            if ([string]::IsNullOrEmpty($path)) {
                return (& $self._state.GetValue)
            }
            return (& $self._state.GetValue -Path $path)
        }
        
        Subscribe = { 
            param($self, [string]$path, [scriptblock]$handler) 
            if (-not $handler) { throw "Handler scriptblock is required for Subscribe" }
            return (& $self._state.Subscribe -Path $path -Handler $handler)
        }
        
        Unsubscribe = { 
            param($self, $subId) 
            if ($subId) { & $self._state.Unsubscribe -SubscriptionId $subId }
        }
        
        RegisterAction = { 
            param($self, [string]$actionName, [scriptblock]$scriptBlock) 
            if ([string]::IsNullOrWhiteSpace($actionName)) { throw "Action name cannot be empty" }
            if (-not $scriptBlock) { throw "Script block is required for action '$actionName'" }
            $self._actions[$actionName] = $scriptBlock 
            if ($self._enableDebugLogging) { Write-Log -Level Debug -Message "Registered action: $actionName" }
        }
        
        AddMiddleware = {
            param($self, [scriptblock]$middleware)
            $self._middleware += $middleware
        }
        
        Dispatch = {
            param($self, [string]$actionName, $payload = $null)
            
            if ([string]::IsNullOrWhiteSpace($actionName)) { return @{ Success = $false; Error = "Action name cannot be empty" } }
            
            $action = @{ Type = $actionName; Payload = $payload; Timestamp = [DateTime]::UtcNow }
            
            foreach ($mw in $self._middleware) {
                if ($null -ne $mw) {
                    $action = & $mw -Action $action -Store $self
                    if (-not $action) { return @{ Success = $false; Error = "Action cancelled by middleware" } }
                }
            }
            
            if (-not $self._actions.ContainsKey($actionName)) {
                if ($self._enableDebugLogging) { Write-Log -Level Warning -Message "Action '$actionName' not found." }
                return @{ Success = $false; Error = "Action '$actionName' not registered." }
            }
            
            if ($self._enableDebugLogging) { Write-Log -Level Debug -Message "Dispatching action '$actionName'" -Data $payload }
            
            try {
                $previousState = & $self.GetState -self $self
                
                $actionContext = @{
                    GetState = { & $self.GetState -self $self }
                    UpdateState = { param($updates) & $self._updateState -self $self -updates $updates }
                    Dispatch = { param($name, $p) & $self.Dispatch -self $self -actionName $name -payload $p }
                }
                
                & $self._actions[$actionName] -Context $actionContext -Payload $payload
                
                if ($self._history.Count -gt 100) { $self._history = $self._history[-100..-1] }
                $self._history += @{ Action = $action; PreviousState = $previousState; NextState = (& $self.GetState -self $self) }
                
                return @{ Success = $true }
            } 
            catch {
                if ($self._enableDebugLogging) { Write-Log -Level Error -Message "Error in action handler '$actionName'" -Data $_ }
                return @{ Success = $false; Error = $_.ToString() }
            }
        }
        
        _updateState = { 
            param($self, [hashtable]$updates)
            if ($updates) { & $self._state.Update -Updates $updates }
        }
        
        GetHistory = { param($self) ; return $self._history }
        
        RestoreState = {
            param($self, [int]$stepsBack = 1)
            if ($stepsBack -gt $self._history.Count) { throw "Cannot go back $stepsBack steps. Only $($self._history.Count) actions in history." }
            $targetState = $self._history[-$stepsBack].PreviousState
            # This call is correct because it calls another method on the store itself.
            & $self._updateState -self $self -updates $targetState
        }
    }
    
    # Register built-in actions
    & $store.RegisterAction -self $store -actionName "RESET_STATE" -scriptBlock {
        param($Context, $Payload)
        $Context.UpdateState($InitialData)
    }
    
    & $store.RegisterAction -self $store -actionName "UPDATE_STATE" -scriptBlock {
        param($Context, $Payload)
        if ($Payload -is [hashtable]) {
            $Context.UpdateState($Payload)
        }
    }
    
    return $store
}

Export-ModuleMember -Function "Initialize-AppStore"
@{
    # Module manifest for keybindings service
    RootModule = 'keybindings.psm1'
    ModuleVersion = '1.0.0'
    GUID = 'c3d4e5f6-7a8b-9c0d-1e2f-3a4b5c6d7e8f'
    Author = 'PMC Terminal Team'
    CompanyName = 'PMC Terminal'
    Copyright = '(c) 2025 PMC Terminal. All rights reserved.'
    Description = 'Centralized keybinding management service with context support for PMC Terminal'
    
    # Minimum PowerShell version
    PowerShellVersion = '5.1'
    
    # Functions to export
    FunctionsToExport = @('Initialize-KeybindingService')
    
    # Variables to export
    VariablesToExport = @()
    
    # Aliases to export
    AliasesToExport = @()
    
    # Cmdlets to export
    CmdletsToExport = @()
    
    # Required modules
    RequiredModules = @()
    
    # Module dependencies that must be loaded
    NestedModules = @()
    
    # Private data
    PrivateData = @{
        PSData = @{
            Tags = @('Keybindings', 'Input', 'TUI', 'PMC')
            ProjectUri = 'https://github.com/pmc-terminal/pmc-terminal'
            ReleaseNotes = 'Initial release of keybinding service with context-aware bindings and chord support'
        }
    }
}
# FILE: services/keybindings.psm1
# PURPOSE: Centralizes keybinding logic to make them configurable and declarative.

function Initialize-KeybindingService {
    param(
        [hashtable]$CustomBindings = @{},
        [bool]$EnableChords = $false  # For future multi-key sequences
    )
    
    # Default keybindings - can be overridden
    $defaultKeyMap = @{
        # Application-level
        "App.Quit" = @{ Key = 'Q'; Modifiers = @() }
        "App.ForceQuit" = @{ Key = 'Q'; Modifiers = @('Ctrl') }
        "App.Back" = @{ Key = [ConsoleKey]::Escape; Modifiers = @() }
        "App.Refresh" = @{ Key = 'R'; Modifiers = @() }
        "App.DebugLog" = @{ Key = [ConsoleKey]::F12; Modifiers = @() }
        "App.Help" = @{ Key = [ConsoleKey]::F1; Modifiers = @() }
        
        # List operations
        "List.New" = @{ Key = 'N'; Modifiers = @() }
        "List.Edit" = @{ Key = 'E'; Modifiers = @() }
        "List.Delete" = @{ Key = 'D'; Modifiers = @() }
        "List.Toggle" = @{ Key = [ConsoleKey]::Spacebar; Modifiers = @() }
        "List.SelectAll" = @{ Key = 'A'; Modifiers = @('Ctrl') }
        
        # Navigation
        "Nav.Up" = @{ Key = [ConsoleKey]::UpArrow; Modifiers = @() }
        "Nav.Down" = @{ Key = [ConsoleKey]::DownArrow; Modifiers = @() }
        "Nav.Left" = @{ Key = [ConsoleKey]::LeftArrow; Modifiers = @() }
        "Nav.Right" = @{ Key = [ConsoleKey]::RightArrow; Modifiers = @() }
        "Nav.PageUp" = @{ Key = [ConsoleKey]::PageUp; Modifiers = @() }
        "Nav.PageDown" = @{ Key = [ConsoleKey]::PageDown; Modifiers = @() }
        "Nav.Home" = @{ Key = [ConsoleKey]::Home; Modifiers = @() }
        "Nav.End" = @{ Key = [ConsoleKey]::End; Modifiers = @() }
        
        # Quick navigation (number keys)
        "QuickNav.1" = @{ Key = '1'; Modifiers = @() }
        "QuickNav.2" = @{ Key = '2'; Modifiers = @() }
        "QuickNav.3" = @{ Key = '3'; Modifiers = @() }
        "QuickNav.4" = @{ Key = '4'; Modifiers = @() }
        "QuickNav.5" = @{ Key = '5'; Modifiers = @() }
        "QuickNav.6" = @{ Key = '6'; Modifiers = @() }
        "QuickNav.7" = @{ Key = '7'; Modifiers = @() }
        "QuickNav.8" = @{ Key = '8'; Modifiers = @() }
        "QuickNav.9" = @{ Key = '9'; Modifiers = @() }
        
        # Form operations
        "Form.Submit" = @{ Key = [ConsoleKey]::Enter; Modifiers = @('Ctrl') }
        "Form.Cancel" = @{ Key = [ConsoleKey]::Escape; Modifiers = @() }
        "Form.Clear" = @{ Key = 'C'; Modifiers = @('Ctrl', 'Shift') }
        
        # Text editing
        "Edit.Cut" = @{ Key = 'X'; Modifiers = @('Ctrl') }
        "Edit.Copy" = @{ Key = 'C'; Modifiers = @('Ctrl') }
        "Edit.Paste" = @{ Key = 'V'; Modifiers = @('Ctrl') }
        "Edit.Undo" = @{ Key = 'Z'; Modifiers = @('Ctrl') }
        "Edit.Redo" = @{ Key = 'Y'; Modifiers = @('Ctrl') }
    }
    
    # Merge custom bindings
    $keyMap = $defaultKeyMap
    foreach ($action in $CustomBindings.Keys) {
        $keyMap[$action] = $CustomBindings[$action]
    }
    
    $service = @{
        _keyMap = $keyMap
        _enableChords = $EnableChords
        _chordBuffer = @()
        _chordTimeout = 1000  # milliseconds
        _lastKeyTime = [DateTime]::MinValue
        _contextStack = @()  # For context-specific bindings
        _globalHandlers = @{}  # Action name -> handler scriptblock
        
        IsAction = {
            param(
                $self,
                [string]$ActionName, 
                [System.ConsoleKeyInfo]$KeyInfo,
                [string]$Context = $null
            )
            
            if ([string]::IsNullOrWhiteSpace($ActionName)) { return $false }
            
            # Check context-specific binding first
            $contextKey = if ($Context) { "$Context.$ActionName" } else { $null }
            if ($contextKey -and $self._keyMap.ContainsKey($contextKey)) {
                return (& $self._matchesBinding -self $self -binding $self._keyMap[$contextKey] -keyInfo $KeyInfo)
            }
            
            # Check global binding
            if (-not $self._keyMap.ContainsKey($ActionName)) { return $false }
            
            return (& $self._matchesBinding -self $self -binding $self._keyMap[$ActionName] -keyInfo $KeyInfo)
        }
        
        _matchesBinding = {
            param($self, $binding, $keyInfo)
            
            # Match key
            $keyMatches = $false
            if ($binding.Key -is [System.ConsoleKey]) {
                $keyMatches = $keyInfo.Key -eq $binding.Key
            }
            elseif ($binding.Key -is [string] -and $binding.Key.Length -eq 1) {
                $keyMatches = $keyInfo.KeyChar.ToString().Equals($binding.Key, [System.StringComparison]::InvariantCultureIgnoreCase)
            }
            
            if (-not $keyMatches) { return $false }
            
            # Match modifiers
            $requiredModifiers = $binding.Modifiers ?? @()
            $hasCtrl = ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Control) -ne 0
            $hasAlt = ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Alt) -ne 0
            $hasShift = ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift) -ne 0
            
            $ctrlRequired = 'Ctrl' -in $requiredModifiers
            $altRequired = 'Alt' -in $requiredModifiers
            $shiftRequired = 'Shift' -in $requiredModifiers
            
            return ($hasCtrl -eq $ctrlRequired) -and 
                   ($hasAlt -eq $altRequired) -and 
                   ($hasShift -eq $shiftRequired)
        }
        
        GetBinding = {
            param($self, [string]$ActionName)
            return $self._keyMap[$ActionName]
        }
        
        SetBinding = {
            param($self, [string]$ActionName, $Key, [string[]]$Modifiers = @())
            $self._keyMap[$ActionName] = @{ Key = $Key; Modifiers = $Modifiers }
            Write-Log -Level Debug -Message "Set keybinding for '$ActionName': $Key + $($Modifiers -join '+')"
        }
        
        RemoveBinding = {
            param($self, [string]$ActionName)
            $self._keyMap.Remove($ActionName)
            Write-Log -Level Debug -Message "Removed keybinding for '$ActionName'"
        }
        
        GetBindingDescription = {
            param($self, [string]$ActionName)
            if (-not $self._keyMap.ContainsKey($ActionName)) { return $null }
            $binding = $self._keyMap[$ActionName]
            $keyStr = if ($binding.Key -is [System.ConsoleKey]) { $binding.Key.ToString() } else { $binding.Key.ToString().ToUpper() }
            if ($binding.Modifiers.Count -gt 0) { return "$($binding.Modifiers -join '+') + $keyStr" }
            return $keyStr
        }
        
        RegisterGlobalHandler = {
            param($self, [string]$ActionName, [scriptblock]$Handler)
            $self._globalHandlers[$ActionName] = $Handler
            Write-Log -Level Debug -Message "Registered global handler for '$ActionName'"
        }
        
        HandleKey = {
            param($self, [System.ConsoleKeyInfo]$KeyInfo, [string]$Context = $null)
            foreach ($action in $self._keyMap.Keys) {
                if ((& $self.IsAction -self $self -ActionName $action -KeyInfo $KeyInfo -Context $Context)) {
                    if ($self._globalHandlers.ContainsKey($action)) {
                        Write-Log -Level Debug -Message "Executing global handler for '$action'"
                        return (& $self._globalHandlers[$action] -KeyInfo $KeyInfo -Context $Context)
                    }
                    return $action
                }
            }
            return $null
        }
        
        PushContext = {
            param($self, [string]$Context)
            $self._contextStack += $Context
            Write-Log -Level Debug -Message "Pushed keybinding context: $Context"
        }
        
        PopContext = {
            param($self)
            if ($self._contextStack.Count -gt 0) {
                $context = $self._contextStack[-1]
                $self._contextStack = $self._contextStack[0..($self._contextStack.Count - 2)]
                Write-Log -Level Debug -Message "Popped keybinding context: $context"
                return $context
            }
            return $null
        }
        
        GetCurrentContext = {
            param($self)
            if ($self._contextStack.Count -gt 0) { return $self._contextStack[-1] }
            return $null
        }
        
        GetAllBindings = {
            param($self, [bool]$GroupByCategory = $false)
            if (-not $GroupByCategory) { return $self._keyMap }
            $grouped = @{}
            foreach ($action in $self._keyMap.Keys) {
                $parts = $action.Split('.')
                $category = if ($parts.Count -gt 1) { $parts[0] } else { "General" }
                if (-not $grouped.ContainsKey($category)) { $grouped[$category] = @{} }
                $grouped[$category][$action] = $self._keyMap[$action]
            }
            return $grouped
        }
        
        ExportBindings = {
            param($self, [string]$Path)
            $self._keyMap | ConvertTo-Json -Depth 3 | Out-File -FilePath $Path
            Write-Log -Level Info -Message "Exported keybindings to: $Path"
        }
        
        ImportBindings = {
            param($self, [string]$Path)
            if (Test-Path $Path) {
                $imported = Get-Content $Path | ConvertFrom-Json
                foreach ($prop in $imported.PSObject.Properties) {
                    $self._keyMap[$prop.Name] = @{
                        Key = $prop.Value.Key
                        Modifiers = $prop.Value.Modifiers
                    }
                }
                Write-Log -Level Info -Message "Imported keybindings from: $Path"
            }
        }
    }
    
    return $service
}

Export-ModuleMember -Function "Initialize-KeybindingService"
@{
    # Module manifest for navigation service
    RootModule = 'navigation.psm1'
    ModuleVersion = '1.0.0'
    GUID = 'b2c3d4e5-6f7a-8b9c-0d1e-2f3a4b5c6d7e'
    Author = 'PMC Terminal Team'
    CompanyName = 'PMC Terminal'
    Copyright = '(c) 2025 PMC Terminal. All rights reserved.'
    Description = 'Centralized navigation service with routing and breadcrumbs for PMC Terminal'
    
    # Minimum PowerShell version
    PowerShellVersion = '5.1'
    
    # Functions to export
    FunctionsToExport = @('Initialize-NavigationService')
    
    # Variables to export
    VariablesToExport = @()
    
    # Aliases to export
    AliasesToExport = @()
    
    # Cmdlets to export
    CmdletsToExport = @()
    
    # Required modules
    RequiredModules = @(
        @{ ModuleName = 'tui-engine-v2'; ModuleVersion = '1.0.0' },
        @{ ModuleName = 'dialog-system'; ModuleVersion = '1.0.0' }
    )
    
    # Module dependencies that must be loaded
    NestedModules = @()
    
    # Private data
    PrivateData = @{
        PSData = @{
            Tags = @('Navigation', 'Routing', 'TUI', 'PMC')
            ProjectUri = 'https://github.com/pmc-terminal/pmc-terminal'
            ReleaseNotes = 'Initial release of navigation service with route guards and breadcrumbs'
        }
    }
}
# FILE: services/navigation.psm1
# PURPOSE: Decouples screens by managing all navigation through a centralized route map.

function Initialize-NavigationService {
    param(
        [hashtable]$CustomRoutes = @{},
        [bool]$EnableBreadcrumbs = $true
    )
    
    # Default routes - can be overridden by CustomRoutes
    $defaultRoutes = @{
        "/dashboard" = @{ 
            Factory = { Get-DashboardScreen }
            Title = "Dashboard"
            RequiresAuth = $false
        }
        "/tasks" = @{ 
            Factory = { Get-TaskManagementScreen }
            Title = "Task Management"
            RequiresAuth = $false
        }
        "/timer/start" = @{ 
            Factory = { Get-TimerStartScreen }
            Title = "Timer"
            RequiresAuth = $false
        }
        "/timer/manage" = @{
            Factory = { Get-TimerManagementScreen }
            Title = "Timer Management"
            RequiresAuth = $false
        }
        "/reports" = @{ 
            Factory = { Get-ReportsScreen }
            Title = "Reports"
            RequiresAuth = $false
        }
        "/settings" = @{ 
            Factory = { Get-SettingsScreen }
            Title = "Settings"
            RequiresAuth = $false
        }
        "/projects" = @{ 
            Factory = { Get-ProjectManagementScreen }
            Title = "Projects"
            RequiresAuth = $false
        }
        "/log" = @{ 
            Factory = { Get-DebugLogScreen }
            Title = "Debug Log"
            RequiresAuth = $false
        }
    }
    
    # Merge custom routes
    $routes = $defaultRoutes
    foreach ($key in $CustomRoutes.Keys) {
        $routes[$key] = $CustomRoutes[$key]
    }
    
    $service = @{
        _routes = $routes
        _history = @()  # Navigation history for back button
        _breadcrumbs = @()  # For UI breadcrumb display
        _beforeNavigate = @()  # Navigation guards
        _afterNavigate = @()  # Navigation hooks
        
        GoTo = {
            param(
                $self,
                [string]$Path,
                [hashtable]$Params = @{}
            )
            
            if ([string]::IsNullOrWhiteSpace($Path)) {
                Write-Log -Level Error -Message "Navigation path cannot be empty"
                return $false
            }
            
            # Normalize path
            if (-not $Path.StartsWith("/")) { $Path = "/$Path" }
            
            # Check if route exists
            if (-not $self._routes.ContainsKey($Path)) {
                $availableRoutes = ($self._routes.Keys | Sort-Object) -join ", "
                $msg = "Route not found: $Path. Available routes: $availableRoutes"
                Write-Log -Level Error -Message $msg
                Show-AlertDialog -Title "Navigation Error" -Message "The screen '$Path' does not exist."
                return $false
            }
            
            $route = $self._routes[$Path]
            
            # Run before navigation guards
            foreach ($guard in $self._beforeNavigate) {
                $canNavigate = & $guard -Path $Path -Route $route -Params $Params
                if (-not $canNavigate) {
                    Write-Log -Level Debug -Message "Navigation to '$Path' cancelled by guard"
                    return $false
                }
            }
            
            # Check authentication if required
            if ($route.RequiresAuth -and -not (& $self._checkAuth -self $self)) {
                Write-Log -Level Warning -Message "Navigation to '$Path' requires authentication"
                Show-AlertDialog -Title "Access Denied" -Message "You must be logged in to access this screen."
                return $false
            }
            
            try {
                $screen = & $route.Factory
                if (-not $screen) { throw "Screen factory returned null for route '$Path'" }
                if ($screen.SetParams -and $Params.Count -gt 0) { & $screen.SetParams -self $screen -Params $Params }
                
                $self._history += @{ Path = $Path; Timestamp = [DateTime]::UtcNow; Params = $Params }
                if ($EnableBreadcrumbs) { $self._breadcrumbs += @{ Path = $Path; Title = $route.Title ?? $Path } }
                
                Push-Screen -Screen $screen
                
                foreach ($hook in $self._afterNavigate) { & $hook -Path $Path -Screen $screen }
                
                Write-Log -Level Info -Message "Navigated to: $Path"
                return $true
            }
            catch {
                Write-Log -Level Error -Message "Failed to navigate to '$Path': $_"
                Show-AlertDialog -Title "Navigation Error" -Message "Failed to load screen: $_"
                return $false
            }
        }
        
        Back = { 
            param($self, [int]$Steps = 1)
            for ($i = 0; $i -lt $Steps; $i++) {
                if ($global:TuiState.ScreenStack.Count -le 1) {
                    Write-Log -Level Debug -Message "Cannot go back - at root screen"
                    return $false
                }
                Pop-Screen
                if ($EnableBreadcrumbs -and $self._breadcrumbs.Count -gt 0) {
                    $self._breadcrumbs = $self._breadcrumbs[0..($self._breadcrumbs.Count - 2)]
                }
            }
            return $true
        }
        
        GetCurrentPath = {
            param($self)
            if ($self._history.Count -eq 0) { return "/" }
            return $self._history[-1].Path
        }
        
        GetBreadcrumbs = {
            param($self)
            return $self._breadcrumbs
        }
        
        AddRoute = {
            param($self, [string]$Path, [hashtable]$RouteConfig)
            if (-not $RouteConfig.Factory) { throw "Route must have a Factory scriptblock" }
            $self._routes[$Path] = $RouteConfig
            Write-Log -Level Debug -Message "Added route: $Path"
        }
        
        RemoveRoute = {
            param($self, [string]$Path)
            $self._routes.Remove($Path)
            Write-Log -Level Debug -Message "Removed route: $Path"
        }
        
        AddBeforeNavigateGuard = {
            param($self, [scriptblock]$Guard)
            $self._beforeNavigate += $Guard
        }
        
        AddAfterNavigateHook = {
            param($self, [scriptblock]$Hook)
            $self._afterNavigate += $Hook
        }
        
        _checkAuth = {
            param($self)
            # Placeholder for authentication check
            return $true
        }
        
        GetRoutes = {
            param($self)
            return $self._routes.Keys | Sort-Object
        }
        
        IsValidRoute = {
            param($self, [string]$Path)
            return $self._routes.ContainsKey($Path)
        }
    }
    
    return $service
}

Export-ModuleMember -Function "Initialize-NavigationService"
# FILE: utilities/focus-manager.psm1
# PURPOSE: Provides the single source of truth for component focus management with scope support.

$script:Focus = @{
    FocusedComponent = $null 
    TabOrder = @()
    ActiveScope = $null
    History = @()  # Focus history for debugging
    ScopeStack = @()  # For nested focus scopes
}

function global:Request-Focus {
    param(
        [hashtable]$Component,
        [bool]$UpdateTabOrder = $false,
        [string]$Reason = "Direct"
    )
    
    # Validate component
    if ($Component -and -not $Component.IsFocusable) {
        Write-Log -Level Debug -Message "Cannot focus non-focusable component: $($Component.Name ?? $Component.Type)"
        return $false
    }
    
    if ($Component -and -not $Component.Visible) {
        Write-Log -Level Debug -Message "Cannot focus invisible component: $($Component.Name ?? $Component.Type)"
        return $false
    }
    
    # Handle losing focus on previous component
    $oldFocused = $script:Focus.FocusedComponent
    if ($oldFocused -and ($oldFocused -ne $Component)) {
        $oldFocused.IsFocused = $false
        
        if ($oldFocused.OnBlur) {
            try {
                & $oldFocused.OnBlur -self $oldFocused
            } catch {
                Write-Log -Level Error -Message "Error in OnBlur handler" -Data $_
            }
        }
        
        # Fire blur event
        if (Get-Command -Name "Publish-Event" -ErrorAction SilentlyContinue) {
            Publish-Event -EventName "Component.Blur" -Data @{ Component = $oldFocused }
        }
    }
    
    # Update focus scope if needed
    $newScope = if ($Component) { Get-FocusScope -Component $Component } else { $null }
    if ($newScope -ne $script:Focus.ActiveScope) {
        # Leave old scope
        if ($script:Focus.ActiveScope -and $script:Focus.ActiveScope.OnLeaveFocusScope) {
            try {
                & $script:Focus.ActiveScope.OnLeaveFocusScope -self $script:Focus.ActiveScope
            } catch {
                Write-Log -Level Error -Message "Error in OnLeaveFocusScope handler" -Data $_
            }
        }
        
        $script:Focus.ActiveScope = $newScope
        
        # Enter new scope
        if ($newScope -and $newScope.OnEnterFocusScope) {
            try {
                & $newScope.OnEnterFocusScope -self $newScope
            } catch {
                Write-Log -Level Error -Message "Error in OnEnterFocusScope handler" -Data $_
            }
        }
    }
    
    # Set new focus
    $script:Focus.FocusedComponent = $Component
    
    # Update global state if available
    if ($global:TuiState) {
        $global:TuiState.FocusedComponent = $Component
    }
    
    # Update history
    $script:Focus.History += @{
        Component = $Component
        Timestamp = [DateTime]::UtcNow
        Reason = $Reason
    }
    if ($script:Focus.History.Count -gt 50) {
        $script:Focus.History = $script:Focus.History[-50..-1]
    }
    
    if ($Component) {
        $Component.IsFocused = $true
        
        # Call focus handler
        if ($Component.OnFocus) {
            try {
                & $Component.OnFocus -self $Component
            } catch {
                Write-Log -Level Error -Message "Error in OnFocus handler" -Data $_
            }
        }
        
        # Fire focus event
        if (Get-Command -Name "Publish-Event" -ErrorAction SilentlyContinue) {
            Publish-Event -EventName "Component.Focus" -Data @{ Component = $Component }
        }
        
        # Update tab order if requested
        if ($UpdateTabOrder) {
            Update-TabOrder -FocusedComponent $Component
        }
    }
    
    # Request screen refresh
    if (Get-Command -Name "Request-TuiRefresh" -ErrorAction SilentlyContinue) {
        Request-TuiRefresh
    }
    
    if ($Component) {
        Write-Log -Level Debug -Message "Focused: $($Component.Name ?? $Component.Type) (Reason: $Reason)"
    } else {
        Write-Log -Level Debug -Message "Cleared focus (Reason: $Reason)"
    }
    
    return $true
}

function global:Clear-Focus {
    Request-Focus -Component $null -Reason "Clear"
}

function global:Move-Focus {
    param(
        [bool]$Reverse = $false,
        [bool]$Wrap = $true
    )
    
    # Check if active scope handles its own focus movement
    if ($script:Focus.ActiveScope -and $script:Focus.ActiveScope.HandleScopedFocus) {
        $handled = & $script:Focus.ActiveScope.HandleScopedFocus -self $script:Focus.ActiveScope -Reverse $Reverse
        if ($handled) {
            return $true
        }
    }
    
    # No focusable components
    if ($script:Focus.TabOrder.Count -eq 0) {
        Write-Log -Level Debug -Message "No focusable components in tab order"
        return $false
    }
    
    # Find current index
    $currentIndex = [array]::IndexOf($script:Focus.TabOrder, $script:Focus.FocusedComponent)
    
    # If no current focus, focus first/last based on direction
    if ($currentIndex -eq -1) {
        $targetIndex = if ($Reverse) { $script:Focus.TabOrder.Count - 1 } else { 0 }
        Request-Focus -Component $script:Focus.TabOrder[$targetIndex] -Reason "TabNavigation"
        return $true
    }
    
    # Calculate next index
    if ($Reverse) {
        $nextIndex = $currentIndex - 1
        if ($nextIndex -lt 0) {
            $nextIndex = if ($Wrap) { $script:Focus.TabOrder.Count - 1 } else { 0 }
        }
    } else {
        $nextIndex = $currentIndex + 1
        if ($nextIndex -ge $script:Focus.TabOrder.Count) {
            $nextIndex = if ($Wrap) { 0 } else { $script:Focus.TabOrder.Count - 1 }
        }
    }
    
    # Skip invisible or disabled components
    $attempts = 0
    while ($attempts -lt $script:Focus.TabOrder.Count) {
        $candidate = $script:Focus.TabOrder[$nextIndex]
        
        if ($candidate.Visible -and $candidate.IsFocusable -and 
            (-not $candidate.PSObject.Properties['IsEnabled'] -or $candidate.IsEnabled)) {
            Request-Focus -Component $candidate -Reason "TabNavigation"
            return $true
        }
        
        # Move to next candidate
        if ($Reverse) {
            $nextIndex--
            if ($nextIndex -lt 0) {
                $nextIndex = if ($Wrap) { $script:Focus.TabOrder.Count - 1 } else { 0 }
            }
        } else {
            $nextIndex++
            if ($nextIndex -ge $script:Focus.TabOrder.Count) {
                $nextIndex = if ($Wrap) { 0 } else { $script:Focus.TabOrder.Count - 1 }
            }
        }
        
        $attempts++
    }
    
    Write-Log -Level Debug -Message "No valid focus target found"
    return $false
}

function global:Get-FocusedComponent {
    return $script:Focus.FocusedComponent
}

function global:Get-FocusHistory {
    return $script:Focus.History
}

# --- FIX: REMOVED 'private:' ---
function Get-FocusScope {
    param($Component)
    
    $current = $Component
    while ($current) {
        if ($current.IsFocusScope) {
            return $current
        }
        $current = $current.Parent
    }
    
    return $null
}

function global:Push-FocusScope {
    param([hashtable]$Scope)
    
    if (-not $Scope.IsFocusScope) {
        $Scope.IsFocusScope = $true
    }
    
    $script:Focus.ScopeStack += $Scope
    $script:Focus.ActiveScope = $Scope
    
    Write-Log -Level Debug -Message "Pushed focus scope: $($Scope.Name ?? $Scope.Type)"
}

function global:Pop-FocusScope {
    if ($script:Focus.ScopeStack.Count -eq 0) {
        return $null
    }
    
    $poppedScope = $script:Focus.ScopeStack[-1]
    $script:Focus.ScopeStack = $script:Focus.ScopeStack[0..($script:Focus.ScopeStack.Count - 2)]
    
    # Restore previous scope
    if ($script:Focus.ScopeStack.Count -gt 0) {
        $script:Focus.ActiveScope = $script:Focus.ScopeStack[-1]
    } else {
        $script:Focus.ActiveScope = $null
    }
    
    Write-Log -Level Debug -Message "Popped focus scope: $($poppedScope.Name ?? $poppedScope.Type)"
    
    return $poppedScope
}

# --- FIX: REMOVED 'private:' ---
function Update-TabOrder {
    param($FocusedComponent)
    
    # If component is already in tab order, no need to update
    if ($FocusedComponent -in $script:Focus.TabOrder) {
        return
    }
    
    # Rebuild tab order
    Register-ScreenForFocus -Screen $global:TuiState.CurrentScreen
}

# --- FIX: REMOVED 'private:' ---
function Register-ScreenForFocus {
    param($Screen)
    
    $script:Focus.TabOrder = @()
    $script:Focus.ActiveScope = $null
    
    if (-not $Screen) {
        Request-Focus -Component $null -Reason "NoScreen"
        return
    }
    
    # Find all focusable components
    $focusableComponents = @()
    
    $FindFocusable = $null
    $FindFocusable = {
        param($component, $depth = 0)
        
        if (-not $component) { return }
        
        # Add focusable components
        if ($component.IsFocusable -and $component.Visible) {
            $focusableComponents += @{
                Component = $component
                Depth = $depth
                TabIndex = $component.TabIndex ?? 0
                Position = @{
                    Y = $component.Y ?? 0
                    X = $component.X ?? 0
                }
            }
        }
        
        # Process panel children
        if ($component.Children) {
            foreach ($child in $component.Children) {
                & $FindFocusable -component $child -depth ($depth + 1)
            }
        }
        
        # Process named children (for backward compatibility)
        if ($component.Components) {
            foreach ($child in $component.Components.Values) {
                & $FindFocusable -component $child -depth ($depth + 1)
            }
        }
    }.GetNewClosure()
    
    # Start from screen components
    if ($Screen.Components) {
        foreach ($comp in $Screen.Components.Values) {
            & $FindFocusable -component $comp
        }
    }
    
    # Sort by TabIndex, then by position (top to bottom, left to right)
    $script:Focus.TabOrder = $focusableComponents | 
        Sort-Object { $_.TabIndex }, { $_.Position.Y }, { $_.Position.X } |
        ForEach-Object { $_.Component }
    
    Write-Log -Level Debug -Message "Registered $($script:Focus.TabOrder.Count) focusable components"
    
    # Focus first component if none focused
    if ($script:Focus.TabOrder.Count -gt 0 -and -not ($script:Focus.FocusedComponent -in $script:Focus.TabOrder)) {
        Request-Focus -Component $script:Focus.TabOrder[0] -Reason "InitialFocus"
    } elseif ($script:Focus.TabOrder.Count -eq 0) {
        Request-Focus -Component $null -Reason "NoFocusableComponents"
    }
}

function global:Initialize-FocusManager {
    # Subscribe to screen events
    if (Get-Command -Name "Subscribe-Event" -ErrorAction SilentlyContinue) {
        Subscribe-Event -EventName "Screen.Pushed" -Handler {
            param($Event)
            Register-ScreenForFocus -Screen $Event.Data.Screen
        }
        
        Subscribe-Event -EventName "Screen.Popped" -Handler {
            param($Event)
            # Clear focus scopes
            $script:Focus.ScopeStack = @()
            $script:Focus.ActiveScope = $null
            
            # Re-register for new top screen
            if ($global:TuiState -and $global:TuiState.CurrentScreen) {
                Register-ScreenForFocus -Screen $global:TuiState.CurrentScreen
            }
        }
        
        Subscribe-Event -EventName "Component.VisibilityChanged" -Handler {
            param($Event)
            $component = $Event.Data.Component
            
            # If hiding focused component, move focus
            if (-not $component.Visible -and $component -eq $script:Focus.FocusedComponent) {
                Move-Focus
            }
            
            # Update tab order if visibility changed
            if ($global:TuiState -and $global:TuiState.CurrentScreen) {
                Register-ScreenForFocus -Screen $global:TuiState.CurrentScreen
            }
        }
    }
    
    Write-Log -Level Info -Message "Focus Manager initialized"
}

# Utility functions for components
function global:Set-ComponentFocusable {
    param(
        [hashtable]$Component,
        [bool]$IsFocusable
    )
    
    $wasFocusable = $Component.IsFocusable
    $Component.IsFocusable = $IsFocusable
    
    # If making unfocusable and it's currently focused, clear focus
    if ($wasFocusable -and -not $IsFocusable -and $Component -eq $script:Focus.FocusedComponent) {
        Move-Focus
    }
    
    # Update tab order
    if ($global:TuiState -and $global:TuiState.CurrentScreen) {
        Register-ScreenForFocus -Screen $global:TuiState.CurrentScreen
    }
}

function global:Focus-NextInScope {
    param([hashtable]$Scope)
    
    if (-not $Scope -or -not $Scope.IsFocusScope) {
        return $false
    }
    
    # Find focusable children within scope
    $scopeFocusable = @()
    
    $FindScopeFocusable = {
        param($component)
        
        if ($component.IsFocusable -and $component.Visible) {
            $scopeFocusable += $component
        }
        
        if ($component.Children -and $component -ne $Scope) {
            foreach ($child in $component.Children) {
                & $FindScopeFocusable -component $child
            }
        }
    }
    
    & $FindScopeFocusable -component $Scope
    
    if ($scopeFocusable.Count -eq 0) {
        return $false
    }
    
    # Find current index
    $currentIndex = [array]::IndexOf($scopeFocusable, $script:Focus.FocusedComponent)
    $nextIndex = ($currentIndex + 1) % $scopeFocusable.Count
    
    Request-Focus -Component $scopeFocusable[$nextIndex] -Reason "ScopeNavigation"
    return $true
}

Export-ModuleMember -Function @(
    "Initialize-FocusManager",
    "Request-Focus", 
    "Clear-Focus",
    "Move-Focus",
    "Get-FocusedComponent",
    "Get-FocusHistory",
    "Push-FocusScope",
    "Pop-FocusScope",
    "Set-ComponentFocusable",
    "Focus-NextInScope"
)
# Layout Manager Utility Module
# Provides helper functions for component positioning and layout management

function global:New-TuiLayoutManager {
    <#
    .SYNOPSIS
    Creates a layout manager for organizing components within a container
    
    .DESCRIPTION
    The layout manager helps with automatic positioning, spacing, and alignment of components.
    It provides various layout modes: Stack, Grid, Dock, and Manual.
    
    .PARAMETER Container
    A hashtable with X, Y, Width, Height properties defining the container bounds
    
    .PARAMETER Mode
    Layout mode: 'Stack', 'Grid', 'Dock', or 'Manual'
    
    .EXAMPLE
    $layout = New-TuiLayoutManager -Container @{X=0; Y=0; Width=80; Height=25} -Mode 'Stack'
    $layout.Add($component1)
    $layout.Add($component2)
    $layout.Apply()
    #>
    param(
        [hashtable]$Container = @{ X = 0; Y = 0; Width = 80; Height = 25 },
        [string]$Mode = 'Manual',
        [hashtable]$Options = @{}
    )
    
    $manager = @{
        Container = $Container
        Mode = $Mode
        Components = @()
        Options = @{
            # Stack options
            Direction = $Options.Direction ?? 'Vertical'  # 'Vertical' or 'Horizontal'
            Spacing = $Options.Spacing ?? 1
            Padding = $Options.Padding ?? @{ Top = 0; Right = 0; Bottom = 0; Left = 0 }
            Alignment = $Options.Alignment ?? 'Left'  # 'Left', 'Center', 'Right'
            
            # Grid options
            Columns = $Options.Columns ?? 2
            RowHeight = $Options.RowHeight ?? 5
            ColumnWidth = $Options.ColumnWidth ?? 20
            
            # Dock options
            FillLast = $Options.FillLast ?? $true
        }
        
        # Methods
        Add = {
            param($Component, [hashtable]$LayoutProps = @{})
            $this = $args[-1]
            $this.Components += @{
                Component = $Component
                LayoutProps = $LayoutProps
            }
        }.GetNewClosure()
        
        Clear = {
            $this = $args[-1]
            $this.Components = @()
        }.GetNewClosure()
        
        Apply = {
            $this = $args[-1]
            switch ($this.Mode) {
                'Stack' { & $this.ApplyStackLayout }
                'Grid' { & $this.ApplyGridLayout }
                'Dock' { & $this.ApplyDockLayout }
                'Manual' { # Do nothing - components use their existing positions }
            }
        }.GetNewClosure()
        
        ApplyStackLayout = {
            $this = $args[-1]
            $x = $this.Container.X + $this.Options.Padding.Left
            $y = $this.Container.Y + $this.Options.Padding.Top
            $maxWidth = $this.Container.Width - $this.Options.Padding.Left - $this.Options.Padding.Right
            $maxHeight = $this.Container.Height - $this.Options.Padding.Top - $this.Options.Padding.Bottom
            
            foreach ($item in $this.Components) {
                $comp = $item.Component
                
                # Apply alignment
                switch ($this.Options.Alignment) {
                    'Center' { $comp.X = $x + [Math]::Floor(($maxWidth - $comp.Width) / 2) }
                    'Right' { $comp.X = $x + $maxWidth - $comp.Width }
                    default { $comp.X = $x }
                }
                
                if ($this.Options.Direction -eq 'Vertical') {
                    $comp.Y = $y
                    $y += $comp.Height + $this.Options.Spacing
                } else {
                    $comp.Y = $y
                    $x += $comp.Width + $this.Options.Spacing
                }
            }
        }.GetNewClosure()
        
        ApplyGridLayout = {
            $this = $args[-1]
            $startX = $this.Container.X + $this.Options.Padding.Left
            $startY = $this.Container.Y + $this.Options.Padding.Top
            $cols = $this.Options.Columns
            
            for ($i = 0; $i -lt $this.Components.Count; $i++) {
                $comp = $this.Components[$i].Component
                $row = [Math]::Floor($i / $cols)
                $col = $i % $cols
                
                $comp.X = $startX + ($col * ($this.Options.ColumnWidth + $this.Options.Spacing))
                $comp.Y = $startY + ($row * ($this.Options.RowHeight + $this.Options.Spacing))
                
                # Optionally constrain size to grid cell
                if ($this.Components[$i].LayoutProps.ConstrainToCell) {
                    $comp.Width = [Math]::Min($comp.Width, $this.Options.ColumnWidth)
                    $comp.Height = [Math]::Min($comp.Height, $this.Options.RowHeight)
                }
            }
        }.GetNewClosure()
        
        ApplyDockLayout = {
            $this = $args[-1]
            $remainingX = $this.Container.X
            $remainingY = $this.Container.Y
            $remainingWidth = $this.Container.Width
            $remainingHeight = $this.Container.Height
            
            # Process in order: Top, Bottom, Left, Right, Fill
            $dockOrder = @('Top', 'Bottom', 'Left', 'Right', 'Fill')
            
            foreach ($dock in $dockOrder) {
                $items = $this.Components | Where-Object { $_.LayoutProps.Dock -eq $dock }
                
                foreach ($item in $items) {
                    $comp = $item.Component
                    
                    switch ($dock) {
                        'Top' {
                            $comp.X = $remainingX
                            $comp.Y = $remainingY
                            $comp.Width = $remainingWidth
                            $remainingY += $comp.Height
                            $remainingHeight -= $comp.Height
                        }
                        'Bottom' {
                            $comp.X = $remainingX
                            $comp.Y = $remainingY + $remainingHeight - $comp.Height
                            $comp.Width = $remainingWidth
                            $remainingHeight -= $comp.Height
                        }
                        'Left' {
                            $comp.X = $remainingX
                            $comp.Y = $remainingY
                            $comp.Height = $remainingHeight
                            $remainingX += $comp.Width
                            $remainingWidth -= $comp.Width
                        }
                        'Right' {
                            $comp.X = $remainingX + $remainingWidth - $comp.Width
                            $comp.Y = $remainingY
                            $comp.Height = $remainingHeight
                            $remainingWidth -= $comp.Width
                        }
                        'Fill' {
                            $comp.X = $remainingX
                            $comp.Y = $remainingY
                            $comp.Width = $remainingWidth
                            $comp.Height = $remainingHeight
                        }
                    }
                }
            }
        }.GetNewClosure()
        
        # Helper to calculate required size
        GetRequiredSize = {
            $this = $args[-1]
            $width = 0
            $height = 0
            
            switch ($this.Mode) {
                'Stack' {
                    if ($this.Options.Direction -eq 'Vertical') {
                        $width = ($this.Components | ForEach-Object { $_.Component.Width } | Measure-Object -Maximum).Maximum
                        $height = ($this.Components | ForEach-Object { $_.Component.Height } | Measure-Object -Sum).Sum
                        $height += ($this.Components.Count - 1) * $this.Options.Spacing
                    } else {
                        $width = ($this.Components | ForEach-Object { $_.Component.Width } | Measure-Object -Sum).Sum
                        $width += ($this.Components.Count - 1) * $this.Options.Spacing
                        $height = ($this.Components | ForEach-Object { $_.Component.Height } | Measure-Object -Maximum).Maximum
                    }
                }
                'Grid' {
                    $cols = $this.Options.Columns
                    $rows = [Math]::Ceiling($this.Components.Count / $cols)
                    $width = $cols * $this.Options.ColumnWidth + ($cols - 1) * $this.Options.Spacing
                    $height = $rows * $this.Options.RowHeight + ($rows - 1) * $this.Options.Spacing
                }
            }
            
            $width += $this.Options.Padding.Left + $this.Options.Padding.Right
            $height += $this.Options.Padding.Top + $this.Options.Padding.Bottom
            
            return @{ Width = $width; Height = $height }
        }.GetNewClosure()
    }
    
    # Bind methods to the manager instance
    $manager.Add = $manager.Add.Invoke(@($manager))
    $manager.Clear = $manager.Clear.Invoke(@($manager))
    $manager.Apply = $manager.Apply.Invoke(@($manager))
    $manager.ApplyStackLayout = $manager.ApplyStackLayout.Invoke(@($manager))
    $manager.ApplyGridLayout = $manager.ApplyGridLayout.Invoke(@($manager))
    $manager.ApplyDockLayout = $manager.ApplyDockLayout.Invoke(@($manager))
    $manager.GetRequiredSize = $manager.GetRequiredSize.Invoke(@($manager))
    
    return $manager
}

function global:Center-Component {
    <#
    .SYNOPSIS
    Centers a component within a container
    #>
    param(
        [hashtable]$Component,
        [hashtable]$Container = @{ X = 0; Y = 0; Width = $global:TuiState.BufferWidth; Height = $global:TuiState.BufferHeight }
    )
    
    $Component.X = $Container.X + [Math]::Floor(($Container.Width - $Component.Width) / 2)
    $Component.Y = $Container.Y + [Math]::Floor(($Container.Height - $Component.Height) / 2)
}

function global:Align-Components {
    <#
    .SYNOPSIS
    Aligns multiple components horizontally or vertically
    #>
    param(
        [hashtable[]]$Components,
        [string]$Direction = 'Horizontal',  # 'Horizontal' or 'Vertical'
        [string]$Alignment = 'Center',      # 'Top', 'Middle', 'Bottom' for horizontal; 'Left', 'Center', 'Right' for vertical
        [int]$Spacing = 2
    )
    
    if ($Components.Count -eq 0) { return }
    
    if ($Direction -eq 'Horizontal') {
        # Calculate total width needed
        $totalWidth = ($Components | ForEach-Object { $_.Width } | Measure-Object -Sum).Sum
        $totalWidth += ($Components.Count - 1) * $Spacing
        
        # Starting X position
        $currentX = switch ($Alignment) {
            'Left' { 0 }
            'Right' { $global:TuiState.BufferWidth - $totalWidth }
            default { [Math]::Floor(($global:TuiState.BufferWidth - $totalWidth) / 2) }
        }
        
        # Position each component
        foreach ($comp in $Components) {
            $comp.X = $currentX
            $currentX += $comp.Width + $Spacing
        }
    } else {
        # Calculate total height needed
        $totalHeight = ($Components | ForEach-Object { $_.Height } | Measure-Object -Sum).Sum
        $totalHeight += ($Components.Count - 1) * $Spacing
        
        # Starting Y position
        $currentY = switch ($Alignment) {
            'Top' { 0 }
            'Bottom' { $global:TuiState.BufferHeight - $totalHeight }
            default { [Math]::Floor(($global:TuiState.BufferHeight - $totalHeight) / 2) }
        }
        
        # Position each component
        foreach ($comp in $Components) {
            $comp.Y = $currentY
            $currentY += $comp.Height + $Spacing
        }
    }
}

function global:Create-ComponentGrid {
    <#
    .SYNOPSIS
    Arranges components in a grid layout
    #>
    param(
        [hashtable[]]$Components,
        [int]$Columns = 2,
        [int]$StartX = 0,
        [int]$StartY = 0,
        [int]$CellWidth = 20,
        [int]$CellHeight = 5,
        [int]$HorizontalSpacing = 2,
        [int]$VerticalSpacing = 1
    )
    
    for ($i = 0; $i -lt $Components.Count; $i++) {
        $row = [Math]::Floor($i / $Columns)
        $col = $i % $Columns
        
        $Components[$i].X = $StartX + ($col * ($CellWidth + $HorizontalSpacing))
        $Components[$i].Y = $StartY + ($row * ($CellHeight + $VerticalSpacing))
    }
}

Export-ModuleMember -Function @(
    'New-TuiLayoutManager',
    'Center-Component',
    'Align-Components',
    'Create-ComponentGrid'
)
# Component Positioning Helper Module
# Provides utilities for easier component placement and relative positioning

function global:New-TuiPositioner {
    <#
    .SYNOPSIS
    Creates a positioning helper for managing component placement
    
    .DESCRIPTION
    The positioner helps calculate positions for components relative to each other
    and handles common layout patterns like rows, columns, and grids.
    
    .PARAMETER Container
    Defines the bounding container for positioning
    
    .EXAMPLE
    $pos = New-TuiPositioner -Container @{X=0; Y=0; Width=80; Height=25}
    $button1Pos = $pos.NextInRow(10, 3)  # Width=10, Height=3
    $button2Pos = $pos.NextInRow(10, 3)  # Automatically positioned after button1
    #>
    param(
        [hashtable]$Container = @{ X = 0; Y = 0; Width = 80; Height = 25 },
        [hashtable]$Options = @{}
    )
    
    $positioner = @{
        Container = $Container
        CurrentX = $Container.X + ($Options.PaddingLeft ?? 0)
        CurrentY = $Container.Y + ($Options.PaddingTop ?? 0)
        RowHeight = 0
        Options = @{
            Spacing = $Options.Spacing ?? 1
            PaddingTop = $Options.PaddingTop ?? 0
            PaddingRight = $Options.PaddingRight ?? 0
            PaddingBottom = $Options.PaddingBottom ?? 0
            PaddingLeft = $Options.PaddingLeft ?? 0
        }
        
        # Reset to start of container
        Reset = {
            $this.CurrentX = $this.Container.X + $this.Options.PaddingLeft
            $this.CurrentY = $this.Container.Y + $this.Options.PaddingTop
            $this.RowHeight = 0
        }
        
        # Move to next row
        NewRow = {
            $this.CurrentX = $this.Container.X + $this.Options.PaddingLeft
            $this.CurrentY += $this.RowHeight + $this.Options.Spacing
            $this.RowHeight = 0
        }
        
        # Get next position in current row
        NextInRow = {
            param([int]$Width, [int]$Height)
            
            # Check if component fits in current row
            $maxX = $this.Container.X + $this.Container.Width - $this.Options.PaddingRight
            if (($this.CurrentX + $Width) -gt $maxX) {
                & $this.NewRow
            }
            
            $position = @{
                X = $this.CurrentX
                Y = $this.CurrentY
                Width = $Width
                Height = $Height
            }
            
            # Update position for next component
            $this.CurrentX += $Width + $this.Options.Spacing
            $this.RowHeight = [Math]::Max($this.RowHeight, $Height)
            
            return $position
        }
        
        # Get next position in current column
        NextInColumn = {
            param([int]$Width, [int]$Height)
            
            # Check if component fits in current column
            $maxY = $this.Container.Y + $this.Container.Height - $this.Options.PaddingBottom
            if (($this.CurrentY + $Height) -gt $maxY) {
                # Move to next column
                $this.CurrentY = $this.Container.Y + $this.Options.PaddingTop
                $this.CurrentX += $Width + $this.Options.Spacing
            }
            
            $position = @{
                X = $this.CurrentX
                Y = $this.CurrentY
                Width = $Width
                Height = $Height
            }
            
            # Update position for next component
            $this.CurrentY += $Height + $this.Options.Spacing
            
            return $position
        }
        
        # Position at specific coordinates
        At = {
            param([int]$X, [int]$Y, [int]$Width, [int]$Height)
            
            $this.CurrentX = $X + $Width + $this.Options.Spacing
            $this.CurrentY = $Y
            $this.RowHeight = $Height
            
            return @{
                X = $X
                Y = $Y
                Width = $Width
                Height = $Height
            }
        }
        
        # Position relative to another position
        RelativeTo = {
            param(
                [hashtable]$Reference,
                [string]$Direction = "Right",  # Right, Left, Above, Below
                [int]$Width,
                [int]$Height,
                [int]$Offset = $null
            )
            
            if ($null -eq $Offset) { $Offset = $this.Options.Spacing }
            
            $position = switch ($Direction) {
                "Right" {
                    @{
                        X = $Reference.X + $Reference.Width + $Offset
                        Y = $Reference.Y
                        Width = $Width
                        Height = $Height
                    }
                }
                "Left" {
                    @{
                        X = $Reference.X - $Width - $Offset
                        Y = $Reference.Y
                        Width = $Width
                        Height = $Height
                    }
                }
                "Below" {
                    @{
                        X = $Reference.X
                        Y = $Reference.Y + $Reference.Height + $Offset
                        Width = $Width
                        Height = $Height
                    }
                }
                "Above" {
                    @{
                        X = $Reference.X
                        Y = $Reference.Y - $Height - $Offset
                        Width = $Width
                        Height = $Height
                    }
                }
            }
            
            return $position
        }
        
        # Center component in container
        Center = {
            param([int]$Width, [int]$Height)
            
            return @{
                X = $this.Container.X + [Math]::Floor(($this.Container.Width - $Width) / 2)
                Y = $this.Container.Y + [Math]::Floor(($this.Container.Height - $Height) / 2)
                Width = $Width
                Height = $Height
            }
        }
        
        # Align to edges
        AlignTopLeft = {
            param([int]$Width, [int]$Height)
            return @{
                X = $this.Container.X + $this.Options.PaddingLeft
                Y = $this.Container.Y + $this.Options.PaddingTop
                Width = $Width
                Height = $Height
            }
        }
        
        AlignTopRight = {
            param([int]$Width, [int]$Height)
            return @{
                X = $this.Container.X + $this.Container.Width - $Width - $this.Options.PaddingRight
                Y = $this.Container.Y + $this.Options.PaddingTop
                Width = $Width
                Height = $Height
            }
        }
        
        AlignBottomLeft = {
            param([int]$Width, [int]$Height)
            return @{
                X = $this.Container.X + $this.Options.PaddingLeft
                Y = $this.Container.Y + $this.Container.Height - $Height - $this.Options.PaddingBottom
                Width = $Width
                Height = $Height
            }
        }
        
        AlignBottomRight = {
            param([int]$Width, [int]$Height)
            return @{
                X = $this.Container.X + $this.Container.Width - $Width - $this.Options.PaddingRight
                Y = $this.Container.Y + $this.Container.Height - $Height - $this.Options.PaddingBottom
                Width = $Width
                Height = $Height
            }
        }
    }
    
    return $positioner
}

function global:Position-Components {
    <#
    .SYNOPSIS
    Positions multiple components using a layout pattern
    
    .PARAMETER Components
    Array of component hashtables to position
    
    .PARAMETER Pattern
    Layout pattern: 'Row', 'Column', 'Grid', 'Flow'
    
    .PARAMETER Container
    Container bounds
    
    .PARAMETER Options
    Layout options (spacing, columns for grid, etc.)
    #>
    param(
        [hashtable[]]$Components,
        [string]$Pattern = 'Row',
        [hashtable]$Container = @{ X = 0; Y = 0; Width = 80; Height = 25 },
        [hashtable]$Options = @{}
    )
    
    $spacing = $Options.Spacing ?? 1
    $padding = $Options.Padding ?? @{ Top = 0; Right = 0; Bottom = 0; Left = 0 }
    
    switch ($Pattern) {
        'Row' {
            $x = $Container.X + $padding.Left
            $y = $Container.Y + $padding.Top
            
            foreach ($comp in $Components) {
                $comp.X = $x
                $comp.Y = $y
                $x += $comp.Width + $spacing
            }
        }
        
        'Column' {
            $x = $Container.X + $padding.Left
            $y = $Container.Y + $padding.Top
            
            foreach ($comp in $Components) {
                $comp.X = $x
                $comp.Y = $y
                $y += $comp.Height + $spacing
            }
        }
        
        'Grid' {
            $columns = $Options.Columns ?? 2
            $x = $Container.X + $padding.Left
            $y = $Container.Y + $padding.Top
            $col = 0
            $rowHeight = 0
            
            foreach ($comp in $Components) {
                if ($col -ge $columns) {
                    $col = 0
                    $x = $Container.X + $padding.Left
                    $y += $rowHeight + $spacing
                    $rowHeight = 0
                }
                
                $comp.X = $x
                $comp.Y = $y
                $x += $comp.Width + $spacing
                $rowHeight = [Math]::Max($rowHeight, $comp.Height)
                $col++
            }
        }
        
        'Flow' {
            $x = $Container.X + $padding.Left
            $y = $Container.Y + $padding.Top
            $maxX = $Container.X + $Container.Width - $padding.Right
            $rowHeight = 0
            
            foreach ($comp in $Components) {
                # Check if component fits in current row
                if (($x + $comp.Width) -gt $maxX -and $x -ne ($Container.X + $padding.Left)) {
                    # Move to next row
                    $x = $Container.X + $padding.Left
                    $y += $rowHeight + $spacing
                    $rowHeight = 0
                }
                
                $comp.X = $x
                $comp.Y = $y
                $x += $comp.Width + $spacing
                $rowHeight = [Math]::Max($rowHeight, $comp.Height)
            }
        }
    }
}

function global:Get-RelativePosition {
    <#
    .SYNOPSIS
    Calculate position relative to another component
    #>
    param(
        [hashtable]$Reference,
        [string]$Direction = "Right",
        [int]$Offset = 1
    )
    
    switch ($Direction) {
        "Right" { return @{ X = $Reference.X + $Reference.Width + $Offset; Y = $Reference.Y } }
        "Left" { return @{ X = $Reference.X - $Offset; Y = $Reference.Y } }
        "Above" { return @{ X = $Reference.X; Y = $Reference.Y - $Offset } }
        "Below" { return @{ X = $Reference.X; Y = $Reference.Y + $Reference.Height + $Offset } }
        "TopRight" { return @{ X = $Reference.X + $Reference.Width + $Offset; Y = $Reference.Y } }
        "TopLeft" { return @{ X = $Reference.X - $Offset; Y = $Reference.Y } }
        "BottomRight" { return @{ X = $Reference.X + $Reference.Width + $Offset; Y = $Reference.Y + $Reference.Height } }
        "BottomLeft" { return @{ X = $Reference.X - $Offset; Y = $Reference.Y + $Reference.Height } }
    }
}

Export-ModuleMember -Function @(
    'New-TuiPositioner',
    'Position-Components',
    'Get-RelativePosition'
)
# Test file for app-store service
# Run with: Invoke-Pester -Path .\tests\app-store.tests.ps1

BeforeAll {
    # Set up test environment
    $script:BasePath = Split-Path -Parent (Split-Path -Parent $PSCommandPath)
    
    # Import required modules
    Import-Module "$script:BasePath\modules\event-system.psm1" -Force
    Import-Module "$script:BasePath\modules\tui-framework.psm1" -Force
    Import-Module "$script:BasePath\services\app-store.psm1" -Force
    
    # Initialize dependencies
    Initialize-EventSystem
    Initialize-TuiFramework
}

Describe "AppStore Service" {
    Context "Initialization" {
        It "should initialize with empty state" {
            # Arrange & Act
            $store = Initialize-AppStore
            
            # Assert
            $store | Should -Not -BeNullOrEmpty
            $store.GetState() | Should -BeOfType [hashtable]
        }
        
        It "should initialize with provided initial data" {
            # Arrange
            $initialData = @{
                counter = 0
                user = @{ name = "Test User" }
            }
            
            # Act
            $store = Initialize-AppStore -InitialData $initialData
            
            # Assert
            $store.GetState("counter") | Should -Be 0
            $store.GetState("user.name") | Should -Be "Test User"
        }
    }
    
    Context "State Management" {
        It "should update state via registered action" {
            # Arrange
            $store = Initialize-AppStore -InitialData @{ counter = 0 }
            
            $store.RegisterAction("INCREMENT", {
                param($Context)
                $current = $Context.GetState("counter")
                $Context.UpdateState(@{ counter = $current + 1 })
            })
            
            # Act
            $result = $store.Dispatch("INCREMENT")
            
            # Assert
            $result.Success | Should -Be $true
            $store.GetState("counter") | Should -Be 1
        }
        
        It "should handle action with payload" {
            # Arrange
            $store = Initialize-AppStore -InitialData @{ counter = 0 }
            
            $store.RegisterAction("ADD", {
                param($Context, $Payload)
                $current = $Context.GetState("counter")
                $Context.UpdateState(@{ counter = $current + $Payload.Amount })
            })
            
            # Act
            $result = $store.Dispatch("ADD", @{ Amount = 5 })
            
            # Assert
            $result.Success | Should -Be $true
            $store.GetState("counter") | Should -Be 5
        }
        
        It "should return error for unregistered action" {
            # Arrange
            $store = Initialize-AppStore
            
            # Act
            $result = $store.Dispatch("UNKNOWN_ACTION")
            
            # Assert
            $result.Success | Should -Be $false
            $result.Error | Should -BeLike "*not registered*"
        }
    }
    
    Context "Subscriptions" {
        It "should notify subscribers on state change" {
            # Arrange
            $store = Initialize-AppStore -InitialData @{ value = "initial" }
            $notificationReceived = $false
            $newValue = $null
            
            $subId = $store.Subscribe("value", {
                param($data)
                $script:notificationReceived = $true
                $script:newValue = $data.NewValue
            })
            
            $store.RegisterAction("UPDATE_VALUE", {
                param($Context)
                $Context.UpdateState(@{ value = "updated" })
            })
            
            # Act
            $store.Dispatch("UPDATE_VALUE")
            
            # Assert
            $notificationReceived | Should -Be $true
            $newValue | Should -Be "updated"
            
            # Cleanup
            $store.Unsubscribe($subId)
        }
        
        It "should support nested path subscriptions" {
            # Arrange
            $store = Initialize-AppStore -InitialData @{
                user = @{ profile = @{ name = "Test" } }
            }
            
            $notified = $false
            $subId = $store.Subscribe("user.profile.name", {
                param($data)
                $script:notified = $true
            })
            
            $store.RegisterAction("UPDATE_NAME", {
                param($Context)
                $Context.UpdateState(@{ 
                    user = @{ profile = @{ name = "Updated" } }
                })
            })
            
            # Act
            $store.Dispatch("UPDATE_NAME")
            
            # Assert
            $notified | Should -Be $true
            
            # Cleanup
            $store.Unsubscribe($subId)
        }
    }
    
    Context "Middleware" {
        It "should execute middleware before actions" {
            # Arrange
            $store = Initialize-AppStore
            $middlewareExecuted = $false
            
            $store.AddMiddleware({
                param($Action, $Store)
                $script:middlewareExecuted = $true
                return $Action  # Pass through
            })
            
            $store.RegisterAction("TEST", { })
            
            # Act
            $store.Dispatch("TEST")
            
            # Assert
            $middlewareExecuted | Should -Be $true
        }
        
        It "should allow middleware to cancel actions" {
            # Arrange
            $store = Initialize-AppStore
            
            $store.AddMiddleware({
                param($Action, $Store)
                if ($Action.Type -eq "FORBIDDEN") {
                    return $null  # Cancel action
                }
                return $Action
            })
            
            $actionExecuted = $false
            $store.RegisterAction("FORBIDDEN", {
                $script:actionExecuted = $true
            })
            
            # Act
            $result = $store.Dispatch("FORBIDDEN")
            
            # Assert
            $result.Success | Should -Be $false
            $result.Error | Should -BeLike "*cancelled*"
            $actionExecuted | Should -Be $false
        }
    }
    
    Context "Time Travel (Debug Features)" {
        It "should maintain action history" {
            # Arrange
            $store = Initialize-AppStore -InitialData @{ value = 0 }
            
            $store.RegisterAction("SET_VALUE", {
                param($Context, $Payload)
                $Context.UpdateState(@{ value = $Payload })
            })
            
            # Act
            $store.Dispatch("SET_VALUE", 1)
            $store.Dispatch("SET_VALUE", 2)
            $store.Dispatch("SET_VALUE", 3)
            
            $history = $store.GetHistory()
            
            # Assert
            $history.Count | Should -Be 3
            $history[0].Action.Payload | Should -Be 1
            $history[1].Action.Payload | Should -Be 2
            $history[2].Action.Payload | Should -Be 3
        }
        
        It "should restore previous state" {
            # Arrange
            $store = Initialize-AppStore -InitialData @{ value = 0 }
            
            $store.RegisterAction("SET_VALUE", {
                param($Context, $Payload)
                $Context.UpdateState(@{ value = $Payload })
            })
            
            # Act
            $store.Dispatch("SET_VALUE", 1)
            $store.Dispatch("SET_VALUE", 2)
            $store.Dispatch("SET_VALUE", 3)
            
            $store.RestoreState(2)  # Go back 2 steps
            
            # Assert
            $store.GetState("value") | Should -Be 1
        }
    }
}

Describe "AppStore Integration" {
    Context "With Navigation Service" {
        It "should update navigation state" -Skip {
            # This would test integration with navigation service
            # Skipped as it requires full service setup
        }
    }
    
    Context "With UI Components" {
        It "should trigger component updates on state change" -Skip {
            # This would test integration with UI components
            # Skipped as it requires full UI setup
        }
    }
}

AfterAll {
    # Cleanup
    Remove-Module app-store -Force -ErrorAction SilentlyContinue
    Remove-Module tui-framework -Force -ErrorAction SilentlyContinue
    Remove-Module event-system -Force -ErrorAction SilentlyContinue
}
