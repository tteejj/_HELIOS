# PMC Terminal v4.2 "Helios" - Main Entry Point (FIXED WITH PROPER ERROR HANDLING)
# This file orchestrates module loading and application startup with the new service architecture

# Set strict mode for better error handling
Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Get the directory where this script is located
$script:BasePath = Split-Path -Parent $MyInvocation.MyCommand.Path

# Module loading order is critical - dependencies must load first
# FIX: Logger and Exceptions are now pre-loaded in the main execution block to ensure
# tracing and error handling are available immediately.
$script:ModulesToLoad = @(
    # Core infrastructure (no dependencies)
    @{ Name = "event-system"; Path = "modules\event-system.psm1"; Required = $true },
    
    # Data and theme (depend on event system)
    @{ Name = "data-manager"; Path = "modules\data-manager.psm1"; Required = $true },
    @{ Name = "theme-manager"; Path = "modules\theme-manager.psm1"; Required = $true },
    
    # Framework (depends on event system)
    @{ Name = "tui-framework"; Path = "modules\tui-framework.psm1"; Required = $true },
    
    # Engine (depends on theme and framework)
    @{ Name = "tui-engine-v2"; Path = "modules\tui-engine-v2.psm1"; Required = $true },
    
    # Dialog system (depends on engine)
    @{ Name = "dialog-system"; Path = "modules\dialog-system.psm1"; Required = $true },
    
    # Services (depend on framework for state management)
    @{ Name = "app-store"; Path = "services\app-store.psm1"; Required = $true },
    @{ Name = "navigation"; Path = "services\navigation.psm1"; Required = $true },
    @{ Name = "keybindings"; Path = "services\keybindings.psm1"; Required = $true },
    
    # Layout system
    @{ Name = "layout-panels"; Path = "layout\panels.psm1"; Required = $true },
    
    # Focus management (depends on event system)
    @{ Name = "focus-manager"; Path = "utilities\focus-manager.psm1"; Required = $true },
    
    # Components (depend on engine and panels)
    @{ Name = "tui-components"; Path = "components\tui-components.psm1"; Required = $true },
    @{ Name = "advanced-input-components"; Path = "components\advanced-input-components.psm1"; Required = $false },
    @{ Name = "advanced-data-components"; Path = "components\advanced-data-components.psm1"; Required = $true }
)

# Screen modules will be loaded dynamically
$script:ScreenModules = @(
"dashboard-screen-helios",
"task-screen-helios",
"timer-start-screen",
"project-management-screen",
"timer-management-screen",
"reports-screen",
"settings-screen",
"debug-log-screen",
"demo-screen",
"time-entry-screen-helios",
"simple-test-screen"
)

function Initialize-PMCModules {
    param([bool]$Silent = $false)
    
    Trace-FunctionEntry -FunctionName "Initialize-PMCModules" -Parameters @{ Silent = $Silent }
    
    return Invoke-WithErrorHandling -Component "ModuleLoader" -OperationName "Initialize-PMCModules" -ScriptBlock {
        Trace-Step -StepName "Checking console window size"
        $minWidth = 80
        $minHeight = 24
        if ($Host.UI.RawUI) {
            $currentWidth = $Host.UI.RawUI.WindowSize.Width
            $currentHeight = $Host.UI.RawUI.WindowSize.Height
            Trace-Step -StepName "Console size check" -StepData @{
                CurrentWidth = $currentWidth
                CurrentHeight = $currentHeight
                MinWidth = $minWidth
                MinHeight = $minHeight
            }
            
            if ($currentWidth -lt $minWidth -or $currentHeight -lt $minHeight) {
                Write-Host "Console window too small!" -ForegroundColor Red
                Write-Host "Current size: ${currentWidth}x${currentHeight}" -ForegroundColor Yellow
                Write-Host "Minimum required: ${minWidth}x${minHeight}" -ForegroundColor Green
                Write-Host "Please resize your console window and try again." -ForegroundColor White
                Write-Host "Press any key to exit..." -ForegroundColor Gray
                $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
                exit 1
            }
        }
        
        if (-not $Silent) { Write-Host "Initializing PMC Terminal v4.2 'Helios'..." -ForegroundColor Cyan }
        Trace-Step -StepName "Starting module loading sequence" -StepData @{
            TotalModules = $script:ModulesToLoad.Count
            BasePath = $script:BasePath
        }
        
        $loadedModules = @()
        
        foreach ($module in $script:ModulesToLoad) {
            $modulePath = Join-Path $script:BasePath $module.Path
            Trace-Step -StepName "Processing module" -StepData @{
                ModuleName = $module.Name
                ModulePath = $modulePath
                Required = $module.Required
                PathExists = Test-Path $modulePath
            }
            
            try {
                if (Test-Path $modulePath) {
                    if (-not $Silent) { Write-Host "  Loading $($module.Name)..." -ForegroundColor Gray }
                    
                    Trace-Step -StepName "Importing module" -StepData @{
                        ModuleName = $module.Name
                        Action = "Import-Module"
                    }
                    
                    Import-Module $modulePath -Force -Global -ErrorAction Stop
                    $loadedModules += $module.Name
                    
                    Trace-Step -StepName "Module loaded successfully" -StepData @{
                        ModuleName = $module.Name
                        LoadedCount = $loadedModules.Count
                    }
                    
                } elseif ($module.Required) { 
                    $errorMsg = "Required module not found: $($module.Name) at $modulePath"
                    Write-Log -Level Error -Message $errorMsg -Force
                    throw $errorMsg
                }
            } catch {
                $errorMsg = "Failed to load module $($module.Name): $_"
                Write-Log -Level Error -Message $errorMsg -Data @{
                    ModuleName = $module.Name
                    ModulePath = $modulePath
                    Required = $module.Required
                    Exception = $_.Exception.Message
                } -Force
                
                if ($module.Required) { 
                    Write-Host "  $errorMsg" -ForegroundColor Red
                    throw 
                } else { 
                    if (-not $Silent) { Write-Host "  Optional module $($module.Name) not loaded: $_" -ForegroundColor Yellow } 
                }
            }
        }
        
        if (-not $Silent) { Write-Host "Loaded $($loadedModules.Count) modules successfully" -ForegroundColor Green }
        
        Trace-Step -StepName "Module loading completed" -StepData @{
            LoadedModules = $loadedModules
            LoadedCount = $loadedModules.Count
            TotalAttempted = $script:ModulesToLoad.Count
        }
        
        Trace-FunctionExit -FunctionName "Initialize-PMCModules" -ReturnValue @{
            LoadedCount = $loadedModules.Count
            LoadedModules = $loadedModules
        }
        
        return $loadedModules
    }
}

function Initialize-PMCScreens {
    param([bool]$Silent = $false)
    
    Trace-FunctionEntry -FunctionName "Initialize-PMCScreens" -Parameters @{ Silent = $Silent }
    
    return Invoke-WithErrorHandling -Component "ScreenLoader" -OperationName "Initialize-PMCScreens" -ScriptBlock {
        if (-not $Silent) { Write-Host "Loading screens..." -ForegroundColor Cyan }
        
        Trace-Step -StepName "Starting screen loading sequence" -StepData @{
            TotalScreens = $script:ScreenModules.Count
            BasePath = $script:BasePath
            ScreenModules = $script:ScreenModules
        }
        
        $loadedScreens = @()
        
        foreach ($screenName in $script:ScreenModules) {
            $screenPath = Join-Path $script:BasePath "screens\$screenName.psm1"
            
            Trace-Step -StepName "Processing screen module" -StepData @{
                ScreenName = $screenName
                ScreenPath = $screenPath
                PathExists = Test-Path $screenPath
            }
            
            try {
                if (Test-Path $screenPath) {
                    if (-not $Silent) { Write-Host "  Loading $($screenName)..." -ForegroundColor Gray }
                    Trace-Step -StepName "Importing screen module" -StepData @{
                        ScreenName = $screenName
                        Action = "Import-Module"
                    }
                    
                    # FIX: Removed -LiteralPath for broader PowerShell compatibility.
                    # The previous issue was due to string concatenation, not the path itself.
                    Import-Module $screenPath -Force -Global -ErrorAction SilentlyContinue
                    $loadedScreens += $screenName
                    
                    Trace-Step -StepName "Screen module loaded successfully" -StepData @{
                        ScreenName = $screenName
                        LoadedCount = $loadedScreens.Count
                    }
                    
                    # Verify the screen module exported its expected functions
                    $expectedFunctions = @()
                    switch ($screenName) {
                        "dashboard-screen-helios" { $expectedFunctions = @("Get-DashboardScreen") }
                        "task-screen-helios" { $expectedFunctions = @("Get-TaskManagementScreen", "Get-TaskScreen") }
                        "simple-test-screen" { $expectedFunctions = @("Get-SimpleTestScreen") }
                        default { 
                            # For other screens, ensure the function name is correctly formed without spaces.
                            # Fixed: Proper grouping of ForEach-Object pipeline
                            $functionName = "Get-" + ((($screenName -split "-") | ForEach-Object { 
                                $_.Substring(0,1).ToUpper() + $_.Substring(1) 
                            }) -join "")
                            $expectedFunctions = @($functionName)
                        }
                    }
                    
                    foreach ($funcName in $expectedFunctions) {
                        $funcExists = Get-Command $funcName -ErrorAction SilentlyContinue
                        Trace-Step -StepName "Verifying screen function" -StepData @{
                            ScreenName = $screenName
                            FunctionName = $funcName
                            FunctionExists = ($null -ne $funcExists)
                        }
                        
                        if (-not $funcExists) {
                            Write-Log -Level Warning -Message "Expected function '$funcName' not found for screen '$screenName'"
                        }
                    }
                    
                } else { 
                    if (-not $Silent) { 
                        Write-Host "  Screen module not found: $screenName" -ForegroundColor Yellow 
                    }
                    
                    Trace-Step -StepName "Screen module file not found" -StepData @{
                        ScreenName = $screenName
                        ExpectedPath = $screenPath
                    }
                }
            } catch { 
                if (-not $Silent) { 
                    Write-Host "  Failed to load screen: $screenName - $_" -ForegroundColor Yellow 
                }
                
                Write-Log -Level Warning -Message "Failed to load screen module" -Data @{
                    ScreenName = $screenName
                    ScreenPath = $screenPath
                    Exception = $_.Exception.Message
                    StackTrace = $_.Exception.StackTrace
                }
                
                Trace-Step -StepName "Screen module loading failed" -StepData @{
                    ScreenName = $screenName
                    Error = $_.Exception.Message
                }
            }
        }
        
        if (-not $Silent) { Write-Host "Loaded $($loadedScreens.Count) screens" -ForegroundColor Green }
        
        Trace-Step -StepName "Screen loading completed" -StepData @{
            LoadedScreens = $loadedScreens
            LoadedCount = $loadedScreens.Count
            TotalAttempted = $script:ScreenModules.Count
            SuccessRate = if ($script:ScreenModules.Count -gt 0) { 
                [Math]::Round(($loadedScreens.Count / $script:ScreenModules.Count) * 100, 1) 
            } else { 0 }
        }
        
        Trace-FunctionExit -FunctionName "Initialize-PMCScreens" -ReturnValue @{
            LoadedCount = $loadedScreens.Count
            LoadedScreens = $loadedScreens
        }
        
        return $loadedScreens
    }
}

function Initialize-PMCServices {
    param([bool]$Silent = $false)
    
    Trace-FunctionEntry -FunctionName "Initialize-PMCServices" -Parameters @{ Silent = $Silent }
    
    return Invoke-WithErrorHandling -Component "ServiceInitializer" -OperationName "Initialize-PMCServices" -ScriptBlock {
        if (-not $Silent) { Write-Host "Initializing services..." -ForegroundColor Cyan }
        
        Trace-Step -StepName "Starting service initialization" -StepData @{
            GlobalDataExists = ($null -ne $global:Data)
            GlobalDataType = if ($global:Data) { $global:Data.GetType().Name } else { "null" }
        }
        
        $services = @{}
        
        # Initialize AppStore with defensive checks
        $initialData = @{}
        if ($global:Data) { 
            $initialData = $global:Data 
        } else {
            # Initialize with safe empty structures
            $global:Data = @{
                Tasks = @()
                Projects = @{}
                TimeEntries = @()
                ActiveTimers = @{}
                Settings = @{ Theme = "Modern" }
            }
            $initialData = $global:Data
        }
        
        Trace-Step -StepName "Initializing AppStore" -StepData @{
            InitialDataAvailable = ($null -ne $initialData)
        }
        
        $services.Store = Initialize-AppStore -InitialData $initialData -EnableDebugLogging $false
        
        Trace-Step -StepName "AppStore initialized" -StepData @{
            StoreType = $services.Store.GetType().Name
            StoreKeys = if ($services.Store -is [hashtable]) { $services.Store.Keys } else { "N/A" }
        }
        
        # SIMPLIFIED DASHBOARD_REFRESH - Just navigation, no data loading
        Trace-Step -StepName "Registering DASHBOARD_REFRESH action"
        & $services.Store.RegisterAction -self $services.Store -actionName "DASHBOARD_REFRESH" -scriptBlock {
            param($Context)
            Write-Log -Level Info -Message "DASHBOARD_REFRESH: Simplified version (navigation only)"
            # No data loading needed for navigation-only dashboard
        }
        
        # DEFENSIVE TASKS_REFRESH with extreme null checking
        Trace-Step -StepName "Registering TASKS_REFRESH action"
        & $services.Store.RegisterAction -self $services.Store -actionName "TASKS_REFRESH" -scriptBlock {
            param($Context)
            try {
                # Initialize if needed
                if (-not $global:Data) { $global:Data = @{} }
                if (-not $global:Data.ContainsKey('Tasks')) { $global:Data.Tasks = @() }
                
                # Force array type
                $rawTasks = @()
                if ($global:Data.Tasks) {
                    $rawTasks = @($global:Data.Tasks)
                }
                
                # Safe count
                $totalCount = 0
                if ($rawTasks) { $totalCount = @($rawTasks).Count }
                
                Write-Log -Level Debug -Message "TASKS_REFRESH: Processing $totalCount tasks"
                
                # Count active tasks with defensive filtering
                $activeTasks = 0
                if ($totalCount -gt 0) {
                    $filtered = @($rawTasks | Where-Object { 
                        $_ -and $_.ContainsKey('completed') -and (-not $_.completed) 
                    })
                    $activeTasks = $filtered.Count
                }
                
                # Build tasks for table display with extreme defensive checks
                $tasksForTable = @()
                if ($totalCount -gt 0) {
                    foreach ($task in $rawTasks) {
                        if (-not $task) { continue }
                        
                        # Safe property access with defaults
                        $taskItem = @{
                            Id = if ($task.ContainsKey('id')) { $task.id } else { [Guid]::NewGuid().ToString() }
                            Status = if ($task.ContainsKey('completed') -and $task.completed) { "✓" } else { "○" }
                            Priority = if ($task.ContainsKey('priority')) { $task.priority } else { "medium" }
                            Title = if ($task.ContainsKey('title')) { $task.title } else { "Untitled" }
                            Category = if ($task.ContainsKey('project')) { $task.project } else { "General" }
                            DueDate = "N/A"
                        }
                        
                        # Safe date parsing
                        if ($task.ContainsKey('due_date') -and $task.due_date) {
                            try {
                                $taskItem.DueDate = ([DateTime]$task.due_date).ToString("yyyy-MM-dd")
                            } catch {
                                $taskItem.DueDate = "Invalid"
                            }
                        }
                        
                        $tasksForTable += $taskItem
                    }
                }
                
                # Ensure array type for state update
                $tasksForTable = @($tasksForTable)
                
                Write-Log -Level Debug -Message "TASKS_REFRESH: Updating state with $($tasksForTable.Count) tasks"
                
                # Update state with defensive checks
                & $Context.UpdateState @{ 
                    tasks = $tasksForTable
                    "stats.activeTasks" = $activeTasks 
                }
                
            } catch {
                Write-Log -Level Error -Message "TASKS_REFRESH failed: $_" -Data @{
                    Exception = $_.Exception.Message
                    StackTrace = $_.Exception.StackTrace
                }
            }
        }
        
        # TASK_CREATE with defensive validation
        & $services.Store.RegisterAction -self $services.Store -actionName "TASK_CREATE" -scriptBlock {
            param($Context, $Payload)
            try {
                # Validate payload
                if (-not $Payload) {
                    Write-Log -Level Warning -Message "TASK_CREATE: No payload provided"
                    return
                }
                
                if (-not $Payload.Title -or [string]::IsNullOrWhiteSpace($Payload.Title)) {
                    Write-Log -Level Warning -Message "TASK_CREATE: No title provided"
                    return
                }
                
                # Initialize if needed
                if (-not $global:Data) { $global:Data = @{} }
                if (-not $global:Data.ContainsKey('Tasks')) { $global:Data.Tasks = @() }
                
                # Create new task with all required fields
                $newTask = @{
                    id = [Guid]::NewGuid().ToString()
                    title = $Payload.Title.Trim()
                    description = if ($Payload.Description) { $Payload.Description } else { "" }
                    completed = $false
                    priority = if ($Payload.Priority) { $Payload.Priority } else { "medium" }
                    project = if ($Payload.Category) { $Payload.Category } else { "General" }
                    due_date = if ($Payload.DueDate) { $Payload.DueDate } else { $null }
                    created_at = (Get-Date).ToString("o")
                    updated_at = (Get-Date).ToString("o")
                }
                
                # Add to tasks array
                $global:Data.Tasks = @($global:Data.Tasks) + $newTask
                
                Write-Log -Level Info -Message "TASK_CREATE: Created task '$($newTask.title)' with ID $($newTask.id)"
                
                # Save data
                if (Get-Command Save-UnifiedData -ErrorAction SilentlyContinue) {
                    Save-UnifiedData
                }
                
                # Refresh tasks
                & $Context.Dispatch "TASKS_REFRESH"
                
            } catch {
                Write-Log -Level Error -Message "TASK_CREATE failed: $_" -Data @{
                    Exception = $_.Exception.Message
                    Payload = $Payload
                }
            }
        }
        
        # TASK_UPDATE with defensive validation
        & $services.Store.RegisterAction -self $services.Store -actionName "TASK_UPDATE" -scriptBlock {
            param($Context, $Payload)
            try {
                if (-not $Payload -or -not $Payload.TaskId) {
                    Write-Log -Level Warning -Message "TASK_UPDATE: No TaskId provided"
                    return
                }
                
                if (-not $global:Data -or -not $global:Data.Tasks) {
                    Write-Log -Level Warning -Message "TASK_UPDATE: No tasks found"
                    return
                }
                
                # Find task safely
                $taskIndex = -1
                $tasks = @($global:Data.Tasks)
                for ($i = 0; $i -lt $tasks.Count; $i++) {
                    if ($tasks[$i] -and $tasks[$i].id -eq $Payload.TaskId) {
                        $taskIndex = $i
                        break
                    }
                }
                
                if ($taskIndex -eq -1) {
                    Write-Log -Level Warning -Message "TASK_UPDATE: Task not found with ID $($Payload.TaskId)"
                    return
                }
                
                # Update task fields
                $task = $tasks[$taskIndex]
                if ($Payload.ContainsKey('Title') -and $Payload.Title) { $task.title = $Payload.Title.Trim() }
                if ($Payload.ContainsKey('Description')) { $task.description = $Payload.Description }
                if ($Payload.ContainsKey('Priority')) { $task.priority = $Payload.Priority }
                if ($Payload.ContainsKey('Category')) { $task.project = $Payload.Category }
                if ($Payload.ContainsKey('DueDate')) { $task.due_date = $Payload.DueDate }
                if ($Payload.ContainsKey('Completed')) { $task.completed = $Payload.Completed }
                
                $task.updated_at = (Get-Date).ToString("o")
                
                Write-Log -Level Info -Message "TASK_UPDATE: Updated task $($Payload.TaskId)"
                
                # Save data
                if (Get-Command Save-UnifiedData -ErrorAction SilentlyContinue) {
                    Save-UnifiedData
                }
                
                # Refresh tasks
                & $Context.Dispatch "TASKS_REFRESH"
                
            } catch {
                Write-Log -Level Error -Message "TASK_UPDATE failed: $_" -Data @{
                    Exception = $_.Exception.Message
                    Payload = $Payload
                }
            }
        }
        
        # TASK_DELETE with defensive validation
        & $services.Store.RegisterAction -self $services.Store -actionName "TASK_DELETE" -scriptBlock {
            param($Context, $Payload)
            try {
                if (-not $Payload -or -not $Payload.TaskId) {
                    Write-Log -Level Warning -Message "TASK_DELETE: No TaskId provided"
                    return
                }
                
                if (-not $global:Data -or -not $global:Data.Tasks) {
                    Write-Log -Level Warning -Message "TASK_DELETE: No tasks found"
                    return
                }
                
                # Filter out the task safely
                $originalCount = @($global:Data.Tasks).Count
                $global:Data.Tasks = @($global:Data.Tasks | Where-Object { 
                    $_ -and $_.id -ne $Payload.TaskId 
                })
                $newCount = @($global:Data.Tasks).Count
                
                if ($newCount -lt $originalCount) {
                    Write-Log -Level Info -Message "TASK_DELETE: Deleted task $($Payload.TaskId)"
                    
                    # Save data
                    if (Get-Command Save-UnifiedData -ErrorAction SilentlyContinue) {
                        Save-UnifiedData
                    }
                    
                    # Refresh tasks
                    & $Context.Dispatch "TASKS_REFRESH"
                } else {
                    Write-Log -Level Warning -Message "TASK_DELETE: Task not found with ID $($Payload.TaskId)"
                }
                
            } catch {
                Write-Log -Level Error -Message "TASK_DELETE failed: $_" -Data @{
                    Exception = $_.Exception.Message
                    Payload = $Payload
                }
            }
        }
        
        # Initialize Navigation Service
        Trace-Step -StepName "Initializing Navigation Service"
        $services.Navigation = Initialize-NavigationService
        Trace-Step -StepName "Navigation Service initialized" -StepData @{
            NavigationType = $services.Navigation.GetType().Name
            NavigationKeys = if ($services.Navigation -is [hashtable]) { $services.Navigation.Keys } else { "N/A" }
        }
        
        # Register navigation routes
        Trace-Step -StepName "Registering navigation routes"
        
        & $services.Navigation.RegisterRoute -self $services.Navigation -Path "/dashboard" -ScreenFactory {
            param($Services)
            Get-DashboardScreen -Services $Services
        }
        
        & $services.Navigation.RegisterRoute -self $services.Navigation -Path "/task" -ScreenFactory {
            param($Services)
            Get-TaskManagementScreen -Services $Services
        }
        
        & $services.Navigation.RegisterRoute -self $services.Navigation -Path "/time-entry" -ScreenFactory {
            param($Services)
            Get-TimeEntryScreen -Services $Services
        }
        
        & $services.Navigation.RegisterRoute -self $services.Navigation -Path "/timer-start" -ScreenFactory {
            param($Services)
            Get-TimerStartScreen -Services $Services
        }
        
        & $services.Navigation.RegisterRoute -self $services.Navigation -Path "/project" -ScreenFactory {
            param($Services)
            Get-ProjectManagementScreen -Services $Services
        }
        
        & $services.Navigation.RegisterRoute -self $services.Navigation -Path "/reports" -ScreenFactory {
            param($Services)
            Get-ReportsScreen -Services $Services
        }
        
        & $services.Navigation.RegisterRoute -self $services.Navigation -Path "/settings" -ScreenFactory {
            param($Services)
            Get-SettingsScreen -Services $Services
        }
        
        # Initialize Keybinding Service
        Trace-Step -StepName "Initializing Keybinding Service"
        $services.Keybindings = Initialize-KeybindingService
        Trace-Step -StepName "Keybinding Service initialized" -StepData @{
            KeybindingType = $services.Keybindings.GetType().Name
            KeybindingKeys = if ($services.Keybindings -is [hashtable]) { $services.Keybindings.Keys } else { "N/A" }
        }
        
        Trace-Step -StepName "Setting global services" -StepData @{
            ServiceCount = $services.Keys.Count
            ServiceNames = $services.Keys
        }
        
        $global:Services = $services
        
        Trace-StateChange -StateType "GlobalServices" -NewValue @{
            ServiceCount = $services.Keys.Count
            ServiceNames = $services.Keys
        }
        
        Trace-FunctionExit -FunctionName "Initialize-PMCServices" -ReturnValue @{
            ServiceCount = $services.Keys.Count
            ServiceNames = $services.Keys
        }
        
        return $services
    }
}

function Start-PMCTerminal {
    param([bool]$Silent = $false)
    
    Trace-FunctionEntry -FunctionName "Start-PMCTerminal" -Parameters @{ Silent = $Silent }
    
    try {
        Trace-Step -StepName "Starting PMC Terminal initialization sequence"
        
        $loadedModules = Initialize-PMCModules -Silent:$Silent
        # Prepend the manually loaded modules for complete logging
        $loadedModules = @("logger", "exceptions") + $loadedModules
        Trace-Step -StepName "Module initialization completed" -StepData @{
            LoadedModuleCount = if ($loadedModules) { @($loadedModules).Count } else { 0 } # ADDED DEFENSIVE CHECK
            LoadedModules = $loadedModules
        }
        
        if (-not $Silent) { Write-Host "`nInitializing subsystems..." -ForegroundColor Cyan }
        
        # Initialize logger first - CRITICAL FOR DEBUGGING (already loaded)
        Write-Log -Level Info -Message "PMC Terminal v4.2 'Helios' startup initiated"
        Write-Log -Level Info -Message "Loaded modules: $($loadedModules -join ', ')"
        
        Trace-Step -StepName "Logger system initialized successfully" -StepData @{
            LogPath = Get-LogPath
        }
        
        # Initialize Event System
        Trace-Step -StepName "Initializing Event System"
        try {
            if (Get-Command Initialize-EventSystem -ErrorAction SilentlyContinue) {
                Initialize-EventSystem
                Write-Log -Level Debug -Message "Event system initialized"
                Trace-Step -StepName "Event system initialized successfully"
            } else {
                Write-Log -Level Warning -Message "Event system not available"
                Trace-Step -StepName "Event system not available"
            }
        } catch {
            Write-Log -Level Error -Message "Failed to initialize Event System" -Data @{
                Exception = $_.Exception.Message
                StackTrace = $_.Exception.StackTrace
            }
            Trace-Step -StepName "Event system initialization failed" -StepData @{
                Error = $_.Exception.Message
            }
            # Continue anyway as it might not be critical
        }
        
        # Initialize Theme Manager with enhanced error handling
        Trace-Step -StepName "Initializing Theme Manager"
        try {
            if (Get-Command Initialize-ThemeManager -ErrorAction SilentlyContinue) {
                Trace-Step -StepName "Calling Initialize-ThemeManager"
                Initialize-ThemeManager
                
                Trace-Step -StepName "Checking if theme is set after initialization"
                $currentTheme = $null
                if (Get-Command Get-TuiTheme -ErrorAction SilentlyContinue) {
                    try {
                        $currentTheme = Get-TuiTheme
                        Trace-Step -StepName "Theme check result" -StepData @{
                            ThemeExists = ($null -ne $currentTheme)
                            ThemeType = if ($currentTheme) { $currentTheme.GetType().Name } else { "null" }
                            ThemeProperties = if ($currentTheme -is [hashtable]) { $currentTheme.Keys } else { "N/A" }
                        }
                    } catch {
                        Write-Log -Level Error -Message "Failed to get current theme after initialization" -Data @{
                            Exception = $_.Exception.Message
                        }
                        Trace-Step -StepName "Get-TuiTheme failed" -StepData @{
                            Error = $_.Exception.Message
                        }
                    }
                }
                
                # FIX: Ensure theme is actually set
                if (-not $currentTheme) {
                    Write-Log -Level Warning -Message "Theme not set after initialization, setting Modern theme"
                    Trace-Step -StepName "Theme not set, attempting to set Modern theme"
                    
                    if (Get-Command Set-TuiTheme -ErrorAction SilentlyContinue) {
                        try {
                            Set-TuiTheme -ThemeName "Modern"
                            $currentTheme = Get-TuiTheme
                            Trace-Step -StepName "Modern theme set successfully" -StepData @{
                                ThemeSet = ($null -ne $currentTheme)
                                ThemeName = if ($currentTheme -and $currentTheme.Name) { $currentTheme.Name } else { "Unknown" }
                            }
                        } catch {
                            Write-Log -Level Error -Message "Failed to set Modern theme" -Data @{
                                Exception = $_.Exception.Message
                                StackTrace = $_.Exception.StackTrace
                            }
                            Trace-Step -StepName "Set-TuiTheme failed" -StepData @{
                                Error = $_.Exception.Message
                            }
                        }
                    } else {
                        Write-Log -Level Error -Message "Set-TuiTheme command not available"
                        Trace-Step -StepName "Set-TuiTheme command not available"
                    }
                }
                
                $finalTheme = if (Get-Command Get-TuiTheme -ErrorAction SilentlyContinue) { 
                    try { Get-TuiTheme } catch { $null }
                } else { $null }
                
                Write-Log -Level Debug -Message "Theme manager initialized" -Data @{
                    ThemeName = if ($finalTheme -and $finalTheme.Name) { $finalTheme.Name } else { "Unknown/Default" }
                    ThemeInitialized = ($null -ne $finalTheme)
                }
                
                Trace-Step -StepName "Theme manager initialization completed" -StepData @{
                    Success = ($null -ne $finalTheme)
                    ThemeName = if ($finalTheme -and $finalTheme.Name) { $finalTheme.Name } else { "Unknown/Default" }
                }
            } else {
                Write-Log -Level Warning -Message "Theme manager not available"
                Trace-Step -StepName "Theme manager not available"
            }
        } catch {
            Write-Log -Level Error -Message "Failed to initialize Theme Manager" -Data @{
                Exception = $_.Exception.Message
                StackTrace = $_.Exception.StackTrace
            }
            Trace-Step -StepName "Theme manager initialization failed" -StepData @{
                Error = $_.Exception.Message
                StackTrace = $_.Exception.StackTrace
            }
            # Continue with default colors
        }
        
        # Initialize Data Manager with error handling
        Trace-Step -StepName "Initializing Data Manager"
        try {
            if (Get-Command Initialize-DataManager -ErrorAction SilentlyContinue) {
                Initialize-DataManager
                Write-Log -Level Debug -Message "Data manager initialized"
                Trace-Step -StepName "Data manager initialized successfully"
            } else {
                Write-Log -Level Warning -Message "Data manager not available"
                Trace-Step -StepName "Data manager not available"
            }
        } catch {
            Write-Log -Level Error -Message "Failed to initialize Data Manager" -Data @{
                Exception = $_.Exception.Message
                StackTrace = $_.Exception.StackTrace
            }
            Trace-Step -StepName "Data manager initialization failed" -StepData @{
                Error = $_.Exception.Message
            }
            # Continue as data can be loaded manually
        }
        
        # Initialize TUI Framework
        Trace-Step -StepName "Initializing TUI Framework"
        try {
            if (Get-Command Initialize-TuiFramework -ErrorAction SilentlyContinue) {
                Initialize-TuiFramework
                Write-Log -Level Debug -Message "TUI framework initialized"
                Trace-Step -StepName "TUI framework initialized successfully"
            } else {
                $errorMsg = "Initialize-TuiFramework command not available"
                Write-Log -Level Error -Message $errorMsg
                Trace-Step -StepName "TUI framework not available"
                throw $errorMsg
            }
        } catch {
            Write-Log -Level Error -Message "Failed to initialize TUI Framework" -Data @{
                Exception = $_.Exception.Message
                StackTrace = $_.Exception.StackTrace
            }
            Trace-Step -StepName "TUI framework initialization failed" -StepData @{
                Error = $_.Exception.Message
            }
            throw # This is critical
        }
        
        # Initialize TUI Engine
        Trace-Step -StepName "Initializing TUI Engine"
        try {
            if (Get-Command Initialize-TuiEngine -ErrorAction SilentlyContinue) {
                # Get console dimensions for logging
                $consoleWidth = if ($Host.UI.RawUI) { $Host.UI.RawUI.WindowSize.Width } else { 80 }
                $consoleHeight = if ($Host.UI.RawUI) { $Host.UI.RawUI.WindowSize.Height } else { 24 }
                
                Trace-Step -StepName "Calling Initialize-TuiEngine" -StepData @{
                    ConsoleWidth = $consoleWidth
                    ConsoleHeight = $consoleHeight
                }
                
                Initialize-TuiEngine
                Write-Log -Level Info -Message "Initializing TUI Engine: ${consoleWidth}x${consoleHeight}"
                Write-Log -Level Info -Message "TUI Engine initialized successfully"
                
                Trace-Step -StepName "TUI engine initialized successfully" -StepData @{
                    Dimensions = "${consoleWidth}x${consoleHeight}"
                }
            } else {
                $errorMsg = "Initialize-TuiEngine command not available"
                Write-Log -Level Error -Message $errorMsg
                Trace-Step -StepName "TUI engine not available"
                throw $errorMsg
            }
        } catch {
            Write-Log -Level Error -Message "Failed to initialize TUI Engine" -Data @{
                Exception = $_.Exception.Message
                StackTrace = $_.Exception.StackTrace
            }
            Trace-Step -StepName "TUI engine initialization failed" -StepData @{
                Error = $_.Exception.Message
            }
            throw # This is critical
        }
        
        # Initialize Dialog System with error handling
        Trace-Step -StepName "Initializing Dialog System"
        try {
            if (Get-Command Initialize-DialogSystem -ErrorAction SilentlyContinue) {
                Initialize-DialogSystem
                Write-Log -Level Debug -Message "Dialog system initialized"
                Trace-Step -StepName "Dialog system initialized successfully"
            } else {
                Write-Log -Level Warning -Message "Dialog system not available"
                Trace-Step -StepName "Dialog system not available"
            }
        } catch {
            Write-Log -Level Error -Message "Failed to initialize Dialog System" -Data @{
                Exception = $_.Exception.Message
                StackTrace = $_.Exception.StackTrace
            }
            Trace-Step -StepName "Dialog system initialization failed" -StepData @{
                Error = $_.Exception.Message
            }
            # Continue without dialogs
        }
        
        # Load data
        Trace-Step -StepName "Loading unified data"
        try {
            if (Get-Command Load-UnifiedData -ErrorAction SilentlyContinue) {
                Load-UnifiedData
                Write-Log -Level Debug -Message "Data loaded successfully"
                Trace-Step -StepName "Data loaded successfully" -StepData @{
                    GlobalDataExists = ($null -ne $global:Data)
                    DataType = if ($global:Data) { $global:Data.GetType().Name } else { "null" }
                    DataKeys = if ($global:Data -is [hashtable]) { $global:Data.Keys } else { "N/A" }
                }
            } else {
                Write-Log -Level Warning -Message "Load-UnifiedData not available, initializing empty data"
                $global:Data = @{}
                Trace-Step -StepName "Initialized empty global data"
            }
        } catch {
            Write-Log -Level Warning -Message "Failed to load data, using empty data" -Data @{
                Exception = $_.Exception.Message
            }
            $global:Data = @{}
            Trace-Step -StepName "Data loading failed, using empty data" -StepData @{
                Error = $_.Exception.Message
            }
        }
        
        # Initialize services
        Trace-Step -StepName "Starting service initialization"
        $services = Initialize-PMCServices -Silent:$Silent
        Trace-Step -StepName "Services initialized" -StepData @{
            ServiceCount = $services.Keys.Count
            ServiceNames = $services.Keys
        }
        
        # Initialize Focus Manager with error handling
        Trace-Step -StepName "Initializing Focus Manager"
        try {
            if (Get-Command Initialize-FocusManager -ErrorAction SilentlyContinue) {
                Initialize-FocusManager
                Write-Log -Level Debug -Message "Focus manager initialized"
                Trace-Step -StepName "Focus manager initialized successfully"
            } else {
                Write-Log -Level Warning -Message "Focus manager not available"
                Trace-Step -StepName "Focus manager not available"
            }
        } catch {
            Write-Log -Level Error -Message "Failed to initialize Focus Manager" -Data @{
                Exception = $_.Exception.Message
                StackTrace = $_.Exception.StackTrace
            }
            Trace-Step -StepName "Focus manager initialization failed" -StepData @{
                Error = $_.Exception.Message
            }
            # Continue without advanced focus management
        }
        
        # Load screens
        Trace-Step -StepName "Loading screen modules"
        $loadedScreens = Initialize-PMCScreens -Silent:$Silent
        Trace-Step -StepName "Screens loaded" -StepData @{
            LoadedScreenCount = if ($loadedScreens) { @($loadedScreens).Count } else { 0 } # ADDED DEFENSIVE CHECK
            LoadedScreens = $loadedScreens
        }
        
        if (-not $Silent) { Write-Host "`nStarting application..." -ForegroundColor Green }
        
        Trace-Step -StepName "Clearing host and preparing for navigation"
        Clear-Host
        
        # Dispatch initial actions to populate dashboard data
        Trace-Step -StepName "Dispatching initial actions to populate data"
        try {
            # Note: The original log message here was confusingly worded. It's now corrected.
            # Write-Log -Level Info -Message "Dispatching initial 'DASHBOARD_REFRESH' action" # COMMENTED OUT
            # & $services.Store.Dispatch -self $services.Store -actionName "DASHBOARD_REFRESH" # COMMENTED OUT
            # Trace-Step -StepName "Initial DASHBOARD_REFRESH action dispatched successfully" # COMMENTED OUT
            Write-Log -Level Info -Message "Skipping initial DASHBOARD_REFRESH for simplified dashboard." # ADDED THIS LINE
        } catch {
            Write-Log -Level Error -Message "Error dispatching initial 'DASHBOARD_REFRESH' action" -Data @{
                Exception = $_.Exception.Message
                StackTrace = $_.Exception.StackTrace
            }
            Trace-Step -StepName "Initial DASHBOARD_REFRESH action failed" -StepData @{
                Error = $_.Exception.Message
            }
            # Continue anyway - the dashboard can refresh later
        }
        
        # Navigate to start screen
        Trace-Step -StepName "Determining start screen path"
        $startPath = "/dashboard"
        if ($args -contains "-start") {
            $startIndex = [array]::IndexOf($args, "-start")
            if (($startIndex + 1) -lt $args.Count) { 
                $startPath = $args[$startIndex + 1] 
                Trace-Step -StepName "Custom start path specified" -StepData @{
                    CustomPath = $startPath
                }
            }
        }
        
        Trace-Step -StepName "Validating start path" -StepData @{
            StartPath = $startPath
            NavigationService = ($null -ne $services.Navigation)
        }
        
        if ($services.Navigation -and (& $services.Navigation.IsValidRoute -self $services.Navigation -Path $startPath)) {
            Trace-Step -StepName "Navigating to start screen" -StepData @{
                StartPath = $startPath
                NavigationMethod = "GoTo"
            }
            
            Write-Log -Level Info -Message "Navigated to: $startPath"
            & $services.Navigation.GoTo -self $services.Navigation -Path $startPath -Services $services
            
            Trace-Step -StepName "Navigation completed successfully"
        } else {
            Write-Log -Level Warning -Message "Startup path '$startPath' is not valid. Defaulting to /dashboard."
            Trace-Step -StepName "Invalid start path, defaulting to dashboard" -StepData @{
                InvalidPath = $startPath
                DefaultPath = "/dashboard"
            }
            
            & $services.Navigation.GoTo -self $services.Navigation -Path "/dashboard" -Services $services
        }
        
        # Start the main loop
        Trace-Step -StepName "Starting TUI main loop"
        if (Get-Command Start-TuiLoop -ErrorAction SilentlyContinue) {
            Start-TuiLoop
            Trace-Step -StepName "TUI main loop started"
        } else {
            $errorMsg = "Start-TuiLoop command not available"
            Write-Log -Level Error -Message $errorMsg
            Trace-Step -StepName "TUI main loop unavailable"
            throw $errorMsg
        }
        
        Trace-FunctionExit -FunctionName "Start-PMCTerminal" -ReturnValue @{ Success = $true }
        
    } catch {
        Write-Log -Level Error -Message "FATAL: Failed to initialize PMC Terminal" -Data @{
            Exception = $_.Exception.Message
            StackTrace = $_.Exception.StackTrace
            InnerException = if ($_.Exception.InnerException) { $_.Exception.InnerException.Message } else { $null }
        } -Force
        
        Trace-Step -StepName "Fatal error occurred during initialization" -StepData @{
            Error = $_.Exception.Message
            StackTrace = $_.Exception.StackTrace
        }
        
        Write-Host "`nFATAL ERROR DURING INITIALIZATION: $($_.Exception.Message)" -ForegroundColor Red
        Write-Host $_.ScriptStackTrace -ForegroundColor Gray
        
        # Try to get diagnostic report
        Trace-Step -StepName "Attempting to generate crash diagnostic report"
        try {
            if (Get-Command Get-HeliosDiagnosticReport -ErrorAction SilentlyContinue) {
                $report = Get-HeliosDiagnosticReport -IncludeErrorHistory -IncludeLogEntries -LogEntryCount 100
                $reportPath = Join-Path $env:TEMP "helios_crash_$(Get-Date -Format 'yyyyMMdd_HHmmss').json"
                $report | ConvertTo-Json -Depth 10 | Set-Content $reportPath
                Write-Host "`nDiagnostic report saved to: $reportPath" -ForegroundColor Yellow
                Write-Log -Level Info -Message "Crash diagnostic report saved" -Data @{ ReportPath = $reportPath } -Force
                
                Trace-Step -StepName "Crash diagnostic report generated" -StepData @{
                    ReportPath = $reportPath
                    ReportSize = (Get-Item $reportPath).Length
                }
            } else {
                Write-Host "Diagnostic report generation not available" -ForegroundColor Yellow
                Trace-Step -StepName "Diagnostic report generation not available"
            }
        } catch {
            Write-Host "Failed to generate diagnostic report: $_" -ForegroundColor Yellow
            Trace-Step -StepName "Diagnostic report generation failed" -StepData @{
                Error = $_.Exception.Message
            }
        }
        
        Trace-FunctionExit -FunctionName "Start-PMCTerminal" -ReturnValue @{ Success = $false; Error = $_.Exception.Message } -WithError
        
        throw
    } finally {
        Trace-Step -StepName "Starting cleanup sequence"
        
        if (Get-Command Write-Log -ErrorAction SilentlyContinue) { 
            Write-Log -Level Info -Message "PMC Terminal shutting down" 
        }
        
        if (Get-Command -Name "Stop-TuiEngine" -ErrorAction SilentlyContinue) { 
            if (-not $Silent) { Write-Host "`nShutting down..." }
            Trace-Step -StepName "Stopping TUI Engine"
            Stop-TuiEngine 
        }
        
        if ($global:Data -and (Get-Command -Name "Save-UnifiedData" -ErrorAction SilentlyContinue)) { 
            if (-not $Silent) { Write-Host "Saving data..." }
            Trace-Step -StepName "Saving unified data"
            Save-UnifiedData 
        }
        
        if (-not $Silent) { Write-Host "Goodbye!" -ForegroundColor Green }
        Trace-Step -StepName "Cleanup completed"
    }
}

# Main execution block with comprehensive tracing
$script:Silent = $args -contains "-silent" -or $args -contains "-s"

# Set up enhanced error handling from the start
Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

try {
    # Clear host and start tracing immediately
    Clear-Host

    # FIX: CRITICAL - Pre-load essential modules (logger, exceptions) BEFORE anything else.
    # This resolves the chicken-and-egg dependency issue where tracing and error handling
    # functions were being called before they were loaded.
    $exceptionsModulePath = Join-Path $script:BasePath "modules\exceptions.psm1"
    $loggerModulePath = Join-Path $script:BasePath "modules\logger.psm1"
    
    if (-not (Test-Path $exceptionsModulePath)) {
        throw "CRITICAL FAILURE: The core exception handling module is missing at '$exceptionsModulePath'. Cannot continue."
    }
    if (-not (Test-Path $loggerModulePath)) {
        throw "CRITICAL FAILURE: The core logger module is missing at '$loggerModulePath'. Cannot continue."
    }
    Import-Module $exceptionsModulePath -Force -Global
    Import-Module $loggerModulePath -Force -Global

    # Now that logger is available, initialize it.
    Initialize-Logger
    Write-Log -Level Info -Message "Logger initialized early in main execution block"
    
    # Initialize basic logging even before modules are loaded
    Write-Host "PMC Terminal v4.2 'Helios' - Enhanced Diagnostics Mode" -ForegroundColor Cyan
    Write-Host "Tracing enabled - All execution steps will be logged" -ForegroundColor Yellow
    Write-Host "Log files written to: $env:TEMP\PMCTerminal\" -ForegroundColor Green
    Write-Host "Starting initialization sequence..." -ForegroundColor Green
    Write-Host ""
    
    # Trace the very beginning
    if (-not $script:Silent) {
        Write-Log -Level Trace -Message "Main execution block started" -Data @{
            Arguments = $args
            SilentMode = $script:Silent
            BasePath = $script:BasePath
            PowerShellVersion = $PSVersionTable.PSVersion.ToString()
            ProcessId = $PID
        }
    }
    
    # Start the terminal with enhanced error context
    Invoke-WithErrorHandling -Component "MainExecution" -OperationName "Start-PMCTerminal" -ScriptBlock {
        Start-PMCTerminal -Silent:$script:Silent
    } -ErrorHandler {
        param($Exception, $DetailedError)
        
        Write-Host "`n=== CRITICAL FAILURE ===" -ForegroundColor Red
        Write-Host "Fatal error occurred during PMC Terminal startup" -ForegroundColor Red
        
        # Check if this is our custom exception with data
        $heliosEx = $null
        if ($Exception -and $Exception.Data -and $Exception.Data.Contains("HeliosException")) {
            $heliosEx = $Exception.Data["HeliosException"]
        }
        
        # Safely access exception properties that might not exist
        $errorMessage = if ($heliosEx -and $heliosEx.Message) { $heliosEx.Message }
                       elseif ($Exception.Message) { $Exception.Message } 
                       elseif ($Exception -is [string]) { $Exception } 
                       else { "Unknown error" }
        Write-Host "Error: $errorMessage" -ForegroundColor Red
        
        $component = if ($heliosEx -and $heliosEx.Component) { $heliosEx.Component }
                    elseif ($Exception.Component) { $Exception.Component }
                    elseif ($Exception.Data -and $Exception.Data.Contains("Component")) { $Exception.Data["Component"] }
                    else { $null }
        
        if ($component) {
            Write-Host "Component: $component" -ForegroundColor Yellow
        }
        
        $timestamp = if ($heliosEx -and $heliosEx.Timestamp) { $heliosEx.Timestamp }
                    elseif ($Exception.Timestamp) { $Exception.Timestamp }
                    elseif ($Exception.Data -and $Exception.Data.Contains("Timestamp")) { $Exception.Data["Timestamp"] }
                    else { Get-Date }
        
        Write-Host "Timestamp: $timestamp" -ForegroundColor Yellow
        
        if ($DetailedError) {
            Write-Host "`nDetailed Error Information:" -ForegroundColor Yellow
            Write-Host "Type: $($DetailedError.Type)" -ForegroundColor Gray
            Write-Host "Category: $($DetailedError.Category)" -ForegroundColor Gray
            Write-Host "Location: $($DetailedError.ScriptName):$($DetailedError.LineNumber)" -ForegroundColor Gray
            
            if ($DetailedError.StackTrace -and $DetailedError.StackTrace.Count -gt 0) {
                Write-Host "`nCall Stack:" -ForegroundColor Yellow
                for ($i = 0; $i -lt [Math]::Min(5, $DetailedError.StackTrace.Count); $i++) {
                    $frame = $DetailedError.StackTrace[$i]
                    Write-Host "  [$i] $($frame.Command) at $($frame.Location)" -ForegroundColor Gray
                }
            }
            
            if ($DetailedError.SystemContext) {
                Write-Host "`nSystem Context:" -ForegroundColor Yellow
                Write-Host "  Process ID: $($DetailedError.SystemContext.ProcessId)" -ForegroundColor Gray
                Write-Host "  PowerShell: $($DetailedError.SystemContext.PowerShellVersion)" -ForegroundColor Gray
                Write-Host "  Memory Usage: $($DetailedError.SystemContext.MemoryUsage) bytes" -ForegroundColor Gray
                
                if ($DetailedError.SystemContext.LoadedModules) {
                    Write-Host "  Loaded Modules: $($DetailedError.SystemContext.LoadedModules.Count)" -ForegroundColor Gray
                }
                
                if ($DetailedError.SystemContext.GlobalVariables) {
                    Write-Host "  Global Variables:" -ForegroundColor Gray
                    foreach ($var in $DetailedError.SystemContext.GlobalVariables) {
                        Write-Host "    $($var.Name): $($var.Type)" -ForegroundColor DarkGray
                    }
                }
            }
        }
        
        # Try to save crash information
        try {
            # Extract Helios exception if available
            $heliosEx = $null
            if ($Exception -and $Exception.Data -and $Exception.Data.Contains("HeliosException")) {
                $heliosEx = $Exception.Data["HeliosException"]
            }
            
            $crashInfo = @{
                Timestamp = Get-Date
                Exception = @{
                    Message = if ($heliosEx -and $heliosEx.Message) { $heliosEx.Message }
                             elseif ($Exception.Message) { $Exception.Message } 
                             else { "Unknown error" }
                    Type = if ($Exception.GetType) { $Exception.GetType().FullName } else { "Unknown" }
                    Component = if ($heliosEx -and $heliosEx.Component) { $heliosEx.Component }
                               elseif ($Exception.Component) { $Exception.Component }
                               elseif ($Exception.Data -and $Exception.Data.Contains("Component")) { $Exception.Data["Component"] }
                               else { "Unknown" }
                }
                DetailedError = $DetailedError
                ProcessId = $PID
                PowerShellVersion = $PSVersionTable.PSVersion.ToString()
                Arguments = $args
                BasePath = $script:BasePath
            }
            
            $crashPath = Join-Path $env:TEMP "helios_fatal_crash_$(Get-Date -Format 'yyyyMMdd_HHmmss').json"
            $crashInfo | ConvertTo-Json -Depth 10 | Set-Content $crashPath -Encoding UTF8
            
            Write-Host "`nCrash information saved to: $crashPath" -ForegroundColor Cyan
            Write-Host "Please include this file when reporting the issue." -ForegroundColor Cyan
            
        } catch {
            Write-Host "`nFailed to save crash information: $_" -ForegroundColor Yellow
        }
        
        Write-Host "`n=== END CRITICAL FAILURE ===" -ForegroundColor Red
        
        # Don't re-throw - we want to handle this gracefully
    }
    
} catch {
    # This is the ultimate fallback error handler
    Write-Host "`n!!! ULTIMATE FALLBACK ERROR HANDLER !!!" -ForegroundColor Red
    Write-Host "Even the enhanced error handling failed!" -ForegroundColor Red
    Write-Host "Raw error: $_" -ForegroundColor Red
    Write-Host "Error type: $($_.GetType().FullName)" -ForegroundColor Yellow
    Write-Host "Script stack trace:" -ForegroundColor Yellow
    Write-Host $_.ScriptStackTrace -ForegroundColor Gray
    
    # Try one last diagnostic attempt
    try {
        $ultimateFailureInfo = @{
            Timestamp = Get-Date
            UltimateError = $_.Exception.Message
            ErrorType = $_.GetType().FullName
            ProcessId = $PID
            PowerShellVersion = $PSVersionTable.PSVersion.ToString()
            WorkingDirectory = Get-Location
            Arguments = $args
        }
        
        $ultimatePath = Join-Path $env:TEMP "helios_ultimate_failure_$(Get-Date -Format 'yyyyMMdd_HHmmss').json"
        $ultimateFailureInfo | ConvertTo-Json -Depth 5 | Set-Content $ultimatePath -Encoding UTF8
        
        Write-Host "`nUltimate failure info saved to: $ultimatePath" -ForegroundColor Magenta
    } catch {
        Write-Host "Even ultimate failure logging failed: $_" -ForegroundColor Red
    }
    
    Write-Error "Fatal error occurred: $_"
    exit 1
    
} finally {
    # Final cleanup and user interaction
    if ($Host.UI.RawUI) {
        Write-Host "`nPress any key to exit..." -ForegroundColor Green
        try {
            $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
        } catch {
            # If even reading a key fails, just wait a moment
            Start-Sleep -Seconds 2
        }
    }
    
    Write-Host "Exiting PMC Terminal..." -ForegroundColor Gray
    exit 1
}
# Advanced Data Components Module
# Enhanced data display components with sorting, filtering, and pagination

#region Advanced Table Component

function global:New-TuiDataTable {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "DataTable"
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 80 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 20 }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Title = $Props.Title
        ShowBorder = if ($null -ne $Props.ShowBorder) { $Props.ShowBorder } else { $true }  # <-- NEW: Controls whether component draws its own border
        Data = if ($null -ne $Props.Data) { $Props.Data } else { @() }
        Columns = if ($null -ne $Props.Columns) { $Props.Columns } else { @() }
        SelectedRow = 0
        ScrollOffset = 0
        SortColumn = $null
        SortDirection = "Ascending"
        FilterText = ""
        FilterColumn = $null
        PageSize = 0  # 0 = auto-calculate
        CurrentPage = 0
        ShowHeader = if ($null -ne $Props.ShowHeader) { $Props.ShowHeader } else { $true }
        ShowFooter = if ($null -ne $Props.ShowFooter) { $Props.ShowFooter } else { $true }
        ShowRowNumbers = if ($null -ne $Props.ShowRowNumbers) { $Props.ShowRowNumbers } else { $false }
        AllowSort = if ($null -ne $Props.AllowSort) { $Props.AllowSort } else { $true }
        AllowFilter = if ($null -ne $Props.AllowFilter) { $Props.AllowFilter } else { $true }
        AllowSelection = if ($null -ne $Props.AllowSelection) { $Props.AllowSelection } else { $true }
        MultiSelect = if ($null -ne $Props.MultiSelect) { $Props.MultiSelect } else { $false }
        SelectedRows = @()
        IsFocusable = if ($null -ne $Props.IsFocusable) { $Props.IsFocusable } else { $true }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        Name = $Props.Name
        FilteredData = @()
        ProcessedData = @()
        _lastRenderedWidth = 0
        _lastRenderedHeight = 0
        
        # Event handlers from Props
        OnRowSelect = $Props.OnRowSelect
        OnSelectionChange = $Props.OnSelectionChange
        
        # Column configuration example:
        # @{
        #     Name = "PropertyName"
        #     Header = "Display Header"
        #     Width = 20
        #     Align = "Left"  # Left, Right, Center
        #     Format = { param($value) $value.ToString("N2") }
        #     Sortable = $true
        #     Filterable = $true
        #     Color = { param($value, $row) if ($value -lt 0) { "Red" } else { "Green" } }
        # }
        
        ProcessData = {
            param($self)
            try {
                # Filter data
                if ([string]::IsNullOrWhiteSpace($self.FilterText)) {
                    $self.FilteredData = $self.Data
                } else {
                    if ($self.FilterColumn) {
                        # Filter specific column
                        $self.FilteredData = @($self.Data | Where-Object {
                            $value = $_."$($self.FilterColumn)"
                            $value -and $value.ToString() -like "*$($self.FilterText)*"
                        })
                    } else {
                        # Filter all columns
                        $self.FilteredData = @($self.Data | Where-Object {
                            $row = $_
                            $matched = $false
                            foreach ($col in $self.Columns) {
                                if ($col.Filterable -ne $false) {
                                    $value = $row."$($col.Name)"
                                    if ($value -and $value.ToString() -like "*$($self.FilterText)*") {
                                        $matched = $true
                                        break
                                    }
                                }
                            }
                            $matched
                        })
                    }
                }
                
                # Sort data
                if ($self.SortColumn -and $self.AllowSort) {
                    $self.ProcessedData = $self.FilteredData | Sort-Object -Property $self.SortColumn -Descending:($self.SortDirection -eq "Descending")
                } else {
                    $self.ProcessedData = $self.FilteredData
                }
                
                # Reset selection if needed
                if ($self.SelectedRow -ge $self.ProcessedData.Count) {
                    $self.SelectedRow = [Math]::Max(0, $self.ProcessedData.Count - 1)
                }
                
                # Calculate page size if auto
                if ($self.PageSize -eq 0) {
                    $headerLines = if ($self.ShowHeader) { 3 } else { 0 }
                    $footerLines = if ($self.ShowFooter) { 2 } else { 0 }
                    $filterLines = if ($self.AllowFilter) { 2 } else { 0 }
                    $borderAdjust = if ($self.ShowBorder) { 2 } else { 0 }
                    $self.PageSize = $self.Height - $headerLines - $footerLines - $filterLines - $borderAdjust
                }
                
                # Adjust current page
                $totalPages = [Math]::Ceiling($self.ProcessedData.Count / [Math]::Max(1, $self.PageSize))
                if ($self.CurrentPage -ge $totalPages) {
                    $self.CurrentPage = [Math]::Max(0, $totalPages - 1)
                }
            } catch {
                Write-Log -Level Error -Message "DataTable ProcessData error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        Render = {
            param($self)
            try {
                # CRITICAL: Check if component is visible
                if ($self.Visible -eq $false) { return }
                
                # Force ProcessData if dimensions changed
                if ($self._lastRenderedWidth -ne $self.Width -or $self._lastRenderedHeight -ne $self.Height) {
                    & $self.ProcessData -self $self
                    $self._lastRenderedWidth = $self.Width
                    $self._lastRenderedHeight = $self.Height
                }
                
                # NOTE: ProcessData is now called by external code when data changes
                # This prevents unnecessary recalculation on every render frame
                
                # Calculate content area based on border settings
                if ($self.ShowBorder) {
                    $borderColor = if ($self.IsFocusable -and $self.IsFocused) { 
                        Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
                    } else { 
                        Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
                    }
                    
                    $titleText = if ($null -ne $self.Title) { $self.Title } else { 'Data Table' }
                    Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                        -BorderColor $borderColor -Title " $titleText "
                    
                    # Adjust content area for border
                    $contentX = $self.X + 1
                    $contentY = $self.Y + 1
                    $contentWidth = $self.Width - 2
                    $contentHeight = $self.Height - 2
                } else {
                    # No border, use full dimensions
                    $contentX = $self.X
                    $contentY = $self.Y
                    $contentWidth = $self.Width
                    $contentHeight = $self.Height
                }
                
                $currentY = $contentY
                $innerWidth = $contentWidth
                
                # Filter bar
                if ($self.AllowFilter) {
                    $filterBg = if ($self.FilterText) { Get-ThemeColor "Warning" -Default ([ConsoleColor]::Yellow) } else { Get-ThemeColor "Background" -Default ([ConsoleColor]::Black) }
                    $filterFg = if ($self.FilterText) { Get-ThemeColor "Background" -Default ([ConsoleColor]::Black) } else { Get-ThemeColor "Subtle" -Default ([ConsoleColor]::DarkGray) }
                    
                    Write-BufferString -X ($contentX + 1) -Y $currentY -Text "Filter: " -ForegroundColor (Get-ThemeColor "Primary" -Default ([ConsoleColor]::White))
                    
                    $filterDisplayText = if ($self.FilterText) { $self.FilterText } else { "Type to filter..." }
                    Write-BufferString -X ($contentX + 9) -Y $currentY -Text $filterDisplayText `
                        -ForegroundColor $filterFg -BackgroundColor $filterBg
                    
                    if ($self.FilterColumn) {
                        $filterCol = $self.Columns | Where-Object { $_.Name -eq $self.FilterColumn }
                        $colName = if ($filterCol -and $filterCol.Header) { $filterCol.Header } else { $self.FilterColumn }
                        Write-BufferString -X ($contentX + $contentWidth - 19) -Y $currentY `
                            -Text "Column: $colName" -ForegroundColor (Get-ThemeColor "Info" -Default ([ConsoleColor]::Blue))
                    }
                    
                    $currentY += 2
                }
                
                # Calculate column widths - FIXED VERSION
                $totalDefinedWidth = ($self.Columns | Where-Object { $_.Width } | Measure-Object -Property Width -Sum).Sum
                if ($null -eq $totalDefinedWidth) { $totalDefinedWidth = 0 }
                $flexColumns = @($self.Columns | Where-Object { -not $_.Width })
                $columnSeparators = if ($self.Columns.Count -gt 1) { $self.Columns.Count - 1 } else { 0 }  # Only add separators if multiple columns
                $rowNumberWidth = if ($self.ShowRowNumbers) { 5 } else { 0 }
                $remainingWidth = $innerWidth - $totalDefinedWidth - $rowNumberWidth - $columnSeparators
                
                # CRITICAL FIX: Ensure flex columns get adequate width, especially for single-column tables
                $flexWidth = 0
                if ($flexColumns.Count -gt 0) {
                    $flexWidth = [Math]::Floor($remainingWidth / $flexColumns.Count)
                }
                
                # Assign calculated widths
                foreach ($col in $self.Columns) {
                    if ($col.Width) {
                        $col.CalculatedWidth = $col.Width
                    } else {
                        # For flex columns, use the calculated flex width
                        $col.CalculatedWidth = [Math]::Max(5, $flexWidth)
                    }
                }
                
                # Header
                if ($self.ShowHeader) {
                    $headerX = $contentX
                    
                    # Row number header
                    if ($self.ShowRowNumbers) {
                        Write-BufferString -X $headerX -Y $currentY -Text "#".PadRight(4) `
                            -ForegroundColor (Get-ThemeColor "Header" -Default ([ConsoleColor]::Cyan))
                        $headerX += 5
                    }
                    
                    # Column headers
                    foreach ($col in $self.Columns) {
                        $headerText = if ($col.Header) { $col.Header } else { $col.Name }
                        $width = $col.CalculatedWidth
                        
                        # Add sort indicator
                        if ($self.AllowSort -and $col.Sortable -ne $false -and $col.Name -eq $self.SortColumn) {
                            $sortIndicator = if ($self.SortDirection -eq "Ascending") { "▲" } else { "▼" }
                            $headerText = "$headerText $sortIndicator"
                        }
                        
                        # Truncate if needed
                        if ($headerText.Length -gt $width) {
                            # FIX: Robust substring
                            $maxLength = [Math]::Max(0, $width - 3)
                            $headerText = $headerText.Substring(0, $maxLength) + "..."
                        }
                        
                        # Align header
                        if ($col.Align -eq "Right") {
                            $alignedText = $headerText.PadLeft($width)
                        } elseif ($col.Align -eq "Center") {
                            $padding = $width - $headerText.Length
                            $leftPad = [Math]::Floor($padding / 2)
                            $rightPad = $padding - $leftPad
                            $alignedText = " " * $leftPad + $headerText + " " * $rightPad
                        } else {
                            $alignedText = $headerText.PadRight($width)
                        }
                        
                        Write-BufferString -X $headerX -Y $currentY -Text $alignedText `
                            -ForegroundColor (Get-ThemeColor "Header" -Default ([ConsoleColor]::Cyan))
                        
                        $headerX += $width + 1
                    }
                    
                    $currentY++
                    
                    # Header separator
                    $separatorColor = Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
                    Write-BufferString -X $contentX -Y $currentY `
                        -Text ("─" * $contentWidth) -ForegroundColor $separatorColor
                    $currentY++
                }
                
                # Data rows
                $startIdx = $self.CurrentPage * $self.PageSize
                $endIdx = [Math]::Min($startIdx + $self.PageSize - 1, $self.ProcessedData.Count - 1)
                
                for ($i = $startIdx; $i -le $endIdx; $i++) {
                    $row = $self.ProcessedData[$i]
                    $rowX = $contentX
                    
                    # Selection highlighting
                    $isSelected = if ($self.MultiSelect) {
                        $self.SelectedRows -contains $i
                    } else {
                        $i -eq $self.SelectedRow
                    }
                    
                    $rowBg = if ($isSelected) { Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan) } else { Get-ThemeColor "Background" -Default ([ConsoleColor]::Black) }
                    $rowFg = if ($isSelected) { Get-ThemeColor "Background" -Default ([ConsoleColor]::Black) } else { Get-ThemeColor "Primary" -Default ([ConsoleColor]::White) }
                    
                    # Clear row background if selected - FIXED to respect actual component width
                    if ($isSelected) {
                        # Calculate actual row width based on column widths and separators
                        $actualRowWidth = 0
                        if ($self.ShowRowNumbers) { $actualRowWidth += 5 }
                        foreach ($col in $self.Columns) {
                            $actualRowWidth += $col.CalculatedWidth
                        }
                        # Add column separators
                        if ($self.Columns.Count -gt 1) {
                            $actualRowWidth += ($self.Columns.Count - 1)
                        }
                        # Ensure we don't exceed content width
                        $actualRowWidth = [Math]::Min($actualRowWidth, $contentWidth)
                        
                        Write-BufferString -X $rowX -Y $currentY -Text (" " * $actualRowWidth) `
                            -BackgroundColor $rowBg
                    }
                    
                    # Row number
                    if ($self.ShowRowNumbers) {
                        Write-BufferString -X $rowX -Y $currentY -Text ($i + 1).ToString().PadRight(4) `
                            -ForegroundColor (Get-ThemeColor "Subtle" -Default ([ConsoleColor]::DarkGray)) -BackgroundColor $rowBg
                        $rowX += 5
                    }
                    
                    # Cell data
                    foreach ($col in $self.Columns) {
                        $value = $row."$($col.Name)"
                        $width = $col.CalculatedWidth
                        
                        # Format value
                        $displayValue = if ($col.Format -and $value -ne $null) {
                            & $col.Format $value
                        } elseif ($value -ne $null) {
                            $value.ToString()
                        } else {
                            ""
                        }
                        
                        # Truncate if needed
                        if ($displayValue.Length -gt $width) {
                            # FIX: Robust substring
                            $maxLength = [Math]::Max(0, $width - 3)
                            if ($maxLength -le 0) {
                                Write-Log -Level Warning -Message "DataTable '$($self.Title)' column '$($col.Name)' width too small: $width (max length: $maxLength)"
                                $displayValue = "..."
                            } else {
                                $displayValue = $displayValue.Substring(0, $maxLength) + "..."
                            }
                        }
                        
                        
                        # Align value
                        if ($col.Align -eq "Right") {
                            $alignedValue = $displayValue.PadLeft($width)
                        } elseif ($col.Align -eq "Center") {
                            $padding = $width - $displayValue.Length
                            $leftPad = [Math]::Floor($padding / 2)
                            $rightPad = $padding - $leftPad
                            $alignedValue = " " * $leftPad + $displayValue + " " * $rightPad
                        } else {
                            $alignedValue = $displayValue.PadRight($width)
                        }
                        
                        # Determine color
                        $cellFg = if ($col.Color -and -not $isSelected) {
                            $colorName = & $col.Color $value $row
                            Get-ThemeColor $colorName -Default ([ConsoleColor]::White)
                        } else {
                            $rowFg
                        }
                        
                        # Ensure we don't write beyond component boundaries
                        if ($rowX + $alignedValue.Length -le $contentX + $contentWidth) {
                            Write-BufferString -X $rowX -Y $currentY -Text $alignedValue `
                                -ForegroundColor $cellFg -BackgroundColor $rowBg
                        } else {
                            # Clip the text to fit within boundaries
                            $availableWidth = ($contentX + $contentWidth) - $rowX
                            if ($availableWidth -gt 0) {
                                $clippedText = $alignedValue.Substring(0, [Math]::Min($alignedValue.Length, $availableWidth))
                                Write-BufferString -X $rowX -Y $currentY -Text $clippedText `
                                    -ForegroundColor $cellFg -BackgroundColor $rowBg
                            }
                        }
                        
                        $rowX += $width + 1
                    }
                    
                    $currentY++
                }
                
                # Empty state
                if ($self.ProcessedData.Count -eq 0) {
                    $emptyMessage = if ($self.FilterText) {
                        "No results match the filter"
                    } else {
                        "No data to display"
                    }
                    $msgX = $contentX + [Math]::Floor(($contentWidth - $emptyMessage.Length) / 2)
                    $msgY = $contentY + [Math]::Floor($contentHeight / 2)
                    Write-BufferString -X $msgX -Y $msgY -Text $emptyMessage `
                        -ForegroundColor (Get-ThemeColor "Subtle" -Default ([ConsoleColor]::DarkGray))
                }
                
                # Footer
                if ($self.ShowFooter) {
                    $footerY = $contentY + $contentHeight - 1
                    
                    # Status
                    $statusText = "$($self.ProcessedData.Count) rows"
                    if ($self.FilterText) {
                        $statusText += " (filtered from $($self.Data.Count))"
                    }
                    if ($self.MultiSelect) {
                        $statusText += " | $($self.SelectedRows.Count) selected"
                    }
                    Write-BufferString -X ($contentX + 1) -Y $footerY -Text $statusText `
                        -ForegroundColor (Get-ThemeColor "Subtle" -Default ([ConsoleColor]::DarkGray))
                    
                    # Pagination
                    if ($self.ProcessedData.Count -gt $self.PageSize) {
                        $totalPages = [Math]::Ceiling($self.ProcessedData.Count / [Math]::Max(1, $self.PageSize))
                        $pageText = "Page $($self.CurrentPage + 1)/$totalPages"
                        Write-BufferString -X ($contentX + $contentWidth - $pageText.Length - 1) -Y $footerY `
                            -Text $pageText -ForegroundColor (Get-ThemeColor "Info" -Default ([ConsoleColor]::Blue))
                    }
                    
                    # Scrollbar
                    if ($self.ProcessedData.Count -gt $self.PageSize) {
                        $scrollHeight = $contentHeight - 4 - (if ($self.ShowHeader) { 2 } else { 0 }) - (if ($self.AllowFilter) { 2 } else { 0 })
                        $scrollPos = [Math]::Floor(($self.SelectedRow / ($self.ProcessedData.Count - 1)) * ($scrollHeight - 1))
                        $scrollX = $contentX + $contentWidth - 1
                        
                        for ($i = 0; $i -lt $scrollHeight; $i++) {
                            $scrollY = $currentY - $scrollHeight + $i
                            $char = if ($i -eq $scrollPos) { "█" } else { "│" }
                            $color = if ($i -eq $scrollPos) { Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan) } else { Get-ThemeColor "Subtle" -Default ([ConsoleColor]::DarkGray) }
                            Write-BufferString -X $scrollX -Y $scrollY -Text $char -ForegroundColor $color
                        }
                    }
                }
            } catch {
                Write-Log -Level Error -Message "DataTable Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                # Filter mode
                if ($Key.Modifiers -band [ConsoleModifiers]::Control) {
                    switch ($Key.Key) {
                        ([ConsoleKey]::F) {
                            # Toggle filter focus
                            $self.FilterMode = -not $self.FilterMode
                            Request-TuiRefresh
                            return $true
                        }
                        ([ConsoleKey]::S) {
                            # Cycle sort column
                            if ($self.AllowSort) {
                                $sortableCols = @($self.Columns | Where-Object { $_.Sortable -ne $false })
                                if ($sortableCols.Count -gt 0) {
                                    $currentIdx = [array]::IndexOf($sortableCols.Name, $self.SortColumn)
                                    $nextIdx = ($currentIdx + 1) % $sortableCols.Count
                                    $self.SortColumn = $sortableCols[$nextIdx].Name
                                    & $self.ProcessData -self $self
                                    Request-TuiRefresh
                                }
                            }
                            return $true
                        }
                        ([ConsoleKey]::A) {
                            # Select all (if multi-select)
                            if ($self.MultiSelect) {
                                if ($self.SelectedRows.Count -eq $self.ProcessedData.Count) {
                                    $self.SelectedRows = @()
                                } else {
                                    $self.SelectedRows = @(0..($self.ProcessedData.Count - 1))
                                }
                                if ($self.OnSelectionChange) {
                                    Invoke-WithErrorHandling -Component "$($self.Name).OnSelectionChange" -ScriptBlock {
                                        & $self.OnSelectionChange -SelectedRows $self.SelectedRows
                                    } -Context @{ Component = $self.Name; SelectedRows = $self.SelectedRows } -ErrorHandler {
                                        param($Exception)
                                        Write-Log -Level Error -Message "DataTable OnSelectionChange error: $($Exception.Message)" -Data $Exception.Context
                                    }
                                }
                                Request-TuiRefresh
                            }
                            return $true
                        }
                    }
                }
                
                # Filter text input
                if ($self.FilterMode) {
                    switch ($Key.Key) {
                        ([ConsoleKey]::Escape) {
                            $self.FilterMode = $false
                            Request-TuiRefresh
                            return $true
                        }
                        ([ConsoleKey]::Enter) {
                            $self.FilterMode = $false
                            & $self.ProcessData -self $self
                            Request-TuiRefresh
                            return $true
                        }
                        ([ConsoleKey]::Backspace) {
                            if ($self.FilterText.Length -gt 0) {
                                $self.FilterText = $self.FilterText.Substring(0, $self.FilterText.Length - 1)
                                & $self.ProcessData -self $self
                                Request-TuiRefresh
                            }
                            return $true
                        }
                        default {
                            if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar)) {
                                $self.FilterText += $Key.KeyChar
                                & $self.ProcessData -self $self
                                Request-TuiRefresh
                                return $true
                            }
                        }
                    }
                    return $false
                }
                
                # Normal navigation
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) {
                        if ($self.SelectedRow -gt 0) {
                            $self.SelectedRow--
                            
                            # Adjust page if needed
                            if ($self.SelectedRow -lt ($self.CurrentPage * $self.PageSize)) {
                                $self.CurrentPage--
                            }
                            
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::DownArrow) {
                        if ($self.SelectedRow -lt ($self.ProcessedData.Count - 1)) {
                            $self.SelectedRow++
                            
                            # Adjust page if needed
                            if ($self.SelectedRow -ge (($self.CurrentPage + 1) * $self.PageSize)) {
                                $self.CurrentPage++
                            }
                            
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::PageUp) {
                        if ($self.CurrentPage -gt 0) {
                            $self.CurrentPage--
                            $self.SelectedRow = $self.CurrentPage * $self.PageSize
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::PageDown) {
                        $totalPages = [Math]::Ceiling($self.ProcessedData.Count / [Math]::Max(1, $self.PageSize))
                        if ($self.CurrentPage -lt ($totalPages - 1)) {
                            $self.CurrentPage++
                            $self.SelectedRow = $self.CurrentPage * $self.PageSize
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::Home) {
                        $self.SelectedRow = 0
                        $self.CurrentPage = 0
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::End) {
                        $self.SelectedRow = $self.ProcessedData.Count - 1
                        $self.CurrentPage = [Math]::Floor($self.SelectedRow / [Math]::Max(1, $self.PageSize))
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::Spacebar) {
                        if ($self.MultiSelect) {
                            if ($self.SelectedRows -contains $self.SelectedRow) {
                                $self.SelectedRows = @($self.SelectedRows | Where-Object { $_ -ne $self.SelectedRow })
                            } else {
                                $self.SelectedRows += $self.SelectedRow
                            }
                            if ($self.OnSelectionChange) {
                                Invoke-WithErrorHandling -Component "$($self.Name).OnSelectionChange" -ScriptBlock {
                                    & $self.OnSelectionChange -SelectedRows $self.SelectedRows
                                } -Context @{ Component = $self.Name; SelectedRows = $self.SelectedRows } -ErrorHandler {
                                    param($Exception)
                                    Write-Log -Level Error -Message "DataTable OnSelectionChange error: $($Exception.Message)" -Data $Exception.Context
                                }
                            }
                            Request-TuiRefresh
                        } elseif ($self.AllowSort) {
                            # Toggle sort direction
                            if ($self.SortDirection -eq "Ascending") {
                                $self.SortDirection = "Descending"
                            } else {
                                $self.SortDirection = "Ascending"
                            }
                            & $self.ProcessData -self $self
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::Enter) {
                        if ($self.OnRowSelect -and $self.ProcessedData.Count -gt 0) {
                            Invoke-WithErrorHandling -Component "$($self.Name).OnRowSelect" -ScriptBlock {
                                $selectedData = if ($self.MultiSelect) {
                                    @($self.SelectedRows | ForEach-Object { $self.ProcessedData[$_] })
                                } else {
                                    $self.ProcessedData[$self.SelectedRow]
                                }
                                & $self.OnRowSelect -SelectedData $selectedData -SelectedIndex $self.SelectedRow
                            } -Context @{ Component = $self.Name; SelectedRow = $self.SelectedRow; MultiSelect = $self.MultiSelect } -ErrorHandler {
                                param($Exception)
                                Write-Log -Level Error -Message "DataTable OnRowSelect error: $($Exception.Message)" -Data $Exception.Context
                            }
                        }
                        return $true
                    }
                    ([ConsoleKey]::F) {
                        if ($self.AllowFilter) {
                            $self.FilterMode = $true
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    default {
                        # Number keys for column sorting
                        if ($Key.KeyChar -match '\d' -and $self.AllowSort) {
                            $colIndex = [int]$Key.KeyChar.ToString() - 1
                            if ($colIndex -ge 0 -and $colIndex -lt $self.Columns.Count) {
                                $col = $self.Columns[$colIndex]
                                if ($col.Sortable -ne $false) {
                                    if ($self.SortColumn -eq $col.Name) {
                                        # Toggle direction
                                        $self.SortDirection = if ($self.SortDirection -eq "Ascending") { "Descending" } else { "Ascending" }
                                    } else {
                                        $self.SortColumn = $col.Name
                                        $self.SortDirection = "Ascending"
                                    }
                                    & $self.ProcessData -self $self
                                    Request-TuiRefresh
                                }
                            }
                            return $true
                        }
                    }
                }
            } catch {
                Write-Log -Level Error -Message "DataTable HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
        
        # Public methods
        RefreshData = {
            param($self)
            Invoke-WithErrorHandling -Component "$($self.Name).RefreshData" -ScriptBlock {
                & $self.ProcessData -self $self
                Request-TuiRefresh
            } -Context @{ Component = $self.Name } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "DataTable RefreshData error: $($Exception.Message)" -Data $Exception.Context
            }
        }
        
        SetFilter = {
            param($self, $FilterText, $FilterColumn)
            Invoke-WithErrorHandling -Component "$($self.Name).SetFilter" -ScriptBlock {
                $self.FilterText = $FilterText
                $self.FilterColumn = $FilterColumn
                & $self.ProcessData -self $self
                Request-TuiRefresh
            } -Context @{ Component = $self.Name; FilterText = $FilterText; FilterColumn = $FilterColumn } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "DataTable SetFilter error: $($Exception.Message)" -Data $Exception.Context
            }
        }
        
        ExportData = {
            param($self, $Format = "CSV", $FilePath)
            Invoke-WithErrorHandling -Component "$($self.Name).ExportData" -ScriptBlock {
                $exportData = if ($self.FilterText) { $self.ProcessedData } else { $self.Data }
                
                switch ($Format.ToUpper()) {
                    "CSV" {
                        $exportData | Export-Csv -Path $FilePath -NoTypeInformation
                    }
                    "JSON" {
                        $exportData | ConvertTo-Json -Depth 10 | Set-Content -Path $FilePath
                    }
                    "HTML" {
                        # Simple HTML table export
                        $html = "<table border='1'><tr>"
                        foreach ($col in $self.Columns) {
                            $headerText = if ($col.Header) { $col.Header } else { $col.Name }
                            $html += "<th>$headerText</th>"
                        }
                        $html += "</tr>"
                        
                        foreach ($row in $exportData) {
                            $html += "<tr>"
                            foreach ($col in $self.Columns) {
                                $value = $row."$($col.Name)"
                                $html += "<td>$value</td>"
                            }
                            $html += "</tr>"
                        }
                        $html += "</table>"
                        
                        $html | Set-Content -Path $FilePath
                    }
                }
            } -Context @{ Component = $self.Name; Format = $Format; FilePath = $FilePath } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "DataTable ExportData error: $($Exception.Message)" -Data $Exception.Context
            }
        }
    }
    
    # Initialize data processing after component is created
    & $component.ProcessData -self $component
    
    return $component
}

#endregion

#region Tree View Component

function global:New-TuiTreeView {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "TreeView"
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 40 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 20 }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        RootNode = if ($null -ne $Props.RootNode) { $Props.RootNode } else { @{ Name = "Root"; Children = @(); Expanded = $true } }
        SelectedNode = $null
        SelectedPath = @()
        FlattenedNodes = @()
        ScrollOffset = 0
        ShowRoot = if ($null -ne $Props.ShowRoot) { $Props.ShowRoot } else { $true }
        IsFocusable = $true
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        Name = $Props.Name
        OnNodeSelect = $Props.OnNodeSelect
        
        # Node structure:
        # @{
        #     Name = "Node Name"
        #     Data = @{}  # Custom data
        #     Children = @()
        #     Expanded = $false
        #     Icon = "📁"  # Optional
        #     Parent = $null  # Set automatically
        # }
        
        FlattenTree = {
            param($self)
            try {
                $flattened = @()
                
                $processNode = {
                    param($Node, $Level, $Parent)
                    
                    $node.Parent = $Parent
                    $node.Level = $Level
                    
                    if ($self.ShowRoot -or $Level -gt 0) {
                        $flattened += $Node
                    }
                    
                    if ($Node.Expanded -and $Node.Children) {
                        foreach ($child in $Node.Children) {
                            & $processNode $child ($Level + 1) $Node
                        }
                    }
                }
                
                & $processNode $self.RootNode 0 $null
                $self.FlattenedNodes = $flattened
            } catch {
                Write-Log -Level Error -Message "TreeView FlattenTree error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        Render = {
            param($self)
            try {
                # Check if component is visible
                if ($self.Visible -eq $false) { return }
                
                # Flatten tree first
                & $self.FlattenTree -self $self
                
                $borderColor = if ($self.IsFocused) { 
                    Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
                } else { 
                    Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
                }
                
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor -Title " Tree View "
                
                $visibleHeight = $self.Height - 2
                $startIdx = $self.ScrollOffset
                $endIdx = [Math]::Min($self.FlattenedNodes.Count - 1, $startIdx + $visibleHeight - 1)
                
                $currentY = $self.Y + 1
                
                for ($i = $startIdx; $i -le $endIdx; $i++) {
                    $node = $self.FlattenedNodes[$i]
                    $isSelected = ($node -eq $self.SelectedNode)
                    
                    # Indentation
                    $indent = "  " * $node.Level
                    
                    # Expand/collapse indicator
                    $expandIcon = if ($node.Children -and $node.Children.Count -gt 0) {
                        if ($node.Expanded) { "▼" } else { "▶" }
                    } else {
                        " "
                    }
                    
                    # Node icon
                    $nodeIcon = if ($node.Icon) { 
                        $node.Icon 
                    } elseif ($node.Children -and $node.Children.Count -gt 0) {
                        if ($node.Expanded) { "📂" } else { "📁" }
                    } else {
                        "📄"
                    }
                    
                    # Colors
                    $fg = if ($isSelected) { Get-ThemeColor "Background" -Default ([ConsoleColor]::Black) } else { Get-ThemeColor "Primary" -Default ([ConsoleColor]::White) }
                    $bg = if ($isSelected) { Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan) } else { Get-ThemeColor "Background" -Default ([ConsoleColor]::Black) }
                    
                    # Clear line if selected
                    if ($isSelected) {
                        Write-BufferString -X ($self.X + 1) -Y $currentY -Text (" " * ($self.Width - 2)) `
                            -BackgroundColor $bg
                    }
                    
                    # Render node
                    $nodeText = "$indent$expandIcon $nodeIcon $($node.Name)"
                    if ($nodeText.Length -gt ($self.Width - 3)) {
                        $nodeText = $nodeText.Substring(0, $self.Width - 6) + "..."
                    }
                    
                    Write-BufferString -X ($self.X + 1) -Y $currentY -Text $nodeText `
                        -ForegroundColor $fg -BackgroundColor $bg
                    
                    $currentY++
                }
                
                # Scrollbar
                if ($self.FlattenedNodes.Count -gt $visibleHeight) {
                    $scrollHeight = $visibleHeight
                    $scrollPos = if ($self.FlattenedNodes.Count -gt 1) {
                        $selectedIdx = [array]::IndexOf($self.FlattenedNodes, $self.SelectedNode)
                        [Math]::Floor(($selectedIdx / ($self.FlattenedNodes.Count - 1)) * ($scrollHeight - 1))
                    } else { 0 }
                    
                    for ($i = 0; $i -lt $scrollHeight; $i++) {
                        $char = if ($i -eq $scrollPos) { "█" } else { "│" }
                        $color = if ($i -eq $scrollPos) { Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan) } else { Get-ThemeColor "Subtle" -Default ([ConsoleColor]::DarkGray) }
                        Write-BufferString -X ($self.X + $self.Width - 2) -Y ($self.Y + 1 + $i) `
                            -Text $char -ForegroundColor $color
                    }
                }
            } catch {
                Write-Log -Level Error -Message "TreeView Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                if ($self.FlattenedNodes.Count -eq 0) { return $false }
                
                $currentIdx = if ($self.SelectedNode) {
                    [array]::IndexOf($self.FlattenedNodes, $self.SelectedNode)
                } else { 0 }
                
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) {
                        if ($currentIdx -gt 0) {
                            $currentIdx--
                            $self.SelectedNode = $self.FlattenedNodes[$currentIdx]
                            
                            # Adjust scroll
                            if ($currentIdx -lt $self.ScrollOffset) {
                                $self.ScrollOffset = $currentIdx
                            }
                            
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::DownArrow) {
                        if ($currentIdx -lt ($self.FlattenedNodes.Count - 1)) {
                            $currentIdx++
                            $self.SelectedNode = $self.FlattenedNodes[$currentIdx]
                            
                            # Adjust scroll
                            $visibleHeight = $self.Height - 2
                            if ($currentIdx -ge ($self.ScrollOffset + $visibleHeight)) {
                                $self.ScrollOffset = $currentIdx - $visibleHeight + 1
                            }
                            
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::LeftArrow) {
                        if ($self.SelectedNode) {
                            if ($self.SelectedNode.Expanded -and $self.SelectedNode.Children) {
                                # Collapse
                                $self.SelectedNode.Expanded = $false
                                Request-TuiRefresh
                            } elseif ($self.SelectedNode.Parent) {
                                # Move to parent
                                $self.SelectedNode = $self.SelectedNode.Parent
                                Request-TuiRefresh
                            }
                        }
                        return $true
                    }
                    ([ConsoleKey]::RightArrow) {
                        if ($self.SelectedNode -and $self.SelectedNode.Children -and $self.SelectedNode.Children.Count -gt 0) {
                            if (-not $self.SelectedNode.Expanded) {
                                # Expand
                                $self.SelectedNode.Expanded = $true
                                Request-TuiRefresh
                            } else {
                                # Move to first child
                                $self.SelectedNode = $self.SelectedNode.Children[0]
                                Request-TuiRefresh
                            }
                        }
                        return $true
                    }
                    ([ConsoleKey]::Spacebar) {
                        if ($self.SelectedNode -and $self.SelectedNode.Children -and $self.SelectedNode.Children.Count -gt 0) {
                            $self.SelectedNode.Expanded = -not $self.SelectedNode.Expanded
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::Enter) {
                        if ($self.OnNodeSelect -and $self.SelectedNode) {
                            Invoke-WithErrorHandling -Component "$($self.Name).OnNodeSelect" -ScriptBlock {
                                # Build path
                                $path = @()
                                $current = $self.SelectedNode
                                while ($current) {
                                    $path = @($current.Name) + $path
                                    $current = $current.Parent
                                }
                                
                                & $self.OnNodeSelect -Node $self.SelectedNode -Path $path
                            } -Context @{ Component = $self.Name; SelectedNode = $self.SelectedNode.Name } -ErrorHandler {
                                param($Exception)
                                Write-Log -Level Error -Message "TreeView OnNodeSelect error: $($Exception.Message)" -Data $Exception.Context
                            }
                        }
                        return $true
                    }
                    ([ConsoleKey]::Home) {
                        if ($self.FlattenedNodes.Count -gt 0) {
                            $self.SelectedNode = $self.FlattenedNodes[0]
                            $self.ScrollOffset = 0
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::End) {
                        if ($self.FlattenedNodes.Count -gt 0) {
                            $self.SelectedNode = $self.FlattenedNodes[-1]
                            $visibleHeight = $self.Height - 2
                            $self.ScrollOffset = [Math]::Max(0, $self.FlattenedNodes.Count - $visibleHeight)
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    { $_ -in @([ConsoleKey]::Add, [ConsoleKey]::OemPlus) } {
                        # Expand all
                        $expandAll = {
                            param($Node)
                            $Node.Expanded = $true
                            foreach ($child in $Node.Children) {
                                & $expandAll $child
                            }
                        }
                        & $expandAll $self.RootNode
                        Request-TuiRefresh
                        return $true
                    }
                    { $_ -in @([ConsoleKey]::Subtract, [ConsoleKey]::OemMinus) } {
                        # Collapse all
                        $collapseAll = {
                            param($Node)
                            $Node.Expanded = $false
                            foreach ($child in $Node.Children) {
                                & $collapseAll $child
                            }
                        }
                        & $collapseAll $self.RootNode
                        $self.RootNode.Expanded = $true  # Keep root expanded
                        Request-TuiRefresh
                        return $true
                    }
                }
            } catch {
                Write-Log -Level Error -Message "TreeView HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
        
        # Public methods
        AddNode = {
            param($self, $ParentNode, $NewNode)
            Invoke-WithErrorHandling -Component "$($self.Name).AddNode" -ScriptBlock {
                if (-not $ParentNode.Children) {
                    $ParentNode.Children = @()
                }
                $ParentNode.Children += $NewNode
                $NewNode.Parent = $ParentNode
                Request-TuiRefresh
            } -Context @{ Component = $self.Name; ParentNode = $ParentNode.Name; NewNode = $NewNode.Name } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "TreeView AddNode error: $($Exception.Message)" -Data $Exception.Context
            }
        }
        
        RemoveNode = {
            param($self, $Node)
            Invoke-WithErrorHandling -Component "$($self.Name).RemoveNode" -ScriptBlock {
                if ($Node.Parent) {
                    $Node.Parent.Children = @($Node.Parent.Children | Where-Object { $_ -ne $Node })
                    if ($self.SelectedNode -eq $Node) {
                        $self.SelectedNode = $Node.Parent
                    }
                    Request-TuiRefresh
                }
            } -Context @{ Component = $self.Name; Node = $Node.Name } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "TreeView RemoveNode error: $($Exception.Message)" -Data $Exception.Context
            }
        }
        
        FindNode = {
            param($self, $Predicate)
            Invoke-WithErrorHandling -Component "$($self.Name).FindNode" -ScriptBlock {
                $find = {
                    param($Node)
                    if (& $Predicate $Node) { return $Node }
                    foreach ($child in $Node.Children) {
                        $found = & $find $child
                        if ($found) { return $found }
                    }
                    return $null
                }
                
                return & $find $self.RootNode
            } -Context @{ Component = $self.Name } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "TreeView FindNode error: $($Exception.Message)" -Data $Exception.Context
                return $null
            }
        }
    }
    
    return $component
}

#endregion

Export-ModuleMember -Function @(
    'New-TuiDataTable',
    'New-TuiTreeView'
)
# Advanced Input Components Module
# Enhanced input components from the TUI Upgrade Roadmap

#region DateTime Components with Calendar Grid

function global:New-TuiCalendarPicker {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "CalendarPicker"
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 30 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 10 }
        Value = if ($null -ne $Props.Value) { $Props.Value } else { (Get-Date) }
        Mode = if ($null -ne $Props.Mode) { $Props.Mode } else { "Date" } # Date, DateTime, Time
        IsFocusable = $true
        CurrentView = "Day"  # Day, Month, Year
        SelectedDate = if ($null -ne $Props.Value) { $Props.Value } else { (Get-Date) }
        ViewDate = if ($null -ne $Props.Value) { $Props.Value } else { (Get-Date) }
        Name = $Props.Name
        OnChange = $Props.OnChange
        OnSelect = $Props.OnSelect
        
        Render = {
            param($self)
            try {
                $borderColor = if ($self.IsFocused) { 
                    Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
                } else { 
                    Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
                }
                
                # Main container
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor -Title " Calendar "
                
                # Header with navigation
                $headerY = $self.Y + 1
                $monthYear = $self.ViewDate.ToString("MMMM yyyy")
                $headerX = $self.X + [Math]::Floor(($self.Width - $monthYear.Length) / 2)
                
                Write-BufferString -X ($self.X + 2) -Y $headerY -Text "◄" -ForegroundColor $borderColor
                Write-BufferString -X $headerX -Y $headerY -Text $monthYear -ForegroundColor (Get-ThemeColor "Header")
                Write-BufferString -X ($self.X + $self.Width - 3) -Y $headerY -Text "►" -ForegroundColor $borderColor
                
                # Day headers
                $dayHeaderY = $headerY + 2
                $days = @("Su", "Mo", "Tu", "We", "Th", "Fr", "Sa")
                $dayWidth = 4
                $startX = $self.X + 2
                
                for ($i = 0; $i -lt $days.Count; $i++) {
                    Write-BufferString -X ($startX + ($i * $dayWidth)) -Y $dayHeaderY `
                        -Text $days[$i] -ForegroundColor (Get-ThemeColor "Subtle")
                }
                
                # Calendar grid
                $firstDay = Get-Date -Year $self.ViewDate.Year -Month $self.ViewDate.Month -Day 1
                $startDayOfWeek = [int]$firstDay.DayOfWeek
                $daysInMonth = [DateTime]::DaysInMonth($self.ViewDate.Year, $self.ViewDate.Month)
                
                $currentDay = 1
                $calendarY = $dayHeaderY + 1
                
                for ($week = 0; $week -lt 6; $week++) {
                    if ($currentDay -gt $daysInMonth) { break }
                    
                    for ($dayOfWeek = 0; $dayOfWeek -lt 7; $dayOfWeek++) {
                        $x = $startX + ($dayOfWeek * $dayWidth)
                        
                        if ($week -eq 0 -and $dayOfWeek -lt $startDayOfWeek) {
                            continue
                        }
                        
                        if ($currentDay -le $daysInMonth) {
                            $isSelected = ($currentDay -eq $self.SelectedDate.Day -and 
                                         $self.ViewDate.Month -eq $self.SelectedDate.Month -and 
                                         $self.ViewDate.Year -eq $self.SelectedDate.Year)
                            
                            $isToday = ($currentDay -eq (Get-Date).Day -and 
                                      $self.ViewDate.Month -eq (Get-Date).Month -and 
                                      $self.ViewDate.Year -eq (Get-Date).Year)
                            
                            $fg = if ($isSelected) { 
                                Get-ThemeColor "Background" 
                            } elseif ($isToday) { 
                                Get-ThemeColor "Accent" 
                            } else { 
                                Get-ThemeColor "Primary" 
                            }
                            
                            $bg = if ($isSelected) { 
                                Get-ThemeColor "Accent" 
                            } else { 
                                Get-ThemeColor "Background" 
                            }
                            
                            $dayText = $currentDay.ToString().PadLeft(2)
                            Write-BufferString -X $x -Y ($calendarY + $week) -Text $dayText `
                                -ForegroundColor $fg -BackgroundColor $bg
                            
                            $currentDay++
                        }
                    }
                }
                
                # Time picker if in DateTime mode
                if ($self.Mode -eq "DateTime") {
                    $timeY = $self.Y + $self.Height - 2
                    $timeStr = $self.SelectedDate.ToString("HH:mm")
                    Write-BufferString -X ($self.X + 2) -Y $timeY -Text "Time: $timeStr" `
                        -ForegroundColor (Get-ThemeColor "Primary")
                }
            } catch {
                Write-Log -Level Error -Message "CalendarPicker Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $handled = $true
                $date = $self.SelectedDate
                $viewDate = $self.ViewDate
                
                switch ($Key.Key) {
                    ([ConsoleKey]::LeftArrow) {
                        if ($Key.Modifiers -band [ConsoleModifiers]::Control) {
                            # Previous month
                            $self.ViewDate = $viewDate.AddMonths(-1)
                        } else {
                            # Previous day
                            $date = $date.AddDays(-1)
                            if ($date.Month -ne $viewDate.Month) {
                                $self.ViewDate = $date
                            }
                        }
                    }
                    ([ConsoleKey]::RightArrow) {
                        if ($Key.Modifiers -band [ConsoleModifiers]::Control) {
                            # Next month
                            $self.ViewDate = $viewDate.AddMonths(1)
                        } else {
                            # Next day
                            $date = $date.AddDays(1)
                            if ($date.Month -ne $viewDate.Month) {
                                $self.ViewDate = $date
                            }
                        }
                    }
                    ([ConsoleKey]::UpArrow) {
                        $date = $date.AddDays(-7)
                        if ($date.Month -ne $viewDate.Month) {
                            $self.ViewDate = $date
                        }
                    }
                    ([ConsoleKey]::DownArrow) {
                        $date = $date.AddDays(7)
                        if ($date.Month -ne $viewDate.Month) {
                            $self.ViewDate = $date
                        }
                    }
                    ([ConsoleKey]::PageUp) {
                        $self.ViewDate = $viewDate.AddMonths(-1)
                        $date = Get-Date -Year $self.ViewDate.Year -Month $self.ViewDate.Month `
                            -Day ([Math]::Min($date.Day, [DateTime]::DaysInMonth($self.ViewDate.Year, $self.ViewDate.Month)))
                    }
                    ([ConsoleKey]::PageDown) {
                        $self.ViewDate = $viewDate.AddMonths(1)
                        $date = Get-Date -Year $self.ViewDate.Year -Month $self.ViewDate.Month `
                            -Day ([Math]::Min($date.Day, [DateTime]::DaysInMonth($self.ViewDate.Year, $self.ViewDate.Month)))
                    }
                    ([ConsoleKey]::Home) {
                        $date = Get-Date
                        $self.ViewDate = $date
                    }
                    ([ConsoleKey]::Enter) {
                        if ($self.OnSelect) {
                            Invoke-WithErrorHandling -Component "$($self.Name).OnSelect" -ScriptBlock {
                                & $self.OnSelect -Date $date
                            } -Context @{ Component = $self.Name; SelectedDate = $date } -ErrorHandler {
                                param($Exception)
                                Write-Log -Level Error -Message "CalendarPicker OnSelect error: $($Exception.Message)" -Data $Exception.Context
                            }
                        }
                    }
                    default {
                        $handled = $false
                    }
                }
                
                if ($handled) {
                    $self.SelectedDate = $date
                    if ($self.OnChange) {
                        Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock {
                            & $self.OnChange -NewValue $date
                        } -Context @{ Component = $self.Name; NewValue = $date } -ErrorHandler {
                            param($Exception)
                            Write-Log -Level Error -Message "CalendarPicker OnChange error: $($Exception.Message)" -Data $Exception.Context
                        }
                    }
                    Request-TuiRefresh
                }
                
                return $handled
            } catch {
                Write-Log -Level Error -Message "CalendarPicker HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
    }
    
    return $component
}

#endregion

#region Enhanced Dropdown with Search

function global:New-TuiSearchableDropdown {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "SearchableDropdown"
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 30 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 3 }
        Options = if ($null -ne $Props.Options) { $Props.Options } else { @() }
        Value = $Props.Value
        Placeholder = if ($null -ne $Props.Placeholder) { $Props.Placeholder } else { "Type to search..." }
        MaxDisplayItems = if ($null -ne $Props.MaxDisplayItems) { $Props.MaxDisplayItems } else { 5 }
        AllowCustomValue = if ($null -ne $Props.AllowCustomValue) { $Props.AllowCustomValue } else { $false }
        IsFocusable = $true
        IsOpen = $false
        SearchText = ""
        FilteredOptions = @()
        SelectedIndex = 0
        Name = $Props.Name
        OnChange = $Props.OnChange
        
        Render = {
            param($self)
            try {
                $borderColor = if ($self.IsFocused) { 
                    Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
                } else { 
                    Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
                }
                
                # Main dropdown box
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor
                
                # Display text
                $displayText = ""
                if ($self.IsOpen) {
                    $displayText = $self.SearchText
                    if ([string]::IsNullOrEmpty($displayText) -and -not $self.IsFocused) {
                        $displayText = $self.Placeholder
                    }
                } else {
                    if ($self.Value) {
                        $selected = $self.Options | Where-Object { $_.Value -eq $self.Value } | Select-Object -First 1
                        if ($selected) {
                            $displayText = $selected.Display
                        } else {
                            $displayText = $self.Value.ToString()
                        }
                    } else {
                        $displayText = "Select..."
                    }
                }
                
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $displayText
                
                # Dropdown indicator
                $indicator = if ($self.IsOpen) { "▲" } else { "▼" }
                Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text $indicator `
                    -ForegroundColor $borderColor
                
                # Cursor for search mode
                if ($self.IsOpen -and $self.IsFocused) {
                    $cursorX = $self.X + 2 + $self.SearchText.Length
                    if ($cursorX -lt ($self.X + $self.Width - 3)) {
                        Write-BufferString -X $cursorX -Y ($self.Y + 1) -Text "_" `
                            -BackgroundColor (Get-ThemeColor "Accent")
                    }
                }
                
                # Options dropdown
                if ($self.IsOpen -and $self.FilteredOptions.Count -gt 0) {
                    $dropHeight = [Math]::Min($self.FilteredOptions.Count, $self.MaxDisplayItems) + 2
                    Write-BufferBox -X $self.X -Y ($self.Y + $self.Height) -Width $self.Width -Height $dropHeight `
                        -BorderColor $borderColor -BackgroundColor (Get-ThemeColor "Background")
                    
                    $startIdx = 0
                    if ($self.SelectedIndex -ge $self.MaxDisplayItems) {
                        $startIdx = $self.SelectedIndex - $self.MaxDisplayItems + 1
                    }
                    
                    $endIdx = [Math]::Min($startIdx + $self.MaxDisplayItems - 1, $self.FilteredOptions.Count - 1)
                    
                    for ($i = $startIdx; $i -le $endIdx; $i++) {
                        $option = $self.FilteredOptions[$i]
                        $y = $self.Y + $self.Height + 1 + ($i - $startIdx)
                        
                        $isSelected = ($i -eq $self.SelectedIndex)
                        $fg = if ($isSelected) { Get-ThemeColor "Background" } else { Get-ThemeColor "Primary" }
                        $bg = if ($isSelected) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Background" }
                        
                        $text = $option.Display
                        if ($text.Length -gt ($self.Width - 4)) {
                            $text = $text.Substring(0, $self.Width - 7) + "..."
                        }
                        
                        # Highlight matching text
                        if ($self.SearchText.Length -gt 0 -and -not $isSelected) {
                            $matchIndex = $text.IndexOf($self.SearchText, [StringComparison]::OrdinalIgnoreCase)
                            if ($matchIndex -ge 0) {
                                # Draw text before match
                                if ($matchIndex -gt 0) {
                                    Write-BufferString -X ($self.X + 2) -Y $y `
                                        -Text $text.Substring(0, $matchIndex) -ForegroundColor $fg
                                }
                                
                                # Draw matching text highlighted
                                Write-BufferString -X ($self.X + 2 + $matchIndex) -Y $y `
                                    -Text $text.Substring($matchIndex, $self.SearchText.Length) `
                                    -ForegroundColor (Get-ThemeColor "Warning")
                                
                                # Draw text after match
                                $afterMatch = $matchIndex + $self.SearchText.Length
                                if ($afterMatch -lt $text.Length) {
                                    Write-BufferString -X ($self.X + 2 + $afterMatch) -Y $y `
                                        -Text $text.Substring($afterMatch) -ForegroundColor $fg
                                }
                                
                                continue
                            }
                        }
                        
                        Write-BufferString -X ($self.X + 2) -Y $y -Text $text `
                            -ForegroundColor $fg -BackgroundColor $bg
                    }
                    
                    # Scrollbar if needed
                    if ($self.FilteredOptions.Count -gt $self.MaxDisplayItems) {
                        $scrollHeight = $self.MaxDisplayItems
                        $scrollPos = [Math]::Floor(($self.SelectedIndex / ($self.FilteredOptions.Count - 1)) * ($scrollHeight - 1))
                        
                        for ($i = 0; $i -lt $scrollHeight; $i++) {
                            $char = if ($i -eq $scrollPos) { "█" } else { "│" }
                            $color = if ($i -eq $scrollPos) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Subtle" }
                            Write-BufferString -X ($self.X + $self.Width - 2) -Y ($self.Y + $self.Height + 1 + $i) `
                                -Text $char -ForegroundColor $color
                        }
                    }
                }
            } catch {
                Write-Log -Level Error -Message "SearchableDropdown Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        FilterOptions = {
            try {
                if ([string]::IsNullOrEmpty($this.SearchText)) {
                    $this.FilteredOptions = $this.Options
                } else {
                    $this.FilteredOptions = @($this.Options | Where-Object {
                        $_.Display -like "*$($this.SearchText)*"
                    })
                    
                    # Add custom value option if allowed and no exact match
                    if ($this.AllowCustomValue) {
                        $exactMatch = $this.FilteredOptions | Where-Object { $_.Display -eq $this.SearchText }
                        if (-not $exactMatch) {
                            $this.FilteredOptions = @(@{
                                Display = $this.SearchText
                                Value = $this.SearchText
                                IsCustom = $true
                            }) + $this.FilteredOptions
                        }
                    }
                }
                
                # Reset selection to first item
                $this.SelectedIndex = 0
            } catch {
                Write-Log -Level Error -Message "SearchableDropdown FilterOptions error for '$($this.Name)': $_" -Data @{ Component = $this.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                if (-not $self.IsOpen) {
                    switch ($Key.Key) {
                        { $_ -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar, [ConsoleKey]::DownArrow) } {
                            $self.IsOpen = $true
                            $self.SearchText = ""
                            & $self.FilterOptions
                            Request-TuiRefresh
                            return $true
                        }
                    }
                    return $false
                }
                
                # Handle open dropdown
                switch ($Key.Key) {
                    ([ConsoleKey]::Escape) {
                        $self.IsOpen = $false
                        $self.SearchText = ""
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::Enter) {
                        if ($self.FilteredOptions.Count -gt 0) {
                            $selected = $self.FilteredOptions[$self.SelectedIndex]
                            if ($self.OnChange) {
                                Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock {
                                    & $self.OnChange -NewValue $selected.Value -Option $selected
                                } -Context @{ Component = $self.Name; NewValue = $selected.Value; Option = $selected } -ErrorHandler {
                                    param($Exception)
                                    Write-Log -Level Error -Message "SearchableDropdown OnChange error: $($Exception.Message)" -Data $Exception.Context
                                }
                            }
                            $self.Value = $selected.Value
                            $self.IsOpen = $false
                            $self.SearchText = ""
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::UpArrow) {
                        if ($self.SelectedIndex -gt 0) {
                            $self.SelectedIndex--
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::DownArrow) {
                        if ($self.SelectedIndex -lt ($self.FilteredOptions.Count - 1)) {
                            $self.SelectedIndex++
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::Backspace) {
                        if ($self.SearchText.Length -gt 0) {
                            $self.SearchText = $self.SearchText.Substring(0, $self.SearchText.Length - 1)
                            & $self.FilterOptions
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    default {
                        if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar)) {
                            $self.SearchText += $Key.KeyChar
                            & $self.FilterOptions
                            Request-TuiRefresh
                            return $true
                        }
                    }
                }
            } catch {
                Write-Log -Level Error -Message "SearchableDropdown HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
    }
    
    return $component
}

#endregion

#region Multi-Select Components

function global:New-TuiMultiSelect {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "MultiSelect"
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 30 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 10 }
        Options = if ($null -ne $Props.Options) { $Props.Options } else { @() }
        SelectedValues = if ($null -ne $Props.SelectedValues) { $Props.SelectedValues } else { @() }
        Title = if ($null -ne $Props.Title) { $Props.Title } else { "Select items" }
        AllowSelectAll = if ($null -ne $Props.AllowSelectAll) { $Props.AllowSelectAll } else { $true }
        IsFocusable = $true
        SelectedIndex = 0
        ScrollOffset = 0
        Name = $Props.Name
        OnChange = $Props.OnChange
        OnSubmit = $Props.OnSubmit
        
        Render = {
            param($self)
            try {
                $borderColor = if ($self.IsFocused) { 
                    Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
                } else { 
                    Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
                }
                
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor -Title " $($self.Title) "
                
                # Select all option
                $currentY = $self.Y + 1
                if ($self.AllowSelectAll) {
                    $allSelected = $self.Options.Count -eq $self.SelectedValues.Count
                    $checkbox = if ($allSelected) { "[X]" } else { "[ ]" }
                    $fg = if ($self.SelectedIndex -eq -1) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
                    Write-BufferString -X ($self.X + 2) -Y $currentY -Text "$checkbox Select All" `
                        -ForegroundColor $fg
                    $currentY += 2
                }
                
                # Options
                $visibleHeight = $self.Height - 4
                if ($self.AllowSelectAll) { $visibleHeight -= 2 }
                
                $startIdx = $self.ScrollOffset
                $endIdx = [Math]::Min($self.Options.Count - 1, $startIdx + $visibleHeight - 1)
                
                for ($i = $startIdx; $i -le $endIdx; $i++) {
                    $option = $self.Options[$i]
                    $isChecked = $self.SelectedValues -contains $option.Value
                    $isHighlighted = ($i -eq $self.SelectedIndex)
                    
                    $checkbox = if ($isChecked) { "[X]" } else { "[ ]" }
                    $fg = if ($isHighlighted) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Primary" }
                    
                    $text = "$checkbox $($option.Display)"
                    if ($text.Length -gt ($self.Width - 4)) {
                        $text = $text.Substring(0, $self.Width - 7) + "..."
                    }
                    
                    Write-BufferString -X ($self.X + 2) -Y $currentY -Text $text -ForegroundColor $fg
                    $currentY++
                }
                
                # Status line
                $statusY = $self.Y + $self.Height - 2
                $statusText = "$($self.SelectedValues.Count) of $($self.Options.Count) selected"
                Write-BufferString -X ($self.X + 2) -Y $statusY -Text $statusText `
                    -ForegroundColor (Get-ThemeColor "Subtle")
            } catch {
                Write-Log -Level Error -Message "MultiSelect Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $maxIndex = $self.Options.Count - 1
                if ($self.AllowSelectAll) { $maxIndex++ }
                
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) {
                        if ($self.AllowSelectAll -and $self.SelectedIndex -eq 0) {
                            $self.SelectedIndex = -1
                        } elseif ($self.SelectedIndex -gt 0 -or ($self.AllowSelectAll -and $self.SelectedIndex -gt -1)) {
                            $self.SelectedIndex--
                            if ($self.SelectedIndex -ge 0 -and $self.SelectedIndex -lt $self.ScrollOffset) {
                                $self.ScrollOffset = $self.SelectedIndex
                            }
                        }
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::DownArrow) {
                        if ($self.SelectedIndex -lt ($self.Options.Count - 1)) {
                            $self.SelectedIndex++
                            $visibleHeight = $self.Height - 4
                            if ($self.AllowSelectAll) { $visibleHeight -= 2 }
                            if ($self.SelectedIndex -ge ($self.ScrollOffset + $visibleHeight)) {
                                $self.ScrollOffset = $self.SelectedIndex - $visibleHeight + 1
                            }
                        }
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::Spacebar) {
                        if ($self.SelectedIndex -eq -1 -and $self.AllowSelectAll) {
                            # Toggle all
                            if ($self.SelectedValues.Count -eq $self.Options.Count) {
                                $self.SelectedValues = @()
                            } else {
                                $self.SelectedValues = @($self.Options | ForEach-Object { $_.Value })
                            }
                        } elseif ($self.SelectedIndex -ge 0) {
                            # Toggle individual
                            $option = $self.Options[$self.SelectedIndex]
                            if ($self.SelectedValues -contains $option.Value) {
                                $self.SelectedValues = @($self.SelectedValues | Where-Object { $_ -ne $option.Value })
                            } else {
                                $self.SelectedValues += $option.Value
                            }
                        }
                        
                        if ($self.OnChange) {
                            Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock {
                                & $self.OnChange -SelectedValues $self.SelectedValues
                            } -Context @{ Component = $self.Name; SelectedValues = $self.SelectedValues } -ErrorHandler {
                                param($Exception)
                                Write-Log -Level Error -Message "MultiSelect OnChange error: $($Exception.Message)" -Data $Exception.Context
                            }
                        }
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::Enter) {
                        if ($self.OnSubmit) {
                            Invoke-WithErrorHandling -Component "$($self.Name).OnSubmit" -ScriptBlock {
                                & $self.OnSubmit -SelectedValues $self.SelectedValues
                            } -Context @{ Component = $self.Name; SelectedValues = $self.SelectedValues } -ErrorHandler {
                                param($Exception)
                                Write-Log -Level Error -Message "MultiSelect OnSubmit error: $($Exception.Message)" -Data $Exception.Context
                            }
                        }
                        return $true
                    }
                }
            } catch {
                Write-Log -Level Error -Message "MultiSelect HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
    }
    
    return $component
}

#endregion

#region Numeric Input Components

function global:New-TuiNumberInput {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "NumberInput"
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 20 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 3 }
        Value = if ($null -ne $Props.Value) { $Props.Value } else { 0 }
        Min = if ($null -ne $Props.Min) { $Props.Min } else { 0 }
        Max = if ($null -ne $Props.Max) { $Props.Max } else { 100 }
        Step = if ($null -ne $Props.Step) { $Props.Step } else { 1 }
        DecimalPlaces = if ($null -ne $Props.DecimalPlaces) { $Props.DecimalPlaces } else { 0 }
        IsFocusable = $true
        TextValue = (if ($null -ne $Props.Value) { $Props.Value } else { 0 }).ToString()
        CursorPosition = 0
        Name = $Props.Name
        OnChange = $Props.OnChange
        
        Render = {
            param($self)
            try {
                $borderColor = if ($self.IsFocused) { 
                    Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
                } else { 
                    Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
                }
                
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor
                
                # Value display
                $displayValue = $self.TextValue
                if ($displayValue.Length -gt ($self.Width - 6)) {
                    $displayValue = $displayValue.Substring(0, $self.Width - 9) + "..."
                }
                
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $displayValue
                
                # Cursor
                if ($self.IsFocused -and $self.CursorPosition -le $displayValue.Length) {
                    $cursorX = $self.X + 2 + $self.CursorPosition
                    if ($cursorX -lt ($self.X + $self.Width - 4)) {
                        Write-BufferString -X $cursorX -Y ($self.Y + 1) -Text "_" `
                            -BackgroundColor (Get-ThemeColor "Accent")
                    }
                }
                
                # Spinner buttons
                Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text "▲" `
                    -ForegroundColor $borderColor
                Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text "▼" `
                    -ForegroundColor $borderColor
                
                # Min/Max indicators
                if ($self.Value -le $self.Min) {
                    Write-BufferString -X ($self.X + 1) -Y ($self.Y + 1) -Text "⊥" `
                        -ForegroundColor (Get-ThemeColor "Warning")
                }
                if ($self.Value -ge $self.Max) {
                    Write-BufferString -X ($self.X + $self.Width - 2) -Y ($self.Y + 1) -Text "⊤" `
                        -ForegroundColor (Get-ThemeColor "Warning")
                }
            } catch {
                Write-Log -Level Error -Message "NumberInput Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        ValidateAndUpdate = {
            try {
                $newValue = [double]$this.TextValue
                $newValue = [Math]::Max($this.Min, [Math]::Min($this.Max, $newValue))
                
                if ($this.DecimalPlaces -eq 0) {
                    $newValue = [Math]::Floor($newValue)
                } else {
                    $newValue = [Math]::Round($newValue, $this.DecimalPlaces)
                }
                
                $this.Value = $newValue
                $this.TextValue = $newValue.ToString("F$($this.DecimalPlaces)")
                
                if ($this.OnChange) {
                    Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock {
                        & $this.OnChange -NewValue $newValue
                    } -Context @{ Component = $this.Name; NewValue = $newValue } -ErrorHandler {
                        param($Exception)
                        Write-Log -Level Error -Message "NumberInput OnChange error: $($Exception.Message)" -Data $Exception.Context
                    }
                }
                
                return $true
            } catch {
                # Invalid input, restore previous value
                $this.TextValue = $this.Value.ToString("F$($this.DecimalPlaces)")
                Write-Log -Level Warning -Message "NumberInput ValidateAndUpdate error for '$($this.Name)': $_" -Data @{ Component = $this.Name; InputText = $this.TextValue; Exception = $_ }
                return $false
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) {
                        $self.Value = [Math]::Min($self.Max, $self.Value + $self.Step)
                        $self.TextValue = $self.Value.ToString("F$($self.DecimalPlaces)")
                        $self.CursorPosition = $self.TextValue.Length
                        if ($self.OnChange) {
                            Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock {
                                & $self.OnChange -NewValue $self.Value
                            } -Context @{ Component = $self.Name; NewValue = $self.Value } -ErrorHandler {
                                param($Exception)
                                Write-Log -Level Error -Message "NumberInput OnChange error: $($Exception.Message)" -Data $Exception.Context
                            }
                        }
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::DownArrow) {
                        $self.Value = [Math]::Max($self.Min, $self.Value - $self.Step)
                        $self.TextValue = $self.Value.ToString("F$($self.DecimalPlaces)")
                        $self.CursorPosition = $self.TextValue.Length
                        if ($self.OnChange) {
                            Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock {
                                & $self.OnChange -NewValue $self.Value
                            } -Context @{ Component = $self.Name; NewValue = $self.Value } -ErrorHandler {
                                param($Exception)
                                Write-Log -Level Error -Message "NumberInput OnChange error: $($Exception.Message)" -Data $Exception.Context
                            }
                        }
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::LeftArrow) {
                        if ($self.CursorPosition -gt 0) {
                            $self.CursorPosition--
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::RightArrow) {
                        if ($self.CursorPosition -lt $self.TextValue.Length) {
                            $self.CursorPosition++
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::Home) {
                        $self.CursorPosition = 0
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::End) {
                        $self.CursorPosition = $self.TextValue.Length
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::Backspace) {
                        if ($self.CursorPosition -gt 0) {
                            $self.TextValue = $self.TextValue.Remove($self.CursorPosition - 1, 1)
                            $self.CursorPosition--
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::Delete) {
                        if ($self.CursorPosition -lt $self.TextValue.Length) {
                            $self.TextValue = $self.TextValue.Remove($self.CursorPosition, 1)
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::Enter) {
                        & $self.ValidateAndUpdate -self $self
                        Request-TuiRefresh
                        return $true
                    }
                    default {
                        if ($Key.KeyChar -and ($Key.KeyChar -match '[\d\.\-]')) {
                            $self.TextValue = $self.TextValue.Insert($self.CursorPosition, $Key.KeyChar)
                            $self.CursorPosition++
                            Request-TuiRefresh
                            return $true
                        }
                    }
                }
            } catch {
                Write-Log -Level Error -Message "NumberInput HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
    }
    
    return $component
}

function global:New-TuiSlider {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "Slider"
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 30 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 1 }
        Value = if ($null -ne $Props.Value) { $Props.Value } else { 50 }
        Min = if ($null -ne $Props.Min) { $Props.Min } else { 0 }
        Max = if ($null -ne $Props.Max) { $Props.Max } else { 100 }
        Step = if ($null -ne $Props.Step) { $Props.Step } else { 1 }
        ShowValue = if ($null -ne $Props.ShowValue) { $Props.ShowValue } else { $true }
        IsFocusable = $true
        Name = $Props.Name
        OnChange = $Props.OnChange
        
        Render = {
            param($self)
            try {
                $fg = if ($self.IsFocused) { 
                    Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
                } else { 
                    Get-ThemeColor "Primary" -Default ([ConsoleColor]::White)
                }
                
                # Calculate position
                $range = $self.Max - $self.Min
                $percent = ($self.Value - $self.Min) / $range
                $trackWidth = $self.Width - 2
                $thumbPos = [Math]::Floor($trackWidth * $percent)
                
                # Draw track
                $track = "─" * $trackWidth
                Write-BufferString -X ($self.X + 1) -Y $self.Y -Text $track -ForegroundColor (Get-ThemeColor "Subtle")
                
                # Draw filled portion
                if ($thumbPos -gt 0) {
                    $filled = "═" * $thumbPos
                    Write-BufferString -X ($self.X + 1) -Y $self.Y -Text $filled -ForegroundColor $fg
                }
                
                # Draw thumb
                Write-BufferString -X ($self.X + 1 + $thumbPos) -Y $self.Y -Text "●" -ForegroundColor $fg
                
                # Draw bounds
                Write-BufferString -X $self.X -Y $self.Y -Text "[" -ForegroundColor $fg
                Write-BufferString -X ($self.X + $self.Width - 1) -Y $self.Y -Text "]" -ForegroundColor $fg
                
                # Show value
                if ($self.ShowValue) {
                    $valueText = $self.Value.ToString()
                    $valueX = $self.X + [Math]::Floor(($self.Width - $valueText.Length) / 2)
                    Write-BufferString -X $valueX -Y ($self.Y + 1) -Text $valueText -ForegroundColor $fg
                }
            } catch {
                Write-Log -Level Error -Message "Slider Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $handled = $true
                $oldValue = $self.Value
                
                switch ($Key.Key) {
                    ([ConsoleKey]::LeftArrow) {
                        $self.Value = [Math]::Max($self.Min, $self.Value - $self.Step)
                    }
                    ([ConsoleKey]::RightArrow) {
                        $self.Value = [Math]::Min($self.Max, $self.Value + $self.Step)
                    }
                    ([ConsoleKey]::Home) {
                        $self.Value = $self.Min
                    }
                    ([ConsoleKey]::End) {
                        $self.Value = $self.Max
                    }
                    ([ConsoleKey]::PageDown) {
                        $largeStep = [Math]::Max($self.Step, ($self.Max - $self.Min) / 10)
                        $self.Value = [Math]::Max($self.Min, $self.Value - $largeStep)
                    }
                    ([ConsoleKey]::PageUp) {
                        $largeStep = [Math]::Max($self.Step, ($self.Max - $self.Min) / 10)
                        $self.Value = [Math]::Min($self.Max, $self.Value + $largeStep)
                    }
                    default {
                        $handled = $false
                    }
                }
                
                if ($handled -and $self.Value -ne $oldValue) {
                    if ($self.OnChange) {
                        Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock {
                            & $self.OnChange -NewValue $self.Value
                        } -Context @{ Component = $self.Name; NewValue = $self.Value } -ErrorHandler {
                            param($Exception)
                            Write-Log -Level Error -Message "Slider OnChange error: $($Exception.Message)" -Data $Exception.Context
                        }
                    }
                    Request-TuiRefresh
                }
                
                return $handled
            } catch {
                Write-Log -Level Error -Message "Slider HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
    }
    
    return $component
}

#endregion

Export-ModuleMember -Function @(
    'New-TuiCalendarPicker',
    'New-TuiSearchableDropdown',
    'New-TuiMultiSelect',
    'New-TuiNumberInput',
    'New-TuiSlider'
)
# TUI Component Library - COMPLIANT VERSION
# Stateful component factories following the canonical architecture
# LEGACY New-TuiPanel has been REMOVED.

#region Basic Components

function global:New-TuiLabel {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "Label"
        IsFocusable = $false
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 10 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 1 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Text = if ($null -ne $Props.Text) { $Props.Text } else { "" }
        ForegroundColor = $Props.ForegroundColor
        Name = $Props.Name
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $fg = if ($self.ForegroundColor) { $self.ForegroundColor } else { Get-ThemeColor "Primary" }
                Write-BufferString -X $self.X -Y $self.Y -Text $self.Text -ForegroundColor $fg
            } catch {
                Write-Log -Level Error -Message "Label Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                return $false
            } catch {
                Write-Log -Level Error -Message "Label HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
                return $false
            }
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

function global:New-TuiButton {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "Button"
        IsFocusable = $true
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 10 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 3 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Text = if ($null -ne $Props.Text) { $Props.Text } else { "Button" }
        Name = $Props.Name
        
        # Internal State
        IsPressed = $false
        
        # Event Handlers (from Props)
        OnClick = $Props.OnClick
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Primary" }
                $bgColor = if ($self.IsPressed) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Background" }
                $fgColor = if ($self.IsPressed) { Get-ThemeColor "Background" } else { $borderColor }
                
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor -BackgroundColor $bgColor
                    
                $textX = $self.X + [Math]::Floor(($self.Width - $self.Text.Length) / 2)
                Write-BufferString -X $textX -Y ($self.Y + 1) -Text $self.Text `
                    -ForegroundColor $fgColor -BackgroundColor $bgColor
            } catch {
                Write-Log -Level Error -Message "Button Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                if ($Key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                    if ($self.OnClick) {
                        Invoke-WithErrorHandling -Component "$($self.Name).OnClick" -ScriptBlock {
                            & $self.OnClick
                        } -Context @{ Component = $self.Name; Key = $Key } -ErrorHandler {
                            param($Exception)
                            Write-Log -Level Error -Message "Button OnClick error: $($Exception.Message)" -Data $Exception.Context
                        }
                    }
                    Request-TuiRefresh
                    return $true
                }
            } catch {
                Write-Log -Level Error -Message "Button HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

function global:New-TuiTextBox {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "TextBox"
        IsFocusable = $true
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 20 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 3 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Text = if ($null -ne $Props.Text) { $Props.Text } else { "" }
        Placeholder = if ($null -ne $Props.Placeholder) { $Props.Placeholder } else { "" }
        MaxLength = if ($null -ne $Props.MaxLength) { $Props.MaxLength } else { 100 }
        Name = $Props.Name
        
        # Internal State
        CursorPosition = if ($null -ne $Props.CursorPosition) { $Props.CursorPosition } else { 0 }
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height 3 -BorderColor $borderColor
                
                $displayText = if ($self.Text) { $self.Text } else { "" }
                if ([string]::IsNullOrEmpty($displayText) -and -not $self.IsFocused) { 
                    $displayText = if ($self.Placeholder) { $self.Placeholder } else { "" }
                }
                
                $maxDisplayLength = $self.Width - 4
                if ($displayText.Length -gt $maxDisplayLength) {
                    $displayText = $displayText.Substring(0, $maxDisplayLength)
                }
                
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $displayText
                
                if ($self.IsFocused -and $self.CursorPosition -le $displayText.Length) {
                    $cursorX = $self.X + 2 + $self.CursorPosition
                    Write-BufferString -X $cursorX -Y ($self.Y + 1) -Text "_" `
                        -BackgroundColor (Get-ThemeColor "Accent")
                }
            } catch {
                Write-Log -Level Error -Message "TextBox Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $text = if ($self.Text) { $self.Text } else { "" }
                $cursorPos = if ($null -ne $self.CursorPosition) { $self.CursorPosition } else { 0 }
                $oldText = $text
                
                switch ($Key.Key) {
                    ([ConsoleKey]::Backspace) { 
                        if ($cursorPos -gt 0) { 
                            $text = $text.Remove($cursorPos - 1, 1)
                            $cursorPos-- 
                        }
                    }
                    ([ConsoleKey]::Delete) { 
                        if ($cursorPos -lt $text.Length) { 
                            $text = $text.Remove($cursorPos, 1) 
                        }
                    }
                    ([ConsoleKey]::LeftArrow) { 
                        if ($cursorPos -gt 0) { $cursorPos-- }
                    }
                    ([ConsoleKey]::RightArrow) { 
                        if ($cursorPos -lt $text.Length) { $cursorPos++ }
                    }
                    ([ConsoleKey]::Home) { $cursorPos = 0 }
                    ([ConsoleKey]::End) { $cursorPos = $text.Length }
                    ([ConsoleKey]::V) {
                        # Handle Ctrl+V (paste)
                        if ($Key.Modifiers -band [ConsoleModifiers]::Control) {
                            try {
                                # Get clipboard text (Windows only)
                                $clipboardText = if (Get-Command Get-Clipboard -ErrorAction SilentlyContinue) {
                                    Get-Clipboard -Format Text -ErrorAction SilentlyContinue
                                } else {
                                    $null
                                }
                                
                                if ($clipboardText) {
                                    # Remove newlines for single-line textbox
                                    $clipboardText = $clipboardText -replace '[\r\n]+', ' '
                                    
                                    # Insert as much as will fit
                                    $remainingSpace = $self.MaxLength - $text.Length
                                    if ($remainingSpace -gt 0) {
                                        $toInsert = if ($clipboardText.Length -gt $remainingSpace) {
                                            $clipboardText.Substring(0, $remainingSpace)
                                        } else {
                                            $clipboardText
                                        }
                                        
                                        $text = $text.Insert($cursorPos, $toInsert)
                                        $cursorPos += $toInsert.Length
                                    }
                                }
                            } catch {
                                # Silently ignore clipboard errors
                                Write-Log -Level Warning -Message "TextBox clipboard paste error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
                            }
                        } else {
                            # Regular 'V' key
                            if (-not [char]::IsControl($Key.KeyChar) -and $text.Length -lt $self.MaxLength) {
                                $text = $text.Insert($cursorPos, $Key.KeyChar)
                                $cursorPos++
                            } else {
                                return $false
                            }
                        }
                    }
                    default {
                        if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar) -and $text.Length -lt $self.MaxLength) {
                            $text = $text.Insert($cursorPos, $Key.KeyChar)
                            $cursorPos++
                        } else { 
                            return $false 
                        }
                    }
                }
                
                if ($text -ne $oldText -or $cursorPos -ne $self.CursorPosition) {
                    $self.Text = $text
                    $self.CursorPosition = $cursorPos
                    
                    if ($self.OnChange) { 
                        Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock {
                            & $self.OnChange -NewValue $text
                        } -Context @{ Component = $self.Name; NewValue = $text } -ErrorHandler {
                            param($Exception)
                            Write-Log -Level Error -Message "TextBox OnChange error: $($Exception.Message)" -Data $Exception.Context
                        }
                    }
                    Request-TuiRefresh
                }
                return $true
            } catch {
                Write-Log -Level Error -Message "TextBox HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
                return $false
            }
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

function global:New-TuiCheckBox {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "CheckBox"
        IsFocusable = $true
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 20 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 1 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Text = if ($null -ne $Props.Text) { $Props.Text } else { "Checkbox" }
        Checked = if ($null -ne $Props.Checked) { $Props.Checked } else { $false }
        Name = $Props.Name
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $fg = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Primary" }
                $checkbox = if ($self.Checked) { "[X]" } else { "[ ]" }
                Write-BufferString -X $self.X -Y $self.Y -Text "$checkbox $($self.Text)" -ForegroundColor $fg
            } catch {
                Write-Log -Level Error -Message "CheckBox Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                if ($Key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                    $self.Checked = -not $self.Checked
                    
                    if ($self.OnChange) { 
                        Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock {
                            & $self.OnChange -NewValue $self.Checked 
                        } -Context @{ Component = $self.Name; NewValue = $self.Checked } -ErrorHandler {
                            param($Exception)
                            Write-Log -Level Error -Message "CheckBox OnChange error: $($Exception.Message)" -Data $Exception.Context
                        }
                    }
                    Request-TuiRefresh
                    return $true
                }
            } catch {
                Write-Log -Level Error -Message "CheckBox HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

function global:New-TuiDropdown {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "Dropdown"
        IsFocusable = $true
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 20 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 3 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 10 }
        Options = if ($null -ne $Props.Options) { $Props.Options } else { @() }
        Value = $Props.Value
        Placeholder = if ($null -ne $Props.Placeholder) { $Props.Placeholder } else { "Select..." }
        Name = $Props.Name
        
        # Internal State
        IsOpen = $false
        SelectedIndex = 0
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height 3 -BorderColor $borderColor
                
                $displayText = $self.Placeholder
                if ($self.Value -and $self.Options) {
                    $selected = $self.Options | Where-Object { $_.Value -eq $self.Value } | Select-Object -First 1
                    if ($selected) { $displayText = $selected.Display }
                }
                
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $displayText
                $indicator = if ($self.IsOpen) { "▲" } else { "▼" }
                Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text $indicator
                
                if ($self.IsOpen -and $self.Options.Count -gt 0) {
                    $listHeight = [Math]::Min($self.Options.Count + 2, 8)
                    Write-BufferBox -X $self.X -Y ($self.Y + 3) -Width $self.Width -Height $listHeight `
                        -BorderColor $borderColor -BackgroundColor (Get-ThemeColor "Background")
                    
                    $displayCount = [Math]::Min($self.Options.Count, 6)
                    for ($i = 0; $i -lt $displayCount; $i++) {
                        $option = $self.Options[$i]
                        $y = $self.Y + 4 + $i
                        $fg = if ($i -eq $self.SelectedIndex) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Primary" }
                        $bg = if ($i -eq $self.SelectedIndex) { Get-ThemeColor "Secondary" } else { Get-ThemeColor "Background" }
                        $text = $option.Display
                        if ($text.Length -gt ($self.Width - 4)) { 
                            $text = $text.Substring(0, $self.Width - 7) + "..." 
                        }
                        Write-BufferString -X ($self.X + 2) -Y $y -Text $text -ForegroundColor $fg -BackgroundColor $bg
                    }
                }
            } catch {
                Write-Log -Level Error -Message "Dropdown Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                if (-not $self.IsOpen) {
                    if ($Key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar, [ConsoleKey]::DownArrow)) {
                        $self.IsOpen = $true
                        Request-TuiRefresh
                        return $true
                    }
                } else {
                    switch ($Key.Key) {
                        ([ConsoleKey]::UpArrow) { 
                            if ($self.SelectedIndex -gt 0) { 
                                $self.SelectedIndex--
                                Request-TuiRefresh 
                            }
                            return $true 
                        }
                        ([ConsoleKey]::DownArrow) { 
                            if ($self.SelectedIndex -lt ($self.Options.Count - 1)) { 
                                $self.SelectedIndex++
                                Request-TuiRefresh 
                            }
                            return $true 
                        }
                        ([ConsoleKey]::Enter) {
                            if ($self.Options.Count -gt 0) {
                                $selected = $self.Options[$self.SelectedIndex]
                                $self.Value = $selected.Value
                                
                                if ($self.OnChange) { 
                                    Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock {
                                        & $self.OnChange -NewValue $selected.Value 
                                    } -Context @{ Component = $self.Name; NewValue = $selected.Value } -ErrorHandler {
                                        param($Exception)
                                        Write-Log -Level Error -Message "Dropdown OnChange error: $($Exception.Message)" -Data $Exception.Context
                                    }
                                }
                            }
                            $self.IsOpen = $false
                            Request-TuiRefresh
                            return $true
                        }
                        ([ConsoleKey]::Escape) { 
                            $self.IsOpen = $false
                            Request-TuiRefresh
                            return $true 
                        }
                    }
                }
            } catch {
                Write-Log -Level Error -Message "Dropdown HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

function global:New-TuiProgressBar {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "ProgressBar"
        IsFocusable = $false
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 20 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 1 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Value = if ($null -ne $Props.Value) { $Props.Value } else { 0 }
        Max = if ($null -ne $Props.Max) { $Props.Max } else { 100 }
        ShowPercent = if ($null -ne $Props.ShowPercent) { $Props.ShowPercent } else { $false }
        Name = $Props.Name
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $percent = [Math]::Min(100, [Math]::Max(0, ($self.Value / $self.Max) * 100))
                $filled = [Math]::Floor(($self.Width - 2) * ($percent / 100))
                $empty = ($self.Width - 2) - $filled
                
                $bar = "█" * $filled + "░" * $empty
                Write-BufferString -X $self.X -Y $self.Y -Text "[$bar]" -ForegroundColor (Get-ThemeColor "Accent")
                
                if ($self.ShowPercent) {
                    $percentText = "$([Math]::Round($percent))%"
                    $textX = $self.X + [Math]::Floor(($self.Width - $percentText.Length) / 2)
                    Write-BufferString -X $textX -Y $self.Y -Text $percentText -ForegroundColor (Get-ThemeColor "Primary")
                }
            } catch {
                Write-Log -Level Error -Message "ProgressBar Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                return $false
            } catch {
                Write-Log -Level Error -Message "ProgressBar HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
                return $false
            }
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

function global:New-TuiTextArea {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "TextArea"
        IsFocusable = $true
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 40 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 6 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Text = if ($null -ne $Props.Text) { $Props.Text } else { "" }
        Placeholder = if ($null -ne $Props.Placeholder) { $Props.Placeholder } else { "Enter text..." }
        WrapText = if ($null -ne $Props.WrapText) { $Props.WrapText } else { $true }
        Name = $Props.Name
        
        # Internal State
        Lines = @((if ($null -ne $Props.Text) { $Props.Text } else { "" }) -split "`n")
        CursorX = 0
        CursorY = 0
        ScrollOffset = 0
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height -BorderColor $borderColor
                
                $innerWidth = $self.Width - 4
                $innerHeight = $self.Height - 2
                $displayLines = @()
                if ($self.Lines.Count -eq 0) { $self.Lines = @("") }
                
                foreach ($line in $self.Lines) {
                    if ($self.WrapText -and $line.Length -gt $innerWidth) {
                        for ($i = 0; $i -lt $line.Length; $i += $innerWidth) {
                            $displayLines += $line.Substring($i, [Math]::Min($innerWidth, $line.Length - $i))
                        }
                    } else { 
                        $displayLines += $line 
                    }
                }
                
                if ($displayLines.Count -eq 1 -and $displayLines[0] -eq "" -and -not $self.IsFocused) {
                    Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $self.Placeholder
                    return
                }
                
                $startLine = $self.ScrollOffset
                $endLine = [Math]::Min($displayLines.Count - 1, $startLine + $innerHeight - 1)
                
                for ($i = $startLine; $i -le $endLine; $i++) {
                    $y = $self.Y + 1 + ($i - $startLine)
                    $line = $displayLines[$i]
                    Write-BufferString -X ($self.X + 2) -Y $y -Text $line
                }
                
                if ($self.IsFocused -and $self.CursorY -ge $startLine -and $self.CursorY -le $endLine) {
                    $cursorScreenY = $self.Y + 1 + ($self.CursorY - $startLine)
                    $cursorX = [Math]::Min($self.CursorX, $displayLines[$self.CursorY].Length)
                    Write-BufferString -X ($self.X + 2 + $cursorX) -Y $cursorScreenY -Text "_" `
                        -BackgroundColor (Get-ThemeColor "Accent")
                }
                
                if ($displayLines.Count -gt $innerHeight) {
                    $scrollbarHeight = $innerHeight
                    $scrollPosition = [Math]::Floor(($self.ScrollOffset / ($displayLines.Count - $innerHeight)) * ($scrollbarHeight - 1))
                    for ($i = 0; $i -lt $scrollbarHeight; $i++) {
                        $char = if ($i -eq $scrollPosition) { "█" } else { "│" }
                        $color = if ($i -eq $scrollPosition) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Subtle" }
                        Write-BufferString -X ($self.X + $self.Width - 2) -Y ($self.Y + 1 + $i) -Text $char -ForegroundColor $color
                    }
                }
            } catch {
                Write-Log -Level Error -Message "TextArea Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $lines = $self.Lines
                $cursorY = $self.CursorY
                $cursorX = $self.CursorX
                $innerHeight = $self.Height - 2
                
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) {
                        if ($cursorY -gt 0) {
                            $cursorY--
                            $cursorX = [Math]::Min($cursorX, $lines[$cursorY].Length)
                            if ($cursorY -lt $self.ScrollOffset) { 
                                $self.ScrollOffset = $cursorY 
                            }
                        }
                    }
                    ([ConsoleKey]::DownArrow) {
                        if ($cursorY -lt $lines.Count - 1) {
                            $cursorY++
                            $cursorX = [Math]::Min($cursorX, $lines[$cursorY].Length)
                            if ($cursorY -ge $self.ScrollOffset + $innerHeight) { 
                                $self.ScrollOffset = $cursorY - $innerHeight + 1 
                            }
                        }
                    }
                    ([ConsoleKey]::LeftArrow) {
                        if ($cursorX -gt 0) { 
                            $cursorX-- 
                        } elseif ($cursorY -gt 0) { 
                            $cursorY--
                            $cursorX = $lines[$cursorY].Length 
                        }
                    }
                    ([ConsoleKey]::RightArrow) {
                        if ($cursorX -lt $lines[$cursorY].Length) { 
                            $cursorX++ 
                        } elseif ($cursorY -lt $lines.Count - 1) { 
                            $cursorY++
                            $cursorX = 0 
                        }
                    }
                    ([ConsoleKey]::Home) { $cursorX = 0 }
                    ([ConsoleKey]::End) { $cursorX = $lines[$cursorY].Length }
                    ([ConsoleKey]::Enter) {
                        $currentLine = $lines[$cursorY]
                        $beforeCursor = $currentLine.Substring(0, $cursorX)
                        $afterCursor = $currentLine.Substring($cursorX)
                        $lines[$cursorY] = $beforeCursor
                        $lines = @($lines[0..$cursorY]) + @($afterCursor) + @($lines[($cursorY + 1)..($lines.Count - 1)])
                        $cursorY++
                        $cursorX = 0
                        if ($cursorY -ge $self.ScrollOffset + $innerHeight) { 
                            $self.ScrollOffset = $cursorY - $innerHeight + 1 
                        }
                    }
                    ([ConsoleKey]::Backspace) {
                        if ($cursorX -gt 0) { 
                            $lines[$cursorY] = $lines[$cursorY].Remove($cursorX - 1, 1)
                            $cursorX-- 
                        } elseif ($cursorY -gt 0) {
                            $prevLineLength = $lines[$cursorY - 1].Length
                            $lines[$cursorY - 1] += $lines[$cursorY]
                            $newLines = @()
                            for ($i = 0; $i -lt $lines.Count; $i++) { 
                                if ($i -ne $cursorY) { $newLines += $lines[$i] } 
                            }
                            $lines = $newLines
                            $cursorY--
                            $cursorX = $prevLineLength
                        }
                    }
                    ([ConsoleKey]::Delete) {
                        if ($cursorX -lt $lines[$cursorY].Length) { 
                            $lines[$cursorY] = $lines[$cursorY].Remove($cursorX, 1) 
                        } elseif ($cursorY -lt $lines.Count - 1) {
                            $lines[$cursorY] += $lines[$cursorY + 1]
                            $newLines = @()
                            for ($i = 0; $i -lt $lines.Count; $i++) { 
                                if ($i -ne ($cursorY + 1)) { $newLines += $lines[$i] } 
                            }
                            $lines = $newLines
                        }
                    }
                    ([ConsoleKey]::V) {
                        # Handle Ctrl+V (paste)
                        if ($Key.Modifiers -band [ConsoleModifiers]::Control) {
                            try {
                                # Get clipboard text (Windows only)
                                $clipboardText = if (Get-Command Get-Clipboard -ErrorAction SilentlyContinue) {
                                    Get-Clipboard -Format Text -ErrorAction SilentlyContinue
                                } else {
                                    $null
                                }
                                
                                if ($clipboardText) {
                                    # Split clipboard text into lines
                                    $clipboardLines = $clipboardText -split '[\r\n]+'
                                    
                                    if ($clipboardLines.Count -eq 1) {
                                        # Single line paste - insert at cursor
                                        $lines[$cursorY] = $lines[$cursorY].Insert($cursorX, $clipboardLines[0])
                                        $cursorX += $clipboardLines[0].Length
                                    } else {
                                        # Multi-line paste
                                        $currentLine = $lines[$cursorY]
                                        $beforeCursor = $currentLine.Substring(0, $cursorX)
                                        $afterCursor = $currentLine.Substring($cursorX)
                                        
                                        # First line
                                        $lines[$cursorY] = $beforeCursor + $clipboardLines[0]
                                        
                                        # Insert middle lines
                                        $insertLines = @()
                                        for ($i = 1; $i -lt $clipboardLines.Count - 1; $i++) {
                                            $insertLines += $clipboardLines[$i]
                                        }
                                        
                                        # Last line
                                        $lastLine = $clipboardLines[-1] + $afterCursor
                                        $insertLines += $lastLine
                                        
                                        # Insert all new lines
                                        $newLines = @()
                                        for ($i = 0; $i -le $cursorY; $i++) {
                                            $newLines += $lines[$i]
                                        }
                                        $newLines += $insertLines
                                        for ($i = $cursorY + 1; $i -lt $lines.Count; $i++) {
                                            $newLines += $lines[$i]
                                        }
                                        
                                        $lines = $newLines
                                        $cursorY += $clipboardLines.Count - 1
                                        $cursorX = $clipboardLines[-1].Length
                                    }
                                    
                                    # Adjust scroll if needed
                                    $innerHeight = $self.Height - 2
                                    if ($cursorY -ge $self.ScrollOffset + $innerHeight) { 
                                        $self.ScrollOffset = $cursorY - $innerHeight + 1 
                                    }
                                }
                            } catch {
                                # Silently ignore clipboard errors
                                Write-Log -Level Warning -Message "TextArea clipboard paste error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
                            }
                        } else {
                            # Regular 'V' key
                            if (-not [char]::IsControl($Key.KeyChar)) {
                                $lines[$cursorY] = $lines[$cursorY].Insert($cursorX, $Key.KeyChar)
                                $cursorX++
                            } else {
                                return $false
                            }
                        }
                    }
                    default {
                        if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar)) {
                            $lines[$cursorY] = $lines[$cursorY].Insert($cursorX, $Key.KeyChar)
                            $cursorX++
                        } else { 
                            return $false 
                        }
                    }
                }
                
                $self.Lines = $lines
                $self.CursorX = $cursorX
                $self.CursorY = $cursorY
                $self.Text = $lines -join "`n"
                
                if ($self.OnChange) { 
                    Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock {
                        & $self.OnChange -NewValue $self.Text 
                    } -Context @{ Component = $self.Name; NewValue = $self.Text } -ErrorHandler {
                        param($Exception)
                        Write-Log -Level Error -Message "TextArea OnChange error: $($Exception.Message)" -Data $Exception.Context
                    }
                }
                Request-TuiRefresh
                return $true
            } catch {
                Write-Log -Level Error -Message "TextArea HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
                return $false
            }
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

#endregion

#region DateTime Components

function global:New-TuiDatePicker {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "DatePicker"
        IsFocusable = $true
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 20 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 3 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Value = if ($null -ne $Props.Value) { $Props.Value } else { (Get-Date) }
        Format = if ($null -ne $Props.Format) { $Props.Format } else { "yyyy-MM-dd" }
        Name = $Props.Name
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height 3 -BorderColor $borderColor
                $dateStr = $self.Value.ToString($self.Format)
                
                # Truncate date string if too long
                $maxLength = $self.Width - 6
                if ($dateStr.Length -gt $maxLength) {
                    $dateStr = $dateStr.Substring(0, $maxLength)
                }
                
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $dateStr
                if ($self.IsFocused -and $self.Width -ge 6) { 
                    Write-BufferString -X ($self.X + $self.Width - 4) -Y ($self.Y + 1) -Text "📅" -ForegroundColor $borderColor 
                }
            } catch {
                Write-Log -Level Error -Message "DatePicker Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $date = $self.Value
                $handled = $true
                
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow)   { $date = $date.AddDays(1) }
                    ([ConsoleKey]::DownArrow) { $date = $date.AddDays(-1) }
                    ([ConsoleKey]::PageUp)    { $date = $date.AddMonths(1) }
                    ([ConsoleKey]::PageDown)  { $date = $date.AddMonths(-1) }
                    ([ConsoleKey]::Home)      { $date = Get-Date }
                    ([ConsoleKey]::T) { 
                        if ($Key.Modifiers -band [ConsoleModifiers]::Control) { 
                            $date = Get-Date 
                        } else { 
                            $handled = $false 
                        } 
                    }
                    default { $handled = $false }
                }
                
                if ($handled) {
                    $self.Value = $date
                    if ($self.OnChange) { 
                        Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock {
                            & $self.OnChange -NewValue $date 
                        } -Context @{ Component = $self.Name; NewValue = $date } -ErrorHandler {
                            param($Exception)
                            Write-Log -Level Error -Message "DatePicker OnChange error: $($Exception.Message)" -Data $Exception.Context
                        }
                    }
                    Request-TuiRefresh
                }
                return $handled
            } catch {
                Write-Log -Level Error -Message "DatePicker HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
                return $false
            }
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

function global:New-TuiTimePicker {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "TimePicker"
        IsFocusable = $true
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 15 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 3 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Hour = if ($null -ne $Props.Hour) { $Props.Hour } else { 0 }
        Minute = if ($null -ne $Props.Minute) { $Props.Minute } else { 0 }
        Format24H = if ($null -ne $Props.Format24H) { $Props.Format24H } else { $true }
        Name = $Props.Name
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height 3 -BorderColor $borderColor
                
                if ($self.Format24H) { 
                    $timeStr = "{0:D2}:{1:D2}" -f $self.Hour, $self.Minute 
                } else {
                    $displayHour = if ($self.Hour -eq 0) { 12 } elseif ($self.Hour -gt 12) { $self.Hour - 12 } else { $self.Hour }
                    $ampm = if ($self.Hour -lt 12) { "AM" } else { "PM" }
                    $timeStr = "{0:D2}:{1:D2} {2}" -f $displayHour, $self.Minute, $ampm
                }
                
                # Truncate time string if too long
                $maxLength = $self.Width - 6
                if ($timeStr.Length -gt $maxLength) {
                    $timeStr = $timeStr.Substring(0, $maxLength)
                }
                
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $timeStr
                if ($self.IsFocused -and $self.Width -ge 6) { 
                    Write-BufferString -X ($self.X + $self.Width - 4) -Y ($self.Y + 1) -Text "⏰" -ForegroundColor $borderColor 
                }
            } catch {
                Write-Log -Level Error -Message "TimePicker Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $handled = $true
                $hour = $self.Hour
                $minute = $self.Minute
                
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) { 
                        $minute = ($minute + 15) % 60
                        if ($minute -eq 0) { $hour = ($hour + 1) % 24 } 
                    }
                    ([ConsoleKey]::DownArrow) { 
                        $minute = ($minute - 15 + 60) % 60
                        if ($minute -eq 45) { $hour = ($hour - 1 + 24) % 24 } 
                    }
                    ([ConsoleKey]::LeftArrow)  { $hour = ($hour - 1 + 24) % 24 }
                    ([ConsoleKey]::RightArrow) { $hour = ($hour + 1) % 24 }
                    default { $handled = $false }
                }
                
                if ($handled) {
                    $self.Hour = $hour
                    $self.Minute = $minute
                    
                    if ($self.OnChange) { 
                        Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock {
                            & $self.OnChange -NewHour $hour -NewMinute $minute 
                        } -Context @{ Component = $self.Name; NewHour = $hour; NewMinute = $minute } -ErrorHandler {
                            param($Exception)
                            Write-Log -Level Error -Message "TimePicker OnChange error: $($Exception.Message)" -Data $Exception.Context
                        }
                    }
                    Request-TuiRefresh
                }
                return $handled
            } catch {
                Write-Log -Level Error -Message "TimePicker HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
                return $false
            }
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

#endregion

#region Data Display Components

function global:New-TuiTable {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "Table"
        IsFocusable = $true
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 60 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 15 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Columns = if ($null -ne $Props.Columns) { $Props.Columns } else { @() }
        Rows = if ($null -ne $Props.Rows) { $Props.Rows } else { @() }
        Name = $Props.Name
        
        # Internal State
        SelectedRow = 0
        ScrollOffset = 0
        SortColumn = $null
        SortAscending = $true
        
        # Event Handlers (from Props)
        OnRowSelect = $Props.OnRowSelect
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible -or $self.Columns.Count -eq 0) { return }
                
                $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height -BorderColor $borderColor
                
                $totalWidth = $self.Width - 4
                $colWidth = [Math]::Floor($totalWidth / $self.Columns.Count)
                $headerY = $self.Y + 1
                $currentX = $self.X + 2
                
                # Draw headers
                foreach ($col in $self.Columns) {
                    $header = $col.Header
                    if ($col.Name -eq $self.SortColumn) { 
                        $arrow = if ($self.SortAscending) { "▲" } else { "▼" }
                        $header = "$header $arrow" 
                    }
                    if ($header.Length -gt $colWidth - 1) { 
                        $header = $header.Substring(0, $colWidth - 4) + "..." 
                    }
                    Write-BufferString -X $currentX -Y $headerY -Text $header -ForegroundColor (Get-ThemeColor "Header")
                    $currentX += $colWidth
                }
                
                # Header separator
                Write-BufferString -X ($self.X + 1) -Y ($headerY + 1) -Text ("─" * ($self.Width - 2)) -ForegroundColor $borderColor
                
                # Draw rows
                $visibleRows = $self.Height - 5
                $startIdx = $self.ScrollOffset
                $endIdx = [Math]::Min($self.Rows.Count - 1, $startIdx + $visibleRows - 1)
                
                for ($i = $startIdx; $i -le $endIdx; $i++) {
                    $row = $self.Rows[$i]
                    $rowY = ($headerY + 2) + ($i - $startIdx)
                    $currentX = $self.X + 2
                    $isSelected = ($i -eq $self.SelectedRow -and $self.IsFocused)
                    $bgColor = if ($isSelected) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Background" }
                    $fgColor = if ($isSelected) { Get-ThemeColor "Background" } else { Get-ThemeColor "Primary" }
                    
                    if ($isSelected) { 
                        Write-BufferString -X ($self.X + 1) -Y $rowY -Text (" " * ($self.Width - 2)) -BackgroundColor $bgColor 
                    }
                    
                    foreach ($col in $self.Columns) {
                        $value = $row.($col.Name)
                        if ($null -eq $value) { $value = "" }
                        $text = $value.ToString()
                        if ($text.Length -gt $colWidth - 1) { 
                            $text = $text.Substring(0, $colWidth - 4) + "..." 
                        }
                        Write-BufferString -X $currentX -Y $rowY -Text $text -ForegroundColor $fgColor -BackgroundColor $bgColor
                        $currentX += $colWidth
                    }
                }
                
                # Scrollbar
                if ($self.Rows.Count -gt $visibleRows) {
                    $scrollbarHeight = $visibleRows
                    $scrollPosition = [Math]::Floor(($self.ScrollOffset / ($self.Rows.Count - $visibleRows)) * ($scrollbarHeight - 1))
                    for ($i = 0; $i -lt $scrollbarHeight; $i++) {
                        $char = if ($i -eq $scrollPosition) { "█" } else { "│" }
                        $color = if ($i -eq $scrollPosition) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Subtle" }
                        Write-BufferString -X ($self.X + $self.Width - 2) -Y ($headerY + 2 + $i) -Text $char -ForegroundColor $color
                    }
                }
            } catch {
                Write-Log -Level Error -Message "Table Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                if ($self.Rows.Count -eq 0) { return $false }
                
                $visibleRows = $self.Height - 5
                $handled = $true
                
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) { 
                        if ($self.SelectedRow -gt 0) { 
                            $self.SelectedRow--
                            if ($self.SelectedRow -lt $self.ScrollOffset) { 
                                $self.ScrollOffset = $self.SelectedRow 
                            }
                            Request-TuiRefresh 
                        } 
                    }
                    ([ConsoleKey]::DownArrow) { 
                        if ($self.SelectedRow -lt $self.Rows.Count - 1) { 
                            $self.SelectedRow++
                            if ($self.SelectedRow -ge $self.ScrollOffset + $visibleRows) { 
                                $self.ScrollOffset = $self.SelectedRow - $visibleRows + 1 
                            }
                            Request-TuiRefresh 
                        } 
                    }
                    ([ConsoleKey]::PageUp) { 
                        $self.SelectedRow = [Math]::Max(0, $self.SelectedRow - $visibleRows)
                        $self.ScrollOffset = [Math]::Max(0, $self.ScrollOffset - $visibleRows)
                        Request-TuiRefresh 
                    }
                    ([ConsoleKey]::PageDown) { 
                        $self.SelectedRow = [Math]::Min($self.Rows.Count - 1, $self.SelectedRow + $visibleRows)
                        $maxScroll = [Math]::Max(0, $self.Rows.Count - $visibleRows)
                        $self.ScrollOffset = [Math]::Min($maxScroll, $self.ScrollOffset + $visibleRows)
                        Request-TuiRefresh 
                    }
                    ([ConsoleKey]::Home) { 
                        $self.SelectedRow = 0
                        $self.ScrollOffset = 0
                        Request-TuiRefresh 
                    }
                    ([ConsoleKey]::End) { 
                        $self.SelectedRow = $self.Rows.Count - 1
                        $self.ScrollOffset = [Math]::Max(0, $self.Rows.Count - $visibleRows)
                        Request-TuiRefresh 
                    }
                    ([ConsoleKey]::Enter) { 
                        if ($self.OnRowSelect) { 
                            Invoke-WithErrorHandling -Component "$($self.Name).OnRowSelect" -ScriptBlock {
                                & $self.OnRowSelect -Row $self.Rows[$self.SelectedRow] -Index $self.SelectedRow 
                            } -Context @{ Component = $self.Name; SelectedRow = $self.SelectedRow } -ErrorHandler {
                                param($Exception)
                                Write-Log -Level Error -Message "Table OnRowSelect error: $($Exception.Message)" -Data $Exception.Context
                            }
                        } 
                    }
                    default {
                        if ($Key.KeyChar -match '\d') {
                            $colIndex = [int]$Key.KeyChar.ToString() - 1
                            if ($colIndex -ge 0 -and $colIndex -lt $self.Columns.Count) {
                                $colName = $self.Columns[$colIndex].Name
                                if ($self.SortColumn -eq $colName) { 
                                    $self.SortAscending = -not $self.SortAscending 
                                } else { 
                                    $self.SortColumn = $colName
                                    $self.SortAscending = $true 
                                }
                                $self.Rows = $self.Rows | Sort-Object -Property $colName -Descending:(-not $self.SortAscending)
                                Request-TuiRefresh
                            }
                        } else { 
                            $handled = $false 
                        }
                    }
                }
            } catch {
                Write-Log -Level Error -Message "Table HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $handled
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

function global:New-TuiChart {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "Chart"
        IsFocusable = $false
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 40 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 10 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        ChartType = if ($null -ne $Props.ChartType) { $Props.ChartType } else { "Bar" }
        Data = if ($null -ne $Props.Data) { $Props.Data } else { @() }
        ShowValues = if ($null -ne $Props.ShowValues) { $Props.ShowValues } else { $true }
        Name = $Props.Name
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible -or $self.Data.Count -eq 0) { return }
                
                switch ($self.ChartType) {
                    "Bar" {
                        $maxValue = ($self.Data | Measure-Object -Property Value -Maximum).Maximum
                        if ($maxValue -eq 0) { $maxValue = 1 }
                        $chartHeight = $self.Height - 2
                        $barWidth = [Math]::Floor(($self.Width - 4) / $self.Data.Count)
                        
                        for ($i = 0; $i -lt $self.Data.Count; $i++) {
                            $item = $self.Data[$i]
                            $barHeight = [Math]::Floor(($item.Value / $maxValue) * $chartHeight)
                            $barX = $self.X + 2 + ($i * $barWidth)
                            
                            for ($y = 0; $y -lt $barHeight; $y++) { 
                                $barY = $self.Y + $self.Height - 2 - $y
                                Write-BufferString -X $barX -Y $barY -Text ("█" * ($barWidth - 1)) -ForegroundColor (Get-ThemeColor "Accent") 
                            }
                            
                            if ($item.Label -and $barWidth -gt 3) { 
                                $label = $item.Label
                                if ($label.Length -gt $barWidth - 1) { 
                                    $label = $label.Substring(0, $barWidth - 2) 
                                }
                                Write-BufferString -X $barX -Y ($self.Y + $self.Height - 1) -Text $label -ForegroundColor (Get-ThemeColor "Subtle") 
                            }
                            
                            if ($self.ShowValues -and $barHeight -gt 0) { 
                                $valueText = $item.Value.ToString()
                                Write-BufferString -X $barX -Y ($self.Y + $self.Height - 3 - $barHeight) -Text $valueText -ForegroundColor (Get-ThemeColor "Primary") 
                            }
                        }
                    }
                    "Sparkline" {
                        $width = $self.Width - 2
                        $height = $self.Height - 1
                        $maxValue = ($self.Data | Measure-Object -Maximum).Maximum
                        if ($maxValue -eq 0) { $maxValue = 1 }
                        
                        $sparkChars = @(" ", " ", "▂", "▃", "▄", "▅", "▆", "▇", "█")
                        $sparkline = ""
                        
                        foreach ($value in $self.Data) { 
                            $normalized = ($value / $maxValue)
                            $charIndex = [Math]::Floor($normalized * ($sparkChars.Count - 1))
                            $sparkline += $sparkChars[$charIndex] 
                        }
                        
                        if ($sparkline.Length -gt $width) { 
                            $sparkline = $sparkline.Substring($sparkline.Length - $width) 
                        } else { 
                            $sparkline = $sparkline.PadLeft($width) 
                        }
                        
                        Write-BufferString -X ($self.X + 1) -Y ($self.Y + [Math]::Floor($height / 2)) -Text $sparkline -ForegroundColor (Get-ThemeColor "Accent")
                    }
                }
            } catch {
                Write-Log -Level Error -Message "Chart Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                return $false
            } catch {
                Write-Log -Level Error -Message "Chart HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
                return $false
            }
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

#endregion

#region Container Components

# FIX: REMOVED the legacy New-TuiPanel function entirely.
# All code should now use the more specific panels from layout/panels.psm1.

#endregion

Export-ModuleMember -Function @(
    # Basic Components
    'New-TuiLabel',
    'New-TuiButton',
    'New-TuiTextBox',
    'New-TuiCheckBox',
    'New-TuiDropdown',
    'New-TuiProgressBar',
    'New-TuiTextArea',
    # DateTime Components
    'New-TuiDatePicker',
    'New-TuiTimePicker',
    # Data Display Components
    'New-TuiTable',
    'New-TuiChart'
)
# FILE: layout/panels.psm1
# PURPOSE: Provides a suite of specialized layout panels for declarative UI construction.

function New-BasePanel {
    param([hashtable]$Props)
    
    $panel = @{
        Type = "Panel"
        Name = if ($null -ne $Props.Name) { $Props.Name } else { "Panel_$([Guid]::NewGuid().ToString('N').Substring(0,8))" }
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 40 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 20 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        IsFocusable = if ($null -ne $Props.IsFocusable) { $Props.IsFocusable } else { $false }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Children = @()
        Parent = $null
        LayoutProps = if ($null -ne $Props.LayoutProps) { $Props.LayoutProps } else { @{} }
        ShowBorder = if ($null -ne $Props.ShowBorder) { $Props.ShowBorder } else { $false }
        BorderStyle = if ($null -ne $Props.BorderStyle) { $Props.BorderStyle } else { "Single" }  # Single, Double, Rounded
        BorderColor = if ($null -ne $Props.BorderColor) { $Props.BorderColor } else { "Border" } # Theme color name
        Title = $Props.Title
        Padding = if ($null -ne $Props.Padding) { $Props.Padding } else { 0 }
        Margin = if ($null -ne $Props.Margin) { $Props.Margin } else { 0 }
        BackgroundColor = $Props.BackgroundColor
        ForegroundColor = $Props.ForegroundColor
        _isDirty = $true
        _cachedLayout = $null
        
        AddChild = { 
            param($self, $Child, [hashtable]$LayoutProps = @{})
            
            Invoke-WithErrorHandling -Component "$($self.Name).AddChild" -ScriptBlock {
                if (-not $Child) {
                    throw "Cannot add null child to panel"
                }
                
                $Child.Parent = $self
                $Child.LayoutProps = $LayoutProps
                [void]($self.Children += $Child)
                $self._isDirty = $true
                
                # Propagate visibility
                if (-not $self.Visible) {
                    $Child.Visible = $false
                }
            } -Context @{ Parent = $self.Name; ChildType = $Child.Type; ChildName = $Child.Name } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "Panel AddChild error: $($Exception.Message)" -Data $Exception.Context
            }
        }
        
        RemoveChild = {
            param($self, $Child)
            Invoke-WithErrorHandling -Component "$($self.Name).RemoveChild" -ScriptBlock {
                $self.Children = $self.Children | Where-Object { $_ -ne $Child }
                if ($Child.Parent -eq $self) {
                    $Child.Parent = $null
                }
                $self._isDirty = $true
            } -Context @{ Parent = $self.Name; ChildType = $Child.Type; ChildName = $Child.Name } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "Panel RemoveChild error: $($Exception.Message)" -Data $Exception.Context
            }
        }
        
        ClearChildren = {
            param($self)
            Invoke-WithErrorHandling -Component "$($self.Name).ClearChildren" -ScriptBlock {
                foreach ($child in $self.Children) {
                    $child.Parent = $null
                }
                $self.Children = @()
                $self._isDirty = $true
            } -Context @{ Parent = $self.Name } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "Panel ClearChildren error: $($Exception.Message)" -Data $Exception.Context
            }
        }
        
        Show = { 
            param($self)
            Invoke-WithErrorHandling -Component "$($self.Name).Show" -ScriptBlock {
                $self.Visible = $true
                foreach ($child in $self.Children) { 
                    if ($child.Show) { 
                        & $child.Show -self $child
                    } else { 
                        $child.Visible = $true
                    }
                }
                
                # Request refresh if we have access to the function
                if (Get-Command -Name "Request-TuiRefresh" -ErrorAction SilentlyContinue) {
                    Request-TuiRefresh
                }
            } -Context @{ Panel = $self.Name } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "Panel Show error: $($Exception.Message)" -Data $Exception.Context
            }
        }
        
        Hide = { 
            param($self)
            Invoke-WithErrorHandling -Component "$($self.Name).Hide" -ScriptBlock {
                $self.Visible = $false
                foreach ($child in $self.Children) { 
                    if ($child.Hide) { 
                        & $child.Hide -self $child
                    } else { 
                        $child.Visible = $false
                    }
                }
                
                # Request refresh if we have access to the function
                if (Get-Command -Name "Request-TuiRefresh" -ErrorAction SilentlyContinue) {
                    Request-TuiRefresh
                }
            } -Context @{ Panel = $self.Name } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "Panel Hide error: $($Exception.Message)" -Data $Exception.Context
            }
        }
        
        HandleInput = { 
            param($self, $Key)
            Invoke-WithErrorHandling -Component "$($self.Name).HandleInput" -ScriptBlock {
                # Panels typically don't handle input directly
                # but can be overridden for special behavior
                return $false
            } -Context @{ Panel = $self.Name; Key = $Key } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "Panel HandleInput error: $($Exception.Message)" -Data $Exception.Context
                return $false
            }
        }
        
        GetContentBounds = {
            param($self)
            Invoke-WithErrorHandling -Component "$($self.Name).GetContentBounds" -ScriptBlock {
                $borderOffset = if ($self.ShowBorder) { 1 } else { 0 }
                
                return @{
                    X = $self.X + $self.Padding + $borderOffset + $self.Margin
                    Y = $self.Y + $self.Padding + $borderOffset + $self.Margin
                    Width = $self.Width - (2 * ($self.Padding + $borderOffset + $self.Margin))
                    Height = $self.Height - (2 * ($self.Padding + $borderOffset + $self.Margin))
                }
            } -Context @{ Panel = $self.Name } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "Panel GetContentBounds error: $($Exception.Message)" -Data $Exception.Context
                return @{ X = $self.X; Y = $self.Y; Width = $self.Width; Height = $self.Height } # Fallback
            }
        }
        
        InvalidateLayout = {
            param($self)
            Invoke-WithErrorHandling -Component "$($self.Name).InvalidateLayout" -ScriptBlock {
                $self._isDirty = $true
                
                # Propagate to parent
                if ($self.Parent -and $self.Parent.InvalidateLayout) {
                    & $self.Parent.InvalidateLayout -self $self.Parent
                }
            } -Context @{ Panel = $self.Name } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "Panel InvalidateLayout error: $($Exception.Message)" -Data $Exception.Context
            }
        }
    }
    
    return $panel
}

function global:New-TuiStackPanel {
    param([hashtable]$Props = @{})
    
    $panel = New-BasePanel -Props $Props
    $panel.Type = "StackPanel"
    $panel.Layout = 'Stack'
    $panel.Orientation = if ($null -ne $Props.Orientation) { $Props.Orientation } else { 'Vertical' }
    $panel.Spacing = if ($null -ne $Props.Spacing) { $Props.Spacing } else { 1 }
    $panel.HorizontalAlignment = if ($null -ne $Props.HorizontalAlignment) { $Props.HorizontalAlignment } else { 'Stretch' }  # Left, Center, Right, Stretch
    $panel.VerticalAlignment = if ($null -ne $Props.VerticalAlignment) { $Props.VerticalAlignment } else { 'Stretch' }      # Top, Middle, Bottom, Stretch
    
    $panel.CalculateLayout = {
        param($self)
        Invoke-WithErrorHandling -Component "$($self.Name).CalculateLayout" -ScriptBlock {
            $bounds = & $self.GetContentBounds -self $self
            $layout = @{
                Children = @()
            }
            
            $currentX = $bounds.X
            $currentY = $bounds.Y
            $totalChildWidth = 0
            $totalChildHeight = 0
            $visibleChildren = $self.Children | Where-Object { $_.Visible }
            
            # Calculate total size needed
            foreach ($child in $visibleChildren) {
                if ($self.Orientation -eq 'Vertical') {
                    $totalChildHeight += $child.Height
                    $totalChildWidth = [Math]::Max($totalChildWidth, $child.Width)
                } else {
                    $totalChildWidth += $child.Width
                    $totalChildHeight = [Math]::Max($totalChildHeight, $child.Height)
                }
            }
            
            # Add spacing
            if ($visibleChildren.Count -gt 1) {
                if ($self.Orientation -eq 'Vertical') {
                    $totalChildHeight += ($visibleChildren.Count - 1) * $self.Spacing
                } else {
                    $totalChildWidth += ($visibleChildren.Count - 1) * $self.Spacing
                }
            }
            
            # Calculate starting position based on alignment
            if ($self.Orientation -eq 'Vertical') {
                switch ($self.VerticalAlignment) {
                    'Top' { $currentY = $bounds.Y }
                    'Middle' { $currentY = $bounds.Y + [Math]::Floor(($bounds.Height - $totalChildHeight) / 2) }
                    'Bottom' { $currentY = $bounds.Y + $bounds.Height - $totalChildHeight }
                    'Stretch' { $currentY = $bounds.Y }
                }
            } else {
                switch ($self.HorizontalAlignment) {
                    'Left' { $currentX = $bounds.X }
                    'Center' { $currentX = $bounds.X + [Math]::Floor(($bounds.Width - $totalChildWidth) / 2) }
                    'Right' { $currentX = $bounds.X + $bounds.Width - $totalChildWidth }
                    'Stretch' { $currentX = $bounds.X }
                }
            }
            
            # Layout children
            foreach ($child in $visibleChildren) {
                $childLayout = @{
                    Component = $child
                    X = $currentX
                    Y = $currentY
                    Width = $child.Width
                    Height = $child.Height
                }
                
                # Apply stretch behavior
                if ($self.Orientation -eq 'Vertical' -and $self.HorizontalAlignment -eq 'Stretch') {
                    $childLayout.Width = $bounds.Width
                    # Update child's actual width for proper rendering
                    if ($child.Width -ne $bounds.Width) {
                        $child.Width = $bounds.Width
                    }
                }
                elseif ($self.Orientation -eq 'Horizontal' -and $self.VerticalAlignment -eq 'Stretch') {
                    $childLayout.Height = $bounds.Height
                    # Update child's actual height for proper rendering
                    if ($child.Height -ne $bounds.Height) {
                        $child.Height = $bounds.Height
                    }
                }
                
                # Handle horizontal alignment for vertical stacks
                if ($self.Orientation -eq 'Vertical' -and $self.HorizontalAlignment -ne 'Stretch') {
                    switch ($self.HorizontalAlignment) {
                        'Center' { $childLayout.X = $bounds.X + [Math]::Floor(($bounds.Width - $child.Width) / 2) }
                        'Right' { $childLayout.X = $bounds.X + $bounds.Width - $child.Width }
                    }
                }
                
                # Handle vertical alignment for horizontal stacks
                if ($self.Orientation -eq 'Horizontal' -and $self.VerticalAlignment -ne 'Stretch') {
                    switch ($self.VerticalAlignment) {
                        'Middle' { $childLayout.Y = $bounds.Y + [Math]::Floor(($bounds.Height - $child.Height) / 2) }
                        'Bottom' { $childLayout.Y = $bounds.Y + $bounds.Height - $child.Height }
                    }
                }
                
                # FIX: CRITICAL - Apply calculated positions and sizes back to the child component
                $child.X = $childLayout.X
                $child.Y = $childLayout.Y
                if ($childLayout.Width -ne $child.Width -and $child.PSObject.Properties['Width'].IsSettable) {
                    $child.Width = $childLayout.Width
                }
                if ($childLayout.Height -ne $child.Height -and $child.PSObject.Properties['Height'].IsSettable) {
                    $child.Height = $childLayout.Height
                }
                
                $layout.Children += $childLayout
                
                # Move to next position
                if ($self.Orientation -eq 'Vertical') {
                    $currentY += $childLayout.Height + $self.Spacing
                } else {
                    $currentX += $childLayout.Width + $self.Spacing
                }
            }
            
            $self._cachedLayout = $layout
            $self._isDirty = $false
            return $layout
        } -Context @{ Panel = $self.Name; Orientation = $self.Orientation } -ErrorHandler {
            param($Exception)
            Write-Log -Level Error -Message "StackPanel CalculateLayout error: $($Exception.Message)" -Data $Exception.Context
            return @{ Children = @() } # Return empty layout on error
        }
    }
    
    $panel.Render = {
        param($self)
        Invoke-WithErrorHandling -Component "$($self.Name).Render" -ScriptBlock {
            if (-not $self.Visible) { return }
            
            # Clear panel area first to prevent bleed-through
            $bgColor = if ($self.BackgroundColor) { 
                $self.BackgroundColor 
            } else { 
                Get-ThemeColor "Background" -Default ([ConsoleColor]::Black)
            }
            
            # FIX: Fill the entire panel area with background color
            for ($y = $self.Y; $y -lt ($self.Y + $self.Height); $y++) {
                Write-BufferString -X $self.X -Y $y -Text (' ' * $self.Width) -BackgroundColor $bgColor
            }
            
            if ($self.ShowBorder) {
                # FIX: Use proper theme colors for borders
                $borderColor = if ($self.BorderColor) {
                    Get-ThemeColor $self.BorderColor -Default ([ConsoleColor]::Gray)
                } elseif ($self.ForegroundColor) { 
                    $self.ForegroundColor 
                } else { 
                    Get-ThemeColor "Border" -Default ([ConsoleColor]::Gray)
                }
                
                # FIX: Use BorderStyle from panel properties
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor -BackgroundColor $bgColor `
                    -BorderStyle $self.BorderStyle -Title $self.Title
            }
            # FIX: Ensure layout is calculated before Z-Index renderer processes children.
            & $self.CalculateLayout -self $self
        } -Context @{ Panel = $self.Name } -ErrorHandler {
            param($Exception)
            Write-Log -Level Error -Message "StackPanel Render error: $($Exception.Message)" -Data $Exception.Context
        }
    }
    
    return $panel
}

function global:New-TuiGridPanel {
    param([hashtable]$Props = @{})
    
    $panel = New-BasePanel -Props $Props
    $panel.Type = "GridPanel"
    $panel.Layout = 'Grid'
    $panel.RowDefinitions = if ($null -ne $Props.RowDefinitions) { $Props.RowDefinitions } else { @("1*") }
    $panel.ColumnDefinitions = if ($null -ne $Props.ColumnDefinitions) { $Props.ColumnDefinitions } else { @("1*") }
    $panel.ShowGridLines = if ($null -ne $Props.ShowGridLines) { $Props.ShowGridLines } else { $false }
    $panel.GridLineColor = if ($null -ne $Props.GridLineColor) { $Props.GridLineColor } else { Get-ThemeColor "BorderDim" -Default DarkGray }
    
    $panel._CalculateGridSizes = {
        param($self, $definitions, $totalSize)
        Invoke-WithErrorHandling -Component "$($self.Name)._CalculateGridSizes" -ScriptBlock {
            $parsedDefs = @()
            $totalFixed = 0
            $totalStars = 0.0
            
            foreach ($def in $definitions) {
                if ($def -match '^(\d+)$') {
                    $parsedDefs += @{ Type = 'Fixed'; Value = [int]$Matches[1] }
                    $totalFixed += [int]$Matches[1]
                } elseif ($def -match '^(\d*\.?\d*)\*$') {
                    $stars = if ($Matches[1]) { [double]$Matches[1] } else { 1.0 }
                    $parsedDefs += @{ Type = 'Star'; Value = $stars }
                    $totalStars += $stars
                } elseif ($def -eq 'Auto') {
                    $parsedDefs += @{ Type = 'Star'; Value = 1.0 }
                    $totalStars += 1.0
                } else {
                    throw "Invalid grid definition: $def"
                }
            }
            
            $remainingSize = [Math]::Max(0, $totalSize - $totalFixed)
            $sizes = @()
            
            foreach ($def in $parsedDefs) {
                if ($def.Type -eq 'Fixed') {
                    $sizes += $def.Value
                } else {
                    $size = if ($totalStars -gt 0) { [Math]::Floor($remainingSize * ($def.Value / $totalStars)) } else { 0 }
                    $sizes += $size
                }
            }
            
            # FIX: Distribute rounding errors to the last star-sized cell to ensure total size is met.
            $totalAllocated = ($sizes | Measure-Object -Sum).Sum
            if ($totalAllocated -ne $totalSize -and $totalStars -gt 0) {
                $lastStarIndex = -1
                for($i = $parsedDefs.Count - 1; $i -ge 0; $i--) {
                    if ($parsedDefs[$i].Type -eq 'Star') {
                        $lastStarIndex = $i; break
                    }
                }
                if ($lastStarIndex -ne -1) {
                    $sizes[$lastStarIndex] += ($totalSize - $totalAllocated)
                }
            }
            
            return $sizes
        } -Context @{ Panel = $self.Name; Definitions = $definitions; TotalSize = $totalSize } -ErrorHandler {
            param($Exception)
            Write-Log -Level Error -Message "GridPanel _CalculateGridSizes error: $($Exception.Message)" -Data $Exception.Context
            return @() # Return empty array on error
        }
    }
    
    $panel.CalculateLayout = {
        param($self)
        Invoke-WithErrorHandling -Component "$($self.Name).CalculateLayout" -ScriptBlock {
            $bounds = & $self.GetContentBounds -self $self
            
            $rowHeights = & $self._CalculateGridSizes -self $self -definitions $self.RowDefinitions -totalSize $bounds.Height
            $colWidths = & $self._CalculateGridSizes -self $self -definitions $self.ColumnDefinitions -totalSize $bounds.Width
            
            $rowOffsets = @(0); for ($i = 0; $i -lt $rowHeights.Count - 1; $i++) { $rowOffsets += ($rowOffsets[-1] + $rowHeights[$i]) }
            $colOffsets = @(0); for ($i = 0; $i -lt $colWidths.Count - 1; $i++) { $colOffsets += ($colOffsets[-1] + $colWidths[$i]) }
            
            $layout = @{ Children = @(); Rows = $rowHeights; Columns = $colWidths; RowOffsets = $rowOffsets; ColumnOffsets = $colOffsets }
            
            foreach ($child in $self.Children) {
                if (-not $child.Visible) { continue }
                
                $gridRow = if ($null -ne $child.LayoutProps."Grid.Row") { [int]$child.LayoutProps."Grid.Row" } else { 0 }
                $gridCol = if ($null -ne $child.LayoutProps."Grid.Column") { [int]$child.LayoutProps."Grid.Column" } else { 0 }
                $gridRowSpan = if ($null -ne $child.LayoutProps."Grid.RowSpan") { [int]$child.LayoutProps."Grid.RowSpan" } else { 1 }
                $gridColSpan = if ($null -ne $child.LayoutProps."Grid.ColumnSpan") { [int]$child.LayoutProps."Grid.ColumnSpan" } else { 1 }
                
                $row = [Math]::Max(0, [Math]::Min($rowHeights.Count - 1, $gridRow))
                $col = [Math]::Max(0, [Math]::Min($colWidths.Count - 1, $gridCol))
                $rowSpan = [Math]::Max(1, [Math]::Min($rowHeights.Count - $row, $gridRowSpan))
                $colSpan = [Math]::Max(1, [Math]::Min($colWidths.Count - $col, $gridColSpan))
                
                $cellX = $bounds.X + $colOffsets[$col]; $cellY = $bounds.Y + $rowOffsets[$row]
                $cellWidth = 0; for ($i = 0; $i -lt $colSpan; $i++) { if (($col + $i) -lt $colWidths.Count) { $cellWidth += $colWidths[$col + $i] } }
                $cellHeight = 0; for ($i = 0; $i -lt $rowSpan; $i++) { if (($row + $i) -lt $rowHeights.Count) { $cellHeight += $rowHeights[$row + $i] } }
                
                $childX = $cellX; $childY = $cellY
                $childWidth = $child.Width; $childHeight = $child.Height
                
                $hAlign = if ($null -ne $child.LayoutProps."Grid.HorizontalAlignment") { $child.LayoutProps."Grid.HorizontalAlignment" } else { "Stretch" }
                switch ($hAlign) {
                    "Center" { $childX = $cellX + [Math]::Floor(($cellWidth - $childWidth) / 2) }
                    "Right" { $childX = $cellX + $cellWidth - $childWidth }
                    "Stretch" { $childWidth = $cellWidth }
                }
                
                $vAlign = if ($null -ne $child.LayoutProps."Grid.VerticalAlignment") { $child.LayoutProps."Grid.VerticalAlignment" } else { "Stretch" }
                switch ($vAlign) {
                    "Middle" { $childY = $cellY + [Math]::Floor(($cellHeight - $childHeight) / 2) }
                    "Bottom" { $childY = $cellY + $cellHeight - $childHeight }
                    "Stretch" { $childHeight = $cellHeight }
                }
                
                # FIX: CRITICAL - Apply calculated positions and sizes back to the child component
                $child.X = $childX
                $child.Y = $childY
                if ($child.PSObject.Properties['Width'] -and $child.Width -ne $childWidth) { $child.Width = $childWidth }
                if ($child.PSObject.Properties['Height'] -and $child.Height -ne $childHeight) { $child.Height = $childHeight }
                
                $layout.Children += @{ Component = $child; X = $childX; Y = $childY; Width = $childWidth; Height = $childHeight }
            }
            
            $self._cachedLayout = $layout
            $self._isDirty = $false
            return $layout
        } -Context @{ Panel = $self.Name; RowDefs = $self.RowDefinitions; ColDefs = $self.ColumnDefinitions } -ErrorHandler {
            param($Exception)
            Write-Log -Level Error -Message "GridPanel CalculateLayout error: $($Exception.Message)" -Data $Exception.Context
            return @{ Children = @() } # Return empty layout on error
        }
    }
    
    $panel.Render = {
        param($self)
        Invoke-WithErrorHandling -Component "$($self.Name).Render" -ScriptBlock {
            if (-not $self.Visible) { return }
            
            # Clear panel area first to prevent bleed-through
            $bgColor = if ($self.BackgroundColor) { 
                $self.BackgroundColor 
            } else { 
                Get-ThemeColor "Background" -Default ([ConsoleColor]::Black)
            }
            
            # FIX: Fill the entire panel area with background color
            for ($y = $self.Y; $y -lt ($self.Y + $self.Height); $y++) {
                Write-BufferString -X $self.X -Y $y -Text (' ' * $self.Width) -BackgroundColor $bgColor
            }
            
            if ($self.ShowBorder) {
                # FIX: Use proper theme colors for borders
                $borderColor = if ($self.BorderColor) {
                    Get-ThemeColor $self.BorderColor -Default ([ConsoleColor]::Gray)
                } elseif ($self.ForegroundColor) { 
                    $self.ForegroundColor 
                } else { 
                    Get-ThemeColor "Border" -Default ([ConsoleColor]::Gray)
                }
                
                # FIX: Use BorderStyle from panel properties
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor -BackgroundColor $bgColor `
                    -BorderStyle $self.BorderStyle -Title $self.Title
            }
            
            # FIX: Calculate layout to set child positions. TUI engine will render the children.
            $layout = & $self.CalculateLayout -self $self
            
            if ($self.ShowGridLines) {
                $bounds = & $self.GetContentBounds -self $self
                foreach ($offset in $layout.ColumnOffsets[1..($layout.ColumnOffsets.Count - 1)]) {
                    $x = $bounds.X + $offset; for ($y = $bounds.Y; $y -lt ($bounds.Y + $bounds.Height); $y++) { Write-BufferString -X $x -Y $y -Text "│" -ForegroundColor $self.GridLineColor }
                }
                foreach ($offset in $layout.RowOffsets[1..($layout.RowOffsets.Count - 1)]) {
                    $y = $bounds.Y + $offset; Write-BufferString -X $bounds.X -Y $y -Text ("─" * $bounds.Width) -ForegroundColor $self.GridLineColor
                }
            }
        } -Context @{ Panel = $self.Name } -ErrorHandler {
            param($Exception)
            Write-Log -Level Error -Message "GridPanel Render error: $($Exception.Message)" -Data $Exception.Context
        }
    }
    
    return $panel
}

function global:New-TuiDockPanel { param([hashtable]$Props = @{}) ; return New-TuiStackPanel -Props ($Props.Clone() | Add-Member -MemberType NoteProperty -Name Orientation -Value 'Vertical' -PassThru) }
function global:New-TuiWrapPanel { param([hashtable]$Props = @{}) ; return New-TuiStackPanel -Props $Props }

Export-ModuleMember -Function "New-BasePanel", "New-TuiStackPanel", "New-TuiGridPanel", "New-TuiDockPanel", "New-TuiWrapPanel"
# TUI Framework Integration Module - COMPLIANT VERSION
# Only contains compliant utility functions - deprecated functions removed

$script:TuiAsyncJobs = @()

function global:Invoke-TuiMethod {
    <#
    .SYNOPSIS
    Safely invokes a method on a TUI component.
    #>
    param(
        [Parameter(Mandatory=$true)]
        [hashtable]$Component,

        [Parameter(Mandatory=$true)]
        [string]$MethodName,

        [Parameter()]
        [hashtable]$Arguments = @{}
    )

    if ($null -eq $Component) { return }
    if (-not $Component.ContainsKey($MethodName)) { return }

    $method = $Component[$MethodName]
    if ($null -eq $method -or $method -isnot [scriptblock]) {
        # The method doesn't exist or is not a scriptblock, so we can't call it.
        # This prevents the "term is not recognized" error.
        return
    }

    # Add the component itself as the 'self' parameter for convenience
    $Arguments['self'] = $Component

    try {
        # Use splatting with the @ operator for robust parameter passing
        return & $method @Arguments
    
        } catch {
        $errorMessage = "Error invoking method '$MethodName' on component '$($Component.Type)': $($_.Exception.Message)"
        Write-Log -Level Error -Message $errorMessage -Data $_
        Request-TuiRefresh
    }
}

# Add 'Invoke-TuiMethod' to the Export-ModuleMember list at the end of the file.

function global:Initialize-TuiFramework {
    <#
    .SYNOPSIS
    Initializes the TUI framework
    #>
    
    # Ensure engine is initialized
    if (-not $global:TuiState) {
        throw "TUI Engine must be initialized before framework"
    }
    
    Write-Verbose "TUI Framework initialized"
}

function global:Invoke-TuiAsync {
    <#
    .SYNOPSIS
    Executes a script block asynchronously with proper job management
    
    .PARAMETER ScriptBlock
    The script block to execute asynchronously
    
    .PARAMETER OnComplete
    Handler to call when the job completes successfully
    
    .PARAMETER OnError
    Handler to call if the job encounters an error
    
    .PARAMETER ArgumentList
    Arguments to pass to the script block
    #>
    param(
        [Parameter(Mandatory = $true)]
        [scriptblock]$ScriptBlock,
        
        [Parameter()]
        [scriptblock]$OnComplete = {},
        
        [Parameter()]
        [scriptblock]$OnError = {},
        
        [Parameter()]
        [array]$ArgumentList = @()
    )
    
    try {
        # Start the job
        $job = Start-Job -ScriptBlock $ScriptBlock -ArgumentList $ArgumentList
        
        # Track the job for cleanup
        $script:TuiAsyncJobs += $job
        
        # Create a timer to check job status
        $timer = New-Object System.Timers.Timer
        $timer.Interval = 100  # Check every 100ms
        $timer.AutoReset = $true
        
        # Use Register-ObjectEvent to handle the timer tick
        $timerEvent = Register-ObjectEvent -InputObject $timer -EventName Elapsed -Action {
            try { # Internal try/catch for async operation
                $job = $Event.MessageData.Job
                $onComplete = $Event.MessageData.OnComplete
                $onError = $Event.MessageData.OnError
                $timer = $Event.MessageData.Timer
                
                if ($job.State -eq 'Completed') {
                    try {
                        $result = Receive-Job -Job $job -ErrorAction Stop
                        Remove-Job -Job $job -Force
                        
                        # Remove from tracking
                        $script:TuiAsyncJobs = @($script:TuiAsyncJobs | Where-Object { $_ -ne $job })
                        
                        # Stop and dispose timer
                        $timer.Stop()
                        $timer.Dispose()
                        Unregister-Event -SourceIdentifier $Event.SourceIdentifier
                        
                        # Call completion handler on UI thread
                        if ($onComplete) {
                            Invoke-WithErrorHandling -Component "TuiAsync.OnComplete" -ScriptBlock {
                                & $onComplete -Data $result
                                Request-TuiRefresh
                            } -Context @{ JobId = $job.Id; Result = $result } -ErrorHandler {
                                param($Exception)
                                Write-Log -Level Error -Message "TuiAsync OnComplete handler error: $($Exception.Message)" -Data $Exception.Context
                            }
                        }
                    } catch {
                        Write-Log -Level Error -Message "Job receive error in TuiAsync: $_" -Data @{ JobId = $job.Id; Exception = $_ }
                    }
                }
                elseif ($job.State -eq 'Failed') {
                    try {
                        $error = $job.ChildJobs[0].JobStateInfo.Reason
                        Remove-Job -Job $job -Force
                        
                        # Remove from tracking
                        $script:TuiAsyncJobs = @($script:TuiAsyncJobs | Where-Object { $_ -ne $job })
                        
                        # Stop and dispose timer
                        $timer.Stop()
                        $timer.Dispose()
                        Unregister-Event -SourceIdentifier $Event.SourceIdentifier
                        
                        # Call error handler
                        if ($onError) {
                            Invoke-WithErrorHandling -Component "TuiAsync.OnError" -ScriptBlock {
                                & $onError -Error $error
                                Request-TuiRefresh
                            } -Context @{ JobId = $job.Id; Error = $error } -ErrorHandler {
                                param($Exception)
                                Write-Log -Level Error -Message "TuiAsync OnError handler error: $($Exception.Message)" -Data $Exception.Context
                            }
                        }
                    } catch {
                        Write-Log -Level Error -Message "Job error handling failed in TuiAsync: $_" -Data @{ JobId = $job.Id; Exception = $_ }
                    }
                }
            } catch { # Catch for the Register-ObjectEvent Action block itself
                Write-Log -Level Error -Message "Unhandled error in TuiAsync timer event: $_" -Data @{ JobId = $job.Id; Exception = $_ }
            }
        } -MessageData @{
            Job = $job
            OnComplete = $OnComplete
            OnError = $OnError
            Timer = $timer
        }
        
        # Start the timer
        $timer.Start()
        
        # Return job info
        return @{
            Job = $job
            Timer = $timer
            EventSubscription = $timerEvent
        }
        
    } catch {
        Write-Log -Level Error -Message "Failed to start async operation: $_" -Data @{ ScriptBlock = $ScriptBlock; ArgumentList = $ArgumentList; Exception = $_ }
        if ($OnError) {
            & $OnError -Error $_
        }
    }
}

function global:Stop-AllTuiAsyncJobs {
    <#
    .SYNOPSIS
    Stops and cleans up all tracked async jobs
    #>
    
    foreach ($job in $script:TuiAsyncJobs) {
        try {
            if ($job.State -eq 'Running') {
                Stop-Job -Job $job -ErrorAction SilentlyContinue
            }
            Remove-Job -Job $job -Force -ErrorAction SilentlyContinue
        } catch {
            Write-Warning "Failed to stop job: $_"
        }
    }
    
    $script:TuiAsyncJobs = @()
    
    # Clean up any orphaned timer events
    Get-EventSubscriber | Where-Object { $_.SourceObject -is [System.Timers.Timer] } | ForEach-Object {
        try {
            Unregister-Event -SourceIdentifier $_.SourceIdentifier -ErrorAction SilentlyContinue
            if ($_.SourceObject) {
                $_.SourceObject.Stop()
                $_.SourceObject.Dispose()
            }
        } catch { }
    }
}

function global:Create-TuiState {
    <#
    .SYNOPSIS
    Creates a reactive state management system with deep change detection
    
    .PARAMETER InitialState
    The initial state values
    
    .PARAMETER DeepWatch
    Enable deep property change detection (```powershell
# Theme Manager Module
# Provides theming and color management for the TUI

$script:CurrentTheme = $null
$script:Themes = @{
    Modern = @{
        Name = "Modern"
        Colors = @{
            # Base colors
            Background = [ConsoleColor]::Black
            Foreground = [ConsoleColor]::White
            
            # UI elements
            Primary = [ConsoleColor]::White
            Secondary = [ConsoleColor]::Gray
            Accent = [ConsoleColor]::Cyan
            Success = [ConsoleColor]::Green
            Warning = [ConsoleColor]::Yellow
            Error = [ConsoleColor]::Red
            Info = [ConsoleColor]::Blue
            
            # Special elements
            Header = [ConsoleColor]::Cyan
            Border = [ConsoleColor]::DarkGray
            Selection = [ConsoleColor]::Yellow
            Highlight = [ConsoleColor]::Cyan
            Subtle = [ConsoleColor]::DarkGray
            
            # Syntax highlighting
            Keyword = [ConsoleColor]::Blue
            String = [ConsoleColor]::Green
            Number = [ConsoleColor]::Magenta
            Comment = [ConsoleColor]::DarkGray
        }
    }
    
    Dark = @{
        Name = "Dark"
        Colors = @{
            Background = [ConsoleColor]::Black
            Foreground = [ConsoleColor]::Gray
            Primary = [ConsoleColor]::Gray
            Secondary = [ConsoleColor]::DarkGray
            Accent = [ConsoleColor]::DarkCyan
            Success = [ConsoleColor]::DarkGreen
            Warning = [ConsoleColor]::DarkYellow
            Error = [ConsoleColor]::DarkRed
            Info = [ConsoleColor]::DarkBlue
            Header = [ConsoleColor]::DarkCyan
            Border = [ConsoleColor]::DarkGray
            Selection = [ConsoleColor]::Yellow
            Highlight = [ConsoleColor]::Cyan
            Subtle = [ConsoleColor]::DarkGray
            Keyword = [ConsoleColor]::DarkBlue
            String = [ConsoleColor]::DarkGreen
            Number = [ConsoleColor]::DarkMagenta
            Comment = [ConsoleColor]::DarkGray
        }
    }
    
    Light = @{
        Name = "Light"
        Colors = @{
            Background = [ConsoleColor]::White
            Foreground = [ConsoleColor]::Black
            Primary = [ConsoleColor]::Black
            Secondary = [ConsoleColor]::DarkGray
            Accent = [ConsoleColor]::Blue
            Success = [ConsoleColor]::Green
            Warning = [ConsoleColor]::DarkYellow
            Error = [ConsoleColor]::Red
            Info = [ConsoleColor]::Blue
            Header = [ConsoleColor]::Blue
            Border = [ConsoleColor]::Gray
            Selection = [ConsoleColor]::Cyan
            Highlight = [ConsoleColor]::Yellow
            Subtle = [ConsoleColor]::Gray
            Keyword = [ConsoleColor]::Blue
            String = [ConsoleColor]::Green
            Number = [ConsoleColor]::Magenta
            Comment = [ConsoleColor]::Gray
        }
    }
    
    Retro = @{
        Name = "Retro"
        Colors = @{
            Background = [ConsoleColor]::Black
            Foreground = [ConsoleColor]::Green
            Primary = [ConsoleColor]::Green
            Secondary = [ConsoleColor]::DarkGreen
            Accent = [ConsoleColor]::Yellow
            Success = [ConsoleColor]::Green
            Warning = [ConsoleColor]::Yellow
            Error = [ConsoleColor]::Red
            Info = [ConsoleColor]::Cyan
            Header = [ConsoleColor]::Yellow
            Border = [ConsoleColor]::DarkGreen
            Selection = [ConsoleColor]::Yellow
            Highlight = [ConsoleColor]::White
            Subtle = [ConsoleColor]::DarkGreen
            Keyword = [ConsoleColor]::Yellow
            String = [ConsoleColor]::Cyan
            Number = [ConsoleColor]::White
            Comment = [ConsoleColor]::DarkGreen
        }
    }
}

function global:Initialize-ThemeManager {
    <#
    .SYNOPSIS
    Initializes the theme manager
    #>
    Invoke-WithErrorHandling -Component "ThemeManager.Initialize" -ScriptBlock {
        # Set default theme
        Set-TuiTheme -ThemeName "Modern"
        
        Write-Verbose "Theme manager initialized"
    } -Context @{} -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to initialize Theme Manager: $($Exception.Message)" -Data $Exception.Context
    }
}

function global:Set-TuiTheme {
    <#
    .SYNOPSIS
    Sets the current theme
    
    .PARAMETER ThemeName
    The name of the theme to set
    #>
    param(
        [Parameter(Mandatory = $true)]
        [ValidateSet("Modern", "Dark", "Light", "Retro")]
        [string]$ThemeName
    )
    Invoke-WithErrorHandling -Component "ThemeManager.SetTheme" -ScriptBlock {
        # Initialize themes if null
        if ($null -eq $script:Themes) {
            $script:Themes = @{
                Modern = @{
                    Name = "Modern"
                    Colors = @{
                        Background = [ConsoleColor]::Black
                        Foreground = [ConsoleColor]::White
                        Primary = [ConsoleColor]::White
                        Secondary = [ConsoleColor]::Gray
                        Accent = [ConsoleColor]::Cyan
                        Success = [ConsoleColor]::Green
                        Warning = [ConsoleColor]::Yellow
                        Error = [ConsoleColor]::Red
                        Info = [ConsoleColor]::Blue
                        Header = [ConsoleColor]::Cyan
                        Border = [ConsoleColor]::DarkGray
                        Selection = [ConsoleColor]::Yellow
                        Highlight = [ConsoleColor]::Cyan
                        Subtle = [ConsoleColor]::DarkGray
                    }
                }
            }
        }
        
        if ($script:Themes -and $script:Themes.ContainsKey($ThemeName)) {
            $script:CurrentTheme = $script:Themes[$ThemeName]
            
            # --- FIX ---
            # Defensively check if RawUI exists. In some environments (like the VS Code
            # Integrated Console), it can be $null and cause a crash.
            if ($Host.UI.RawUI) {
                # Apply console colors
                $Host.UI.RawUI.BackgroundColor = $script:CurrentTheme.Colors.Background
                $Host.UI.RawUI.ForegroundColor = $script:CurrentTheme.Colors.Foreground
            }
            
            Write-Verbose "Theme set to: $ThemeName"
            
            # Publish theme change event
            # Check if Publish-Event exists before calling it
            if (Get-Command -Name Publish-Event -ErrorAction SilentlyContinue) {
                Publish-Event -EventName "Theme.Changed" -Data @{ 
                    ThemeName = $ThemeName
                    Theme = $script:CurrentTheme 
                }
            }
        } else {
            Write-Warning "Theme not found: $ThemeName"
        }
    } -Context @{ ThemeName = $ThemeName } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to set TUI Theme to '$($Exception.Context.ThemeName)': $($Exception.Message)" -Data $Exception.Context
    }
}

function global:Get-ThemeColor {
    <#
    .SYNOPSIS
    Gets a color from the current theme
    
    .PARAMETER ColorName
    The name of the color to get
    
    .PARAMETER Default
    Default color if not found
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$ColorName,
        
        [Parameter()]
        [ConsoleColor]$Default = [ConsoleColor]::Gray
    )
    Invoke-WithErrorHandling -Component "ThemeManager.GetColor" -ScriptBlock {
        if ($script:CurrentTheme -and $script:CurrentTheme.Colors.ContainsKey($ColorName)) {
            return $script:CurrentTheme.Colors[$ColorName]
        } else {
            return $Default
        }
    } -Context @{ ColorName = $ColorName; DefaultColor = $Default } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to get theme color '$($Exception.Context.ColorName)': $($Exception.Message)" -Data $Exception.Context
        return $Default # Return default on error
    }
}

function global:Get-TuiTheme {
    <#
    .SYNOPSIS
    Gets the current theme
    #>
    Invoke-WithErrorHandling -Component "ThemeManager.GetTheme" -ScriptBlock {
        return $script:CurrentTheme
    } -Context @{} -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to get current TUI Theme: $($Exception.Message)" -Data $Exception.Context
        return $null # Return null on error
    }
}

function global:Get-AvailableThemes {
    <#
    .SYNOPSIS
    Gets all available themes
    #>
    Invoke-WithErrorHandling -Component "ThemeManager.GetAvailableThemes" -ScriptBlock {
        return $script:Themes.Keys | Sort-Object
    } -Context @{} -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to get available themes: $($Exception.Message)" -Data $Exception.Context
        return @() # Return empty array on error
    }
}

function global:New-TuiTheme {
    <#
    .SYNOPSIS
    Creates a new theme
    
    .PARAMETER Name
    The name of the new theme
    
    .PARAMETER BaseTheme
    The name of the theme to base this on
    
    .PARAMETER Colors
    Hashtable of color overrides
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$Name,
        
        [Parameter()]
        [string]$BaseTheme = "Modern",
        
        [Parameter()]
        [hashtable]$Colors = @{}
    )
    Invoke-WithErrorHandling -Component "ThemeManager.NewTheme" -ScriptBlock {
        # Clone base theme
        $newTheme = @{
            Name = $Name
            Colors = @{}
        }
        
        if ($script:Themes.ContainsKey($BaseTheme)) {
            foreach ($colorKey in $script:Themes[$BaseTheme].Colors.Keys) {
                $newTheme.Colors[$colorKey] = $script:Themes[$BaseTheme].Colors[$colorKey]
            }
        }
        
        # Apply overrides
        foreach ($colorKey in $Colors.Keys) {
            $newTheme.Colors[$colorKey] = $Colors[$colorKey]
        }
        
        # Save theme
        $script:Themes[$Name] = $newTheme
        
        Write-Verbose "Created new theme: $Name"
        
        return $newTheme
    } -Context @{ ThemeName = $Name; BaseTheme = $BaseTheme; CustomColors = $Colors } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to create new TUI Theme '$($Exception.Context.ThemeName)': $($Exception.Message)" -Data $Exception.Context
        return $null # Return null on error
    }
}

function global:Export-TuiTheme {
    <#
    .SYNOPSIS
    Exports a theme to JSON
    
    .PARAMETER ThemeName
    The name of the theme to export
    
    .PARAMETER Path
    The path to save the theme
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$ThemeName,
        
        [Parameter(Mandatory = $true)]
        [string]$Path
    )
    Invoke-WithErrorHandling -Component "ThemeManager.ExportTheme" -ScriptBlock {
        if ($script:Themes.ContainsKey($ThemeName)) {
            $theme = $script:Themes[$ThemeName]
            
            # Convert ConsoleColor enums to strings for JSON
            $exportTheme = @{
                Name = $theme.Name
                Colors = @{}
            }
            
            foreach ($colorKey in $theme.Colors.Keys) {
                $exportTheme.Colors[$colorKey] = $theme.Colors[$colorKey].ToString()
            }
            
            $exportTheme | ConvertTo-Json -Depth 3 | Set-Content -Path $Path
            
            Write-Verbose "Exported theme to: $Path"
        } else {
            Write-Warning "Theme not found: $ThemeName"
        }
    } -Context @{ ThemeName = $ThemeName; FilePath = $Path } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to export TUI Theme '$($Exception.Context.ThemeName)' to '$($Exception.Context.FilePath)': $($Exception.Message)" -Data $Exception.Context
    }
}

function global:Import-TuiTheme {
    <#
    .SYNOPSIS
    Imports a theme from JSON
    
    .PARAMETER Path
    The path to the theme file
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$Path
    )
    Invoke-WithErrorHandling -Component "ThemeManager.ImportTheme" -ScriptBlock {
        if (Test-Path $Path) {
            try {
                $importedTheme = Get-Content $Path -Raw | ConvertFrom-Json -AsHashtable
                
                $theme = @{
                    Name = $importedTheme.Name
                    Colors = @{}
                }
                
                # Convert string color names back to ConsoleColor enums
                foreach ($colorProp in $importedTheme.Colors.PSObject.Properties) {
                    $theme.Colors[$colorProp.Name] = [ConsoleColor]$colorProp.Value
                }
                
                $script:Themes[$theme.Name] = $theme
                
                Write-Verbose "Imported theme: $($theme.Name)"
                
                return $theme
            } catch {
                Write-Log -Level Error -Message "Failed to import theme from '$Path': $_" -Data @{ FilePath = $Path; Exception = $_ }
            }
        } else {
            Write-Warning "Theme file not found: $Path"
        }
    } -Context @{ FilePath = $Path } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to import TUI Theme from '$($Exception.Context.FilePath)': $($Exception.Message)" -Data $Exception.Context
        return $null # Return null on error
    }
}

# Export functions
Export-ModuleMember -Function @(
    'Initialize-ThemeManager',
    'Set-TuiTheme',
    'Get-ThemeColor',
    'Get-TuiTheme',
    'Get-AvailableThemes',
    'New-TuiTheme',
    'Export-TuiTheme',
    'Import-TuiTheme'
)
# Rock-Solid TUI Engine v4.0 - Performance & Reliability Edition
# Implements all critical fixes from code review



#region Core TUI State
$script:TuiState = @{
    Running         = $false
    BufferWidth     = 0
    BufferHeight    = 0
    FrontBuffer     = $null
    BackBuffer      = $null
    ScreenStack     = New-Object System.Collections.Stack
    CurrentScreen   = $null
    IsDirty         = $true
    LastActivity    = [DateTime]::Now
    LastRenderTime  = [DateTime]::MinValue
    RenderStats     = @{ LastFrameTime = 0; FrameCount = 0; TotalTime = 0; TargetFPS = 60 }
    Components      = @()
    Layouts         = @{}
    DebugOverlayEnabled = $false
    FocusedComponent = $null
    
    # Thread-safe input queue and runspace management
    InputQueue = $null
    InputRunspace = $null
    InputPowerShell = $null
    InputAsyncResult = $null
    
    # The correct, thread-safe object for signalling shutdown.
    CancellationTokenSource = $null
    
    # Event cleanup tracking
    EventHandlers = @{}
}

# Debug messages removed to prevent screen bleed-through
# Note: Width and Height params are only available inside Initialize-TuiEngine function



# Cell pool to avoid thousands of hashtable allocations
$script:CellPool = @{
    Pool = New-Object System.Collections.Queue
    MaxSize = 1000
}
#endregion

#region Cell Management & Object Pooling

function Get-PooledCell {
    param(
        [char]$Char = ' ',
        [ConsoleColor]$FG = [ConsoleColor]::White,
        [ConsoleColor]$BG = [ConsoleColor]::Black
    )
    
    if ($script:CellPool.Pool.Count -gt 0) {
        $cell = $script:CellPool.Pool.Dequeue()
        $cell.Char = $Char
        $cell.FG = $FG
        $cell.BG = $BG
        return $cell
    }
    
    # Create new cell if pool is empty
    return @{
        Char = $Char
        FG = $FG
        BG = $BG
    }
}

function Return-CellToPool {
    param($Cell)
    if ($script:CellPool.Pool.Count -lt $script:CellPool.MaxSize) {
        $script:CellPool.Pool.Enqueue($Cell)
    }
}

#endregion

#region Engine Lifecycle & Main Loop

function global:Initialize-TuiEngine {
    param(
        [int]$Width = [Console]::WindowWidth,
        [int]$Height = [Console]::WindowHeight - 1
    )

    # Patch: Always set defaults if not passed in
    if (-not $Width) { $Width = [Console]::WindowWidth }
    if (-not $Height) { $Height = [Console]::WindowHeight - 1 }
    
    if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
        Write-Log -Level Info -Message "Initializing TUI Engine: ${Width}x${Height}"
    }

   

    
    
    try {
        if ($Width -le 0 -or $Height -le 0) { throw "Invalid console dimensions: ${Width}x${Height}" }
        
        $script:TuiState.BufferWidth = $Width
        $script:TuiState.BufferHeight = $Height
        
        # Create 2D arrays for buffers
        $script:TuiState.FrontBuffer = New-Object 'object[,]' $Height, $Width
        $script:TuiState.BackBuffer = New-Object 'object[,]' $Height, $Width
        
        # Initialize buffers with empty cells
        $emptyCell = @{ Char = ' '; FG = [ConsoleColor]::White; BG = [ConsoleColor]::Black }
        for ($y = 0; $y -lt $Height; $y++) {
            for ($x = 0; $x -lt $Width; $x++) {
                $script:TuiState.FrontBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = [ConsoleColor]::Black }
                $script:TuiState.BackBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = [ConsoleColor]::Black }
            }
        }
        
        [Console]::CursorVisible = $false
        [Console]::Clear() # Clear console to remove initialization messages
        
        # Initialize subsystems with error handling
        try { 
            Initialize-LayoutEngines 
            if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
                Write-Log -Level Debug -Message "Layout engines initialized"
            }
        } catch { 
            Write-Warning "Layout engines init failed: $_" 
            if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
                Write-Log -Level Error -Message "Layout engines init failed" -Data $_
            }
        }
        try { 
            Initialize-ComponentSystem 
            if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
                Write-Log -Level Debug -Message "Component system initialized"
            }
        } catch { 
            Write-Warning "Component system init failed: $_" 
            if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
                Write-Log -Level Error -Message "Component system init failed" -Data $_
            }
        }
        
        # Track event handlers for cleanup (event system should already be initialized)
        $script:TuiState.EventHandlers = @{}
        
        # --- THE FIX: HOOK CTRL+C *BEFORE* STARTING THE INPUT THREAD ---
        # Temporarily disabled due to compatibility issues
        # TODO: Re-enable with proper PowerShell event handling
        try {
            [Console]::TreatControlCAsInput = $false
            # Ctrl+C handler temporarily disabled - will terminate process normally
        } catch {
            Write-Warning "Could not set console input mode: $_"
        }
        
        # Now it is safe to start the input thread.
        Initialize-InputThread
        
        # Publish initialization event
        Safe-PublishEvent -EventName "System.EngineInitialized" -Data @{ Width = $Width; Height = $Height }
        
        # Export TuiState for global access
        $global:TuiState = $script:TuiState
        
        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            Write-Log -Level Info -Message "TUI Engine initialized successfully"
        }
    }
    catch {
        # --- ENHANCED DIAGNOSTIC BLOCK ---
        # This will now clearly print the root cause of any initialization failure.
        Write-Host "--------------------------------------------------------" -ForegroundColor Red
        Write-Host "IMMEDIATE, ORIGINAL ERROR DETECTED DURING INITIALIZATION" -ForegroundColor Red
        Write-Host "THE *REAL* PROBLEM IS LIKELY THIS:" -ForegroundColor Yellow
        
        if ($_) {
            Write-Host "MESSAGE: $($_.Exception.Message)" -ForegroundColor White
            
            Write-Host "FULL ERROR:" -ForegroundColor Yellow
            if ($_.Exception) {
                $_.Exception | Format-List * -Force
            } else {
                Write-Host "Error details: $_" -ForegroundColor White
            }
        } else {
            Write-Host "Unknown error occurred" -ForegroundColor White
        }
        
        Write-Host "--------------------------------------------------------" -ForegroundColor Red
        
        # Re-throw the exception so the main script's finally block is triggered for cleanup.
        throw "FATAL: TUI Engine initialization failed. See original error details above."
    }
}

function Initialize-InputThread {
    try {
        # Create thread-safe input handling
        $queueType = [System.Collections.Concurrent.ConcurrentQueue[System.ConsoleKeyInfo]]
        $script:TuiState.InputQueue = New-Object $queueType
    } catch {
        Write-Warning "Failed to create ConcurrentQueue, falling back to ArrayList"
        $script:TuiState.InputQueue = [System.Collections.ArrayList]::Synchronized([System.Collections.ArrayList]::new())
    }
    
    # Create the cancellation token source for thread-safe shutdown.
    $script:TuiState.CancellationTokenSource = [System.Threading.CancellationTokenSource]::new()
    $token = $script:TuiState.CancellationTokenSource.Token

    # Create runspace for input handling (fully-qualified .NET types)
    $runspace = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()
    $runspace.Open()
    $runspace.SessionStateProxy.SetVariable('InputQueue', $script:TuiState.InputQueue)
    $runspace.SessionStateProxy.SetVariable('token', $token)
    
    # Create a PowerShell instance in that runspace
    $ps = [System.Management.Automation.PowerShell]::Create()
    $ps.Runspace = $runspace
    
    # This script block will run in the background.
    $ps.AddScript({
        try {
            while (-not $token.IsCancellationRequested) {
                if ([Console]::KeyAvailable) {
                    $keyInfo = [Console]::ReadKey($true)
                    
                    # Handle different queue types
                    if ($InputQueue -is [System.Collections.Concurrent.ConcurrentQueue[System.ConsoleKeyInfo]]) {
                        if ($InputQueue.Count -lt 100) {
                            $InputQueue.Enqueue($keyInfo)
                        }
                    } elseif ($InputQueue -is [System.Collections.ArrayList]) {
                        if ($InputQueue.Count -lt 100) {
                            $InputQueue.Add($keyInfo) | Out-Null
                        }
                    }
                }
                else {
                    Start-Sleep -Milliseconds 20
                }
            }
        }
        catch [System.Management.Automation.PipelineStoppedException] {
            return
        }
        catch {
            Write-Warning "Input thread error: $_"
        }
    }) | Out-Null
    
    # Store for cleanup
    $script:TuiState.InputRunspace   = $runspace
    $script:TuiState.InputPowerShell = $ps
    $script:TuiState.InputAsyncResult = $ps.BeginInvoke()
}

function Process-TuiInput {
    # Process all queued input events
    $processedAny = $false
    # Check if the queue exists before trying to use it.
    if (-not $script:TuiState.InputQueue) { return $false }
    
    if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
        Write-Log -Level Verbose -Message "Processing input queue"
    }

    $keyInfo = $null
    
    # Handle different queue types
    if ($script:TuiState.InputQueue -is [System.Collections.Concurrent.ConcurrentQueue[System.ConsoleKeyInfo]]) {
        $keyInfo = [System.ConsoleKeyInfo]::new([char]0, [System.ConsoleKey]::None, $false, $false, $false)
        while ($script:TuiState.InputQueue.TryDequeue([ref]$keyInfo)) {
            $processedAny = $true
            $script:TuiState.LastActivity = [DateTime]::Now
            Invoke-WithErrorHandling -Component "Engine.ProcessInput" -ScriptBlock {
                Process-SingleKeyInput -keyInfo $keyInfo
            } -Context @{ KeyInfo = $keyInfo } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "Error processing single key input: $($Exception.Message)" -Data $Exception.Context
                Request-TuiRefresh
            }
        }
    } elseif ($script:TuiState.InputQueue -is [System.Collections.ArrayList]) {
        while ($script:TuiState.InputQueue.Count -gt 0) {
            try {
                $keyInfo = $script:TuiState.InputQueue[0]
                $script:TuiState.InputQueue.RemoveAt(0)
                $processedAny = $true
                $script:TuiState.LastActivity = [DateTime]::Now
                Invoke-WithErrorHandling -Component "Engine.ProcessInput" -ScriptBlock {
                    Process-SingleKeyInput -keyInfo $keyInfo
                } -Context @{ KeyInfo = $keyInfo } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "Error processing single key input: $($Exception.Message)" -Data $Exception.Context
                    Request-TuiRefresh
                }
            } catch {
                break
            }
        }
    }
    
    return $processedAny
}

###```focus adddition 
function global:Set-ComponentFocus {
    param(
        [hashtable]$Component
    )
    
    $oldFocusedComponent = $script:TuiState.FocusedComponent
    
    if ($null -ne $oldFocusedComponent -and $oldFocusedComponent -ne $Component) {
        $oldFocusedComponent.IsFocused = $false
        if ($oldFocusedComponent.OnBlur) {
            try { & $oldFocusedComponent.OnBlur -self $oldFocusedComponent }
            catch { Write-Log -Level Warning -Message "OnBlur error: $_" }
        }
    }

    if ($null -eq $Component) {
        $script:TuiState.FocusedComponent = $null
        Request-TuiRefresh
        return
    }

    if ($Component.IsFocusable -ne $true -or $Component.Visible -ne $true) {
        return
    }

    $script:TuiState.FocusedComponent = $Component
    $Component.IsFocused = $true
    
    if ($Component.OnFocus) {
        try { & $Component.OnFocus -self $Component }
        catch { Write-Log -Level Warning -Message "OnFocus error: $_" }
    }
    
    Request-TuiRefresh
}

function global:Handle-TabNavigation {
    param(
        [bool]$Reverse = $false
    )
    
    $currentScreen = $script:TuiState.CurrentScreen
    if (-not $currentScreen) { return }

    $focusable = @()
    $FindFocusableIn = {
        param($component)
        if ($component -and $component.IsFocusable -eq $true -and $component.Visible -eq $true) {
            $script:focusable += $component
        }
        if ($component -and $component.Children) {
            foreach ($child in $component.Children) {
                & $script:FindFocusableIn -component $child
            }
        }
    }
    
    foreach ($compName in $currentScreen.Components.Keys) {
        & $FindFocusableIn -component $currentScreen.Components[$compName]
    }

    if ($focusable.Count -eq 0) { return }

    $sortedFocusable = $focusable | Sort-Object { $_.Y }, { $_.X }

    $currentIndex = [array]::IndexOf($sortedFocusable, $script:TuiState.FocusedComponent)
    
    $nextIndex = 0
    if ($currentIndex -ne -1) {
        $direction = if ($Reverse) { -1 } else { 1 }
        $nextIndex = ($currentIndex + $direction + $sortedFocusable.Count) % $sortedFocusable.Count
    }

    Set-ComponentFocus -Component $sortedFocusable[$nextIndex]
}

function global:Clear-ComponentFocus {
    Set-ComponentFocus -Component $null
}
###```

function Process-SingleKeyInput {
    param($keyInfo)
    
    try {
        # Tab navigation handled by focus manager if available
        if ($keyInfo.Key -eq [ConsoleKey]::Tab) {
            if (Get-Command -Name "Move-Focus" -ErrorAction SilentlyContinue) {
                Move-Focus -Reverse ($keyInfo.Modifiers -band [ConsoleModifiers]::Shift)
            } else {
                # Fallback to old tab navigation
                Handle-TabNavigation -Reverse ($keyInfo.Modifiers -band [ConsoleModifiers]::Shift)
            }
            return
        }
        
        # Dialog system gets first chance at input
        if ((Get-Command -Name "Handle-DialogInput" -ErrorAction SilentlyContinue) -and (Handle-DialogInput -Key $keyInfo)) {
            return
        }
        
        # Get focused component from focus manager if available
        $focusedComponent = if (Get-Command -Name "Get-FocusedComponent" -ErrorAction SilentlyContinue) {
            Get-FocusedComponent
        } else {
            $script:TuiState.FocusedComponent
        }
        
        # Focused component gets the next chance
        if ($focusedComponent -and $focusedComponent.HandleInput) {
            try {
                if (& $focusedComponent.HandleInput -self $focusedComponent -Key $keyInfo) {
                    return
                }
            } catch {
                Write-Warning "Component input handler error: $_"
            }
        }
        
        # Finally, the screen itself gets the key
        $currentScreen = $script:TuiState.CurrentScreen
        if ($currentScreen -and $currentScreen.HandleInput) {
            try {
                $result = & $currentScreen.HandleInput -self $currentScreen -Key $keyInfo
                switch ($result) {
                    "Back" { Pop-Screen }
                    "Quit" { 
                        $script:TuiState.Running = $false
                        if ($script:TuiState.CancellationTokenSource) {
                            $script:TuiState.CancellationTokenSource.Cancel()
                        }
                    }
                }
            } catch {
                Write-Warning "Screen input handler error: $_"
            }
        }
    } catch {
        Write-Warning "Input processing error: $_"
    }
}

function global:Start-TuiLoop {
    param([hashtable]$InitialScreen = $null)

    try {
        # Only initialize if not already initialized
        if (-not $script:TuiState.BufferWidth -or $script:TuiState.BufferWidth -eq 0) {
            Initialize-TuiEngine
        }
        
        if ($InitialScreen) {
            Push-Screen -Screen $InitialScreen
        }
        
        # If no screen is active and no initial screen provided, we can't start
        if (-not $script:TuiState.CurrentScreen -and $script:TuiState.ScreenStack.Count -eq 0) {
            throw "No screen available to display. Push a screen before calling Start-TuiLoop or provide an InitialScreen parameter."
        }

        $script:TuiState.Running = $true
        $frameTime = New-Object System.Diagnostics.Stopwatch
        $targetFrameTime = 1000.0 / $script:TuiState.RenderStats.TargetFPS
        
        while ($script:TuiState.Running) {
            # ==========================================================
            # === BEGIN CENTRAL EXCEPTION HANDLING BLOCK ===
            # ==========================================================
            try {
                $frameTime.Restart()

                # Process input
                $hadInput = Process-TuiInput
                
                # Update dialog system
                if (Get-Command -Name "Update-DialogSystem" -ErrorAction SilentlyContinue) { 
                    try { Update-DialogSystem } catch { Write-Log -Level Warning -Message "Dialog update error: $_" }
                }

                # Render if dirty or had input
                if ($script:TuiState.IsDirty -or $hadInput) {
                    Render-Frame
                    $script:TuiState.IsDirty = $false
                }
                
                # Adaptive frame timing
                $elapsed = $frameTime.ElapsedMilliseconds
                if ($elapsed -lt $targetFrameTime) {
                    $sleepTime = [Math]::Max(1, $targetFrameTime - $elapsed)
                    Start-Sleep -Milliseconds $sleepTime
                }
            }
            catch [HeliosException] {
                # --- This block handles our custom, "recoverable" errors ---
                $exception = $_.Exception
                
                # 1. Log the rich, detailed error for developers
                Write-Log -Level Error -Message "A TUI Exception occurred: $($exception.Message)" -Data $exception.Context
                
                # 2. Show a simple, clean dialog to the user
                Show-AlertDialog -Title "Application Error" -Message "An operation failed: $($exception.Message)"
                
                # 3. Force a full re-render to clean up any UI artifacts from the failed operation
                $script:TuiState.IsDirty = $true
            }
            catch {
                # --- This block handles unexpected, potentially fatal errors ---
                $exception = $_.Exception
                
                # 1. Log the catastrophic failure
                Write-Log -Level Error -Message "A FATAL, unhandled exception occurred: $($exception.Message)" -Data $_
                
                # 2. Inform the user and prepare for shutdown
                Show-AlertDialog -Title "Fatal Error" -Message "A critical error occurred. The application will now close."
                
                # 3. Stop the main loop to exit gracefully
                $script:TuiState.Running = $false
            }
            # ==========================================================
            # === END CENTRAL EXCEPTION HANDLING BLOCK ===
            # ==========================================================
        }
    }
    finally {
        Cleanup-TuiEngine
    }
}

# ==============================================================================
# === CRITICAL FIX: NEW RENDER-FRAME IMPLEMENTATION ============================
# ==============================================================================
function Render-Frame {
    try {
        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            Write-Log -Level Verbose -Message "Starting Z-Index frame render"
        }
        
        $bgColor = if (Get-Command -Name "Get-ThemeColor" -ErrorAction SilentlyContinue) {
            Get-ThemeColor "Background"
        } else {
            [ConsoleColor]::Black
        }
        
        # Always clear the back buffer completely
        Clear-BackBuffer -BackgroundColor $bgColor
        
        # 1. RENDER SCREEN CHROME (Header, Footer, etc.)
        # This is for elements NOT in the component tree. The screen's Render method
        # should ONLY draw these non-component elements.
        if ($script:TuiState.CurrentScreen -and $script:TuiState.CurrentScreen.Render) {
            Invoke-WithErrorHandling -Component "$($script:TuiState.CurrentScreen.Name).Render" -ScriptBlock {
                & $script:TuiState.CurrentScreen.Render -self $script:TuiState.CurrentScreen
            } -Context @{ ScreenName = $script:TuiState.CurrentScreen.Name } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "Screen-level render error: $($Exception.Message)" -Data $Exception.Context
            }
        }

        # 2. COLLECT all visible components from the screen's Children and any active dialogs.
        $renderQueue = [System.Collections.Generic.List[hashtable]]::new()
        
        # Debug: Log screen state
        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            Write-Log -Level Debug -Message "Render-Frame: CurrentScreen=$($script:TuiState.CurrentScreen.Name), Children count=$($script:TuiState.CurrentScreen.Children.Count)"
        }
        
        # Define collectComponents as a scriptblock variable that can reference itself
        $script:collectComponents = {
            param($component)
            if (-not $component -or $component.Visible -eq $false) { return }
            
            # Add the component itself to the queue
            $renderQueue.Add($component)
            
            # Debug logging
            if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
                Write-Log -Level Debug -Message "Collected component: Type=$($component.Type), Name=$($component.Name), Pos=($($component.X),$($component.Y)), ZIndex=$($component.ZIndex), Children=$($component.Children.Count)"
            }
            
            # Process children if any
            if ($component.Children -and $component.Children.Count -gt 0) {
                # A panel must calculate its children's layout before they are collected
                if ($component.CalculateLayout) {
    		  try { 
        		[void](& $component.CalculateLayout -self $component) # FIX: Suppress output
   		  }
    		  catch { 
        		Write-Log -Level Error -Message "Layout failed for '$($component.Name)'" -Data $_ 
    		  }
	    }
                
                # Recursively collect each child
                foreach ($child in $component.Children) {
                    & $script:collectComponents $child
                }
            }
        }

        # Start collection from the screen's children
        if ($script:TuiState.CurrentScreen -and $script:TuiState.CurrentScreen.Children) {
            foreach ($child in $script:TuiState.CurrentScreen.Children) {
                & $script:collectComponents -component $child
            }
        }

        # Collect from the current dialog (which is a self-contained component tree)
        if ((Get-Command -Name "Get-CurrentDialog" -ErrorAction SilentlyContinue)) {
            $currentDialog = Get-CurrentDialog
            if ($currentDialog) {
                & $script:collectComponents -component $currentDialog
            }
        }
        
        # 3. SORT the render queue by ZIndex
        $sortedQueue = $renderQueue | Sort-Object -Property ZIndex
        
        # 4. DRAW the sorted components
        foreach ($componentToRender in $sortedQueue) {
            if ($componentToRender.Render) {
                Invoke-WithErrorHandling -Component "$($componentToRender.Name ?? $componentToRender.Type).Render" -ScriptBlock {
                    & $componentToRender.Render -self $componentToRender
                } -Context @{ ComponentType = $componentToRender.Type; ComponentName = $componentToRender.Name; ComponentProps = $componentToRender.Props } -ErrorHandler {
                    param($Exception)
                    throw [ComponentRenderException]::new(
                        "Failed to render component '$($Exception.Context.ComponentName ?? $Exception.Context.ComponentType)'",
                        @{
                            FailingComponent = $Exception.Context.Component
                            OriginalException = $Exception.OriginalError # Preserve the original error object
                        }
                    )
                }
            }
        }
        
        # 5. FINALIZE the frame
        Render-BufferOptimized
        
        # Force cursor to bottom-right to avoid interference
        [Console]::SetCursorPosition($script:TuiState.BufferWidth - 1, $script:TuiState.BufferHeight - 1)
        
    } catch {
        Write-Warning "Fatal Frame render error: $_"
    }
}

function global:Request-TuiRefresh {
    $script:TuiState.IsDirty = $true
}

function Cleanup-TuiEngine {
    try {
        # --- ROBUST CLEANUP ROUTINE ---
        # This sequence is defensive and will not fail even if initialization was partial.
        if ($script:TuiState.CancellationTokenSource) {
            try {
                if (-not $script:TuiState.CancellationTokenSource.IsCancellationRequested) {
                    $script:TuiState.CancellationTokenSource.Cancel()
                }
            } catch { 
                # Ignore errors if CancellationTokenSource is in an invalid state
            }
        }

        if ($script:TuiState.InputPowerShell) {
            if ($script:TuiState.InputAsyncResult) {
                try { $script:TuiState.InputPowerShell.EndInvoke($script:TuiState.InputAsyncResult) } catch { }
            }
            try { $script:TuiState.InputPowerShell.Dispose() } catch { }
        }
        
        if ($script:TuiState.InputRunspace) {
            try { $script:TuiState.InputRunspace.Dispose() } catch { }
        }
        
        if ($script:TuiState.CancellationTokenSource) {
            try { $script:TuiState.CancellationTokenSource.Dispose() } catch { }
        }

        # Clean up background jobs
        if (Get-Command -Name "Stop-AllTuiAsyncJobs" -ErrorAction SilentlyContinue) {
            try { Stop-AllTuiAsyncJobs } catch { }
        }

        Cleanup-EventHandlers
        
        # Only try to reset the console if we are in an interactive session
        if (-not $env:CI -and -not $PSScriptRoot) {
            try {
                if ([System.Environment]::UserInteractive) {
                    [Console]::Write("$([char]27)[0m")
                    [Console]::CursorVisible = $true
                    [Console]::Clear()
                    [Console]::ResetColor()
                }
            } catch {
                # This can fail in non-interactive environments, ignore the error.
            }
        }
    } catch {
        Write-Warning "A secondary error occurred during TUI cleanup: $_"
    }
}

function Cleanup-EventHandlers {
    if (-not (Get-Command -Name "Unsubscribe-Event" -ErrorAction SilentlyContinue)) { return }
    if (-not $script:TuiState.EventHandlers) { return }

    foreach ($handlerId in $script:TuiState.EventHandlers.Values) {
        try { Unsubscribe-Event -HandlerId $handlerId } catch { }
    }
    $script:TuiState.EventHandlers.Clear()
    
    # Clean up any orphaned Ctrl+C event handler if it exists
    try {
        Get-EventSubscriber -SourceIdentifier "TuiCtrlC" -ErrorAction SilentlyContinue | Unregister-Event
    } catch { }
}

function Safe-PublishEvent {
    param($EventName, $Data)
    if (Get-Command -Name "Publish-Event" -ErrorAction SilentlyContinue) {
        try { Publish-Event -EventName $EventName -Data $Data } catch { }
    }
}

#endregion

#region Screen Management

function global:Push-Screen {
    param([hashtable]$Screen)
    if (-not $Screen) { return }
    
    if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
        Write-Log -Level Debug -Message "Pushing screen: $($Screen.Name)"
    }
    
    try {
        # Handle focus before switching screens
        if ($script:TuiState.FocusedComponent -and $script:TuiState.FocusedComponent.OnBlur) {
            try {
                & $script:TuiState.FocusedComponent.OnBlur -self $script:TuiState.FocusedComponent
            } catch {
                # This is less critical, so a log is acceptable, but we can be more specific.
                Write-Log -Level Warning -Message "Error in OnBlur for component '$($script:TuiState.FocusedComponent.Name)'" -Data $_
            }
        }
        
        if ($script:TuiState.CurrentScreen) {
            if ($script:TuiState.CurrentScreen.OnExit) { 
                Invoke-WithErrorHandling -Component "$($script:TuiState.CurrentScreen.Name).OnExit" -ScriptBlock {
                    & $script:TuiState.CurrentScreen.OnExit -self $script:TuiState.CurrentScreen
                } -Context @{ ScreenName = $script:TuiState.CurrentScreen.Name } -ErrorHandler {
                    param($Exception)
                    Write-Warning "Screen exit error: $($Exception.Message)"
                }
            }
            $script:TuiState.ScreenStack.Push($script:TuiState.CurrentScreen)
        }
        
        $script:TuiState.CurrentScreen = $Screen
        $script:TuiState.FocusedComponent = $null  # Clear focus when changing screens
        
        if ($Screen.Init) { 
            Invoke-WithErrorHandling -Component "$($Screen.Name).Init" -ScriptBlock {
                # Pass services if available on the screen object
                if ($Screen._services) {
                    & $Screen.Init -self $Screen -services $Screen._services
                } else {
                    & $Screen.Init -self $Screen
                }
            } -Context @{ ScreenName = $Screen.Name } -ErrorHandler {
                param($Exception)
                throw [ServiceInitializationException]::new(
                    "Failed to initialize screen '$($Exception.Context.ScreenName)'",
                    @{
                        FailingScreen = $Screen
                        OriginalException = $Exception.OriginalError
                    }
                )
            }
        }
        
        Request-TuiRefresh
        Safe-PublishEvent -EventName "Screen.Pushed" -Data @{ ScreenName = $Screen.Name }
        
    } catch {
        Write-Warning "Push screen error: $_"
    }
}

function global:Pop-Screen {
    if ($script:TuiState.ScreenStack.Count -eq 0) { return $false }
    
    if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
        Write-Log -Level Debug -Message "Popping screen"
    }
    
    try {
        # Handle focus before switching screens
        if ($script:TuiState.FocusedComponent -and $script:TuiState.FocusedComponent.OnBlur) {
            try {
                & $script:TuiState.FocusedComponent.OnBlur -self $script:TuiState.FocusedComponent
            } catch {
                Write-Warning "Component blur error: $_"
            }
        }
        
        # Store the screen to exit before changing CurrentScreen
        $screenToExit = $script:TuiState.CurrentScreen
        
        # Pop the new screen from the stack
        $script:TuiState.CurrentScreen = $script:TuiState.ScreenStack.Pop()
        $script:TuiState.FocusedComponent = $null  # Clear focus when changing screens
        
        # Call lifecycle hooks in correct order
        if ($screenToExit -and $screenToExit.OnExit) { 
            Invoke-WithErrorHandling -Component "$($screenToExit.Name).OnExit" -ScriptBlock {
                & $screenToExit.OnExit -self $screenToExit
            } -Context @{ ScreenName = $screenToExit.Name } -ErrorHandler {
                param($Exception)
                Write-Warning "Screen exit error: $($Exception.Message)"
            }
        }
        if ($script:TuiState.CurrentScreen -and $script:TuiState.CurrentScreen.OnResume) { 
            Invoke-WithErrorHandling -Component "$($script:TuiState.CurrentScreen.Name).OnResume" -ScriptBlock {
                & $script:TuiState.CurrentScreen.OnResume -self $script:TuiState.CurrentScreen
            } -Context @{ ScreenName = $script:TuiState.CurrentScreen.Name } -ErrorHandler {
                param($Exception)
                Write-Warning "Screen resume error: $($Exception.Message)"
            }
        }
        
        # Restore focus if the screen tracks it
        if ($script:TuiState.CurrentScreen.LastFocusedComponent) {
            Set-ComponentFocus -Component $script:TuiState.CurrentScreen.LastFocusedComponent
        }
        
        Request-TuiRefresh
        Safe-PublishEvent -EventName "Screen.Popped" -Data @{ ScreenName = $script:TuiState.CurrentScreen.Name }
        
        return $true
        
    } catch {
        Write-Warning "Pop screen error: $_"
        return $false
    }
}

#endregion

#region Buffer and Rendering

# GetBufferIndex no longer needed - using 2D arrays directly

function global:Clear-BackBuffer {
    param([ConsoleColor]$BackgroundColor = [ConsoleColor]::Black)
    
    # Create a new cell for each position to ensure proper clearing
    for ($y = 0; $y -lt $script:TuiState.BufferHeight; $y++) {
        for ($x = 0; $x -lt $script:TuiState.BufferWidth; $x++) {
            $script:TuiState.BackBuffer[$y, $x] = @{ 
                Char = ' '
                FG = [ConsoleColor]::White
                BG = $BackgroundColor 
            }
        }
    }
}

function global:Write-BufferString {
    param(
        [int]$X, 
        [int]$Y, 
        [string]$Text, 
        [ConsoleColor]$ForegroundColor = [ConsoleColor]::White, 
        [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black
    )
    if ($Y -lt 0 -or $Y -ge $script:TuiState.BufferHeight) { return }
    if ([string]::IsNullOrEmpty($Text)) { return }
    
    $currentX = $X
    foreach ($char in $Text.ToCharArray()) {
        if ($currentX -ge $script:TuiState.BufferWidth) { break }

        if ($currentX -ge 0) {
            $script:TuiState.BackBuffer[$Y, $currentX] = @{ 
                Char = $char
                FG = $ForegroundColor
                BG = $BackgroundColor 
            }
        }
        
        # Pragmatic check for CJK/wide characters. A full implementation is library-dependent.
        if ($char -match '[\u1100-\u11FF\u2E80-\uA4CF\uAC00-\uD7A3\uF900-\uFAFF\uFE30-\uFE4F\uFF00-\uFFEF]') {
            $currentX += 2
            # Also fill the next cell with a space for wide characters to prevent overlap
            if ($currentX -lt $script:TuiState.BufferWidth -and $currentX -gt 0) {
                $script:TuiState.BackBuffer[$Y, $currentX - 1] = @{ 
                    Char = ' '
                    FG = $ForegroundColor
                    BG = $BackgroundColor 
                }
            }
        } else {
            $currentX++
        }
    }
}

function global:Write-BufferBox {
    param(
        [int]$X, 
        [int]$Y, 
        [int]$Width, 
        [int]$Height, 
        [string]$BorderStyle = "Single", 
        [ConsoleColor]$BorderColor = [ConsoleColor]::White, 
        [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black, 
        [string]$Title = ""
    )
    $borders = Get-BorderChars -Style $BorderStyle
    
    # Top border
    Write-BufferString -X $X -Y $Y -Text "$($borders.TopLeft)$($borders.Horizontal * ($Width - 2))$($borders.TopRight)" -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    
    # Title
    if ($Title) {
        $titleText = " $Title "
        if ($titleText.Length -gt ($Width - 2)) {
            # FIX: Ensure the length for Substring is never negative.
            $maxLength = [Math]::Max(0, $Width - 5)
            $titleText = " $($Title.Substring(0, $maxLength))... "
        }
        $titleX = $X + [Math]::Floor(($Width - $titleText.Length) / 2)
       Write-BufferString -X $titleX -Y $Y -Text $titleText -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    
    # Sides and Fill
    for ($i = 1; $i -lt ($Height - 1); $i++) {
        Write-BufferString -X $X -Y ($Y + $i) -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
        Write-BufferString -X ($X + 1) -Y ($Y + $i) -Text (' ' * ($Width - 2)) -BackgroundColor $BackgroundColor
        Write-BufferString -X ($X + $Width - 1) -Y ($Y + $i) -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    
    # Bottom border
    Write-BufferString -X $X -Y ($Y + $Height - 1) -Text "$($borders.BottomLeft)$($borders.Horizontal * ($Width - 2))$($borders.BottomRight)" -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
}

function global:Render-BufferOptimized {
    $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()
    $outputBuilder = New-Object System.Text.StringBuilder -ArgumentList 20000
    $lastFG = -1
    $lastBG = -1
    
    # Force full render on first frame or if requested
    $forceFullRender = $script:TuiState.RenderStats.FrameCount -eq 0
    
    try {
        # Build ANSI output with change detection
        for ($y = 0; $y -lt $script:TuiState.BufferHeight; $y++) {
            # Position cursor at start of line
            $outputBuilder.Append("$([char]27)[$($y + 1);1H") | Out-Null
            
            for ($x = 0; $x -lt $script:TuiState.BufferWidth; $x++) {
                $backCell = $script:TuiState.BackBuffer[$y, $x]
                $frontCell = $script:TuiState.FrontBuffer[$y, $x]
                
                # Skip if cell hasn't changed (unless forcing full render)
                if (-not $forceFullRender -and
                    $backCell.Char -eq $frontCell.Char -and 
                    $backCell.FG -eq $frontCell.FG -and 
                    $backCell.BG -eq $frontCell.BG) {
                    continue
                }
                
                # Position cursor if we skipped cells
                if ($x -gt 0 -and $outputBuilder.Length -gt 0) {
                    $outputBuilder.Append("$([char]27)[$($y + 1);$($x + 1)H") | Out-Null
                }
                
                # Update colors if changed
                if ($backCell.FG -ne $lastFG -or $backCell.BG -ne $lastBG) {
                    $fgCode = Get-AnsiColorCode $backCell.FG
                    $bgCode = Get-AnsiColorCode $backCell.BG -IsBackground $true
                    $outputBuilder.Append("$([char]27)[${fgCode};${bgCode}m") | Out-Null
                    $lastFG = $backCell.FG
                    $lastBG = $backCell.BG
                }
                
                # Append character
                $outputBuilder.Append($backCell.Char) | Out-Null
                
                # Update front buffer
                $script:TuiState.FrontBuffer[$y, $x] = @{
                    Char = $backCell.Char
                    FG = $backCell.FG
                    BG = $backCell.BG
                }
            }
        }
        
        # Reset ANSI formatting at the end
        $outputBuilder.Append("$([char]27)[0m") | Out-Null
        
        # Write to console
        if ($outputBuilder.Length -gt 0) {
            [Console]::Write($outputBuilder.ToString())
        }
        
    } catch {
        Write-Warning "Render error: $_"
    }
    
    # Update stats
    $stopwatch.Stop()
    $script:TuiState.RenderStats.LastFrameTime = $stopwatch.ElapsedMilliseconds
    $script:TuiState.RenderStats.FrameCount++
    $script:TuiState.RenderStats.TotalTime += $stopwatch.ElapsedMilliseconds
}

#endregion

#region Component System

function Initialize-ComponentSystem {
    $script:TuiState.Components = @()
    $script:TuiState.FocusedComponent = $null
}

function global:Register-Component {
    param([hashtable]$Component)
    
    # Add to component registry
    $script:TuiState.Components += $Component
    
    # Initialize component with error handling
    if ($Component.Init) {
        Invoke-WithErrorHandling -Component "$($Component.Name ?? $Component.Type).Init" -ScriptBlock {
            & $Component.Init -self $Component
        } -Context @{ ComponentType = $Component.Type; ComponentName = $Component.Name } -ErrorHandler {
            param($Exception)
            Write-Warning "Component init error: $($Exception.Message)"
        }
    }
    
    return $Component
}

function global:Set-ComponentFocus {
    param([hashtable]$Component)
    
    # Don't focus disabled components
    if ($Component -and ($Component.IsEnabled -eq $false -or $Component.Disabled -eq $true)) {
        return
    }
    
    # Blur previous component with error handling
    if ($script:TuiState.FocusedComponent -and $script:TuiState.FocusedComponent.OnBlur) {
        Invoke-WithErrorHandling -Component "$($script:TuiState.FocusedComponent.Name ?? $script:TuiState.FocusedComponent.Type).OnBlur" -ScriptBlock {
            & $script:TuiState.FocusedComponent.OnBlur -self $script:TuiState.FocusedComponent
        } -Context @{ ComponentType = $script:TuiState.FocusedComponent.Type; ComponentName = $script:TuiState.FocusedComponent.Name } -ErrorHandler {
            param($Exception)
            Write-Warning "Component blur error: $($Exception.Message)"
        }
    }
    
    # Track focus on current screen
    if ($script:TuiState.CurrentScreen) {
        $script:TuiState.CurrentScreen.LastFocusedComponent = $Component
    }
    
    # Focus new component with error handling
    $script:TuiState.FocusedComponent = $Component
    if ($Component -and $Component.OnFocus) {
        Invoke-WithErrorHandling -Component "$($Component.Name ?? $Component.Type).OnFocus" -ScriptBlock {
            & $Component.OnFocus -self $Component
        } -Context @{ ComponentType = $Component.Type; ComponentName = $Component.Name } -ErrorHandler {
            param($Exception)
            Write-Warning "Component focus error: $($Exception.Message)"
        }
    }
    
    Request-TuiRefresh
}

function global:Clear-ComponentFocus {
    <#
    .SYNOPSIS
    Clears focus from the current component
    #>
    if ($script:TuiState.FocusedComponent -and $script:TuiState.FocusedComponent.OnBlur) {
        Invoke-WithErrorHandling -Component "$($script:TuiState.FocusedComponent.Name ?? $script:TuiState.FocusedComponent.Type).OnBlur" -ScriptBlock {
            & $script:TuiState.FocusedComponent.OnBlur -self $script:TuiState.FocusedComponent
        } -Context @{ ComponentType = $script:TuiState.FocusedComponent.Type; ComponentName = $script:TuiState.FocusedComponent.Name } -ErrorHandler {
            param($Exception)
            Write-Warning "Component blur error: $($Exception.Message)"
        }
    }
    
    $script:TuiState.FocusedComponent = $null
    
    # Clear tracked focus on current screen
    if ($script:TuiState.CurrentScreen) {
        $script:TuiState.CurrentScreen.LastFocusedComponent = $null
    }
    
    Request-TuiRefresh
}

function global:Get-NextFocusableComponent {
    <#
    .SYNOPSIS
    Gets the next focusable component in tab order
    #>
    param(
        [hashtable]$CurrentComponent,
        [bool]$Reverse = $false
    )
    
    if (-not $script:TuiState.CurrentScreen) { return $null }
    
    # Get all focusable components
    $focusableComponents = @()
    
    # Recursive function to find focusable components
    function Find-FocusableComponents {
        param($Component)
        
        # Check using the correct properties that our components actually have
        if ($Component.IsFocusable -eq $true -and 
            $Component.Visible -ne $false) {
            $focusableComponents += $Component
        }
        
        if ($Component.Children) {
            foreach ($child in $Component.Children) {
                Find-FocusableComponents -Component $child
            }
        }
    }
    
    # Start from screen components
    if ($script:TuiState.CurrentScreen.Components) {
        if ($script:TuiState.CurrentScreen.Components -is [hashtable]) {
            foreach ($comp in $script:TuiState.CurrentScreen.Components.Values) {
                Find-FocusableComponents -Component $comp
            }
        } elseif ($script:TuiState.CurrentScreen.Components -is [array]) {
            foreach ($comp in $script:TuiState.CurrentScreen.Components) {
                Find-FocusableComponents -Component $comp
            }
        }
    }
    
    if ($focusableComponents.Count -eq 0) { return $null }
    
    # Sort by TabIndex or position
    $sorted = $focusableComponents | Sort-Object {
        if ($null -ne $_.TabIndex) { $_.TabIndex }
        else { $_.Y * 1000 + $_.X }
    }
    
    if ($Reverse) {
        [Array]::Reverse($sorted)
    }
    
    # Find current index
    $currentIndex = -1
    for ($i = 0; $i -lt $sorted.Count; $i++) {
        if ($sorted[$i] -eq $CurrentComponent) {
            $currentIndex = $i
            break
        }
    }
    
    # Get next component
    if ($currentIndex -ge 0) {
        $nextIndex = ($currentIndex + 1) % $sorted.Count
        return $sorted[$nextIndex]
    } else {
        return $sorted[0]
    }
}

function global:Handle-TabNavigation {
    <#
    .SYNOPSIS
    Handles Tab key navigation between components  
    #>
    param([bool]$Reverse = $false)
    
    if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
        Write-Log -Level Debug -Message "Handle-TabNavigation called, Reverse=$Reverse"
    }
    
    $next = Get-NextFocusableComponent -CurrentComponent $script:TuiState.FocusedComponent -Reverse $Reverse
    if ($next) {
        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            Write-Log -Level Debug -Message "Setting focus to component: Type=$($next.Type), Name=$($next.Name)"
        }
        Set-ComponentFocus -Component $next
    }
}

function global:New-Component {
    param(
        [string]$Type = "Base",
        [int]$X = 0,
        [int]$Y = 0,
        [int]$Width = 10,
        [int]$Height = 1,
        [hashtable]$Props = @{}
    )
    
    $component = @{
        Type = $Type
        X = $X
        Y = $Y
        Width = $Width
        Height = $Height
        Visible = $true
        Focused = $false
        Parent = $null
        Children = @()
        Props = $Props
        State = @{}
        
        # Lifecycle methods
        Init = { param($self) }
        Render = { param($self) }
        HandleInput = { param($self, $Key) return $false }
        OnFocus = { param($self) $self.Focused = $true }
        OnBlur = { param($self) $self.Focused = $false }
        Dispose = { param($self) }
    }
    
    # Merge with type-specific properties
    switch ($Type) {
        "TextInput" { $component = Merge-Hashtables $component (Get-TextInputComponent) }
        "Button" { $component = Merge-Hashtables $component (Get-ButtonComponent) }
        "List" { $component = Merge-Hashtables $component (Get-ListComponent) }
        "Table" { $component = Merge-Hashtables $component (Get-TableComponent) }
    }
    
    return $component
}

function Merge-Hashtables {
    param($Base, $Override)
    $result = $Base.Clone()
    foreach ($key in $Override.Keys) {
        $result[$key] = $Override[$key]
    }
    return $result
}

#endregion

#region Layout Management

function Initialize-LayoutEngines {
    $script:TuiState.Layouts = @{
        Grid = Get-GridLayout
        Stack = Get-StackLayout
        Dock = Get-DockLayout
    }
}

function global:Apply-Layout {
    param(
        [string]$LayoutType,
        [hashtable[]]$Components,
        [hashtable]$Options = @{}
    )
    
    if ($script:TuiState.Layouts.ContainsKey($LayoutType)) {
        $layout = $script:TuiState.Layouts[$LayoutType]
        Invoke-WithErrorHandling -Component "Layout.$LayoutType" -ScriptBlock {
            & $layout.Apply -Components $Components -Options $Options
        } -Context @{ LayoutType = $LayoutType; Options = $Options } -ErrorHandler {
            param($Exception)
            Write-Warning "Layout error: $($Exception.Message)"
        }
    }
}

function Get-GridLayout {
    return @{
        Apply = {
            param($Components, $Options)
            $cols = if ($Options.Columns) { $Options.Columns } else { 2 }
            $rows = [Math]::Ceiling($Components.Count / $cols)
            $cellWidth = [Math]::Floor($script:TuiState.BufferWidth / $cols)
            $cellHeight = [Math]::Floor($script:TuiState.BufferHeight / $rows)
            
            for ($i = 0; $i -lt $Components.Count; $i++) {
                $col = $i % $cols
                $row = [Math]::Floor($i / $cols)
                $Components[$i].X = $col * $cellWidth
                $Components[$i].Y = $row * $cellHeight
                $Components[$i].Width = $cellWidth - 1
                $Components[$i].Height = $cellHeight - 1
            }
        }
    }
}

function Get-StackLayout {
    return @{
        Apply = {
            param($Components, $Options)
            $orientation = if ($Options.Orientation) { $Options.Orientation } else { "Vertical" }
            $spacing = if ($null -ne $Options.Spacing) { $Options.Spacing } else { 1 }
            $x = if ($null -ne $Options.X) { $Options.X } else { 0 }
            $y = if ($null -ne $Options.Y) { $Options.Y } else { 0 }
            
            foreach ($component in $Components) {
                $component.X = $x
                $component.Y = $y
                
                if ($orientation -eq "Vertical") {
                    $y += $component.Height + $spacing
                } else {
                    $x += $component.Width + $spacing
                }
            }
        }
    }
}

function Get-DockLayout {
    return @{
        Apply = {
            param($Components, $Options)
            
            # Container bounds
            $containerX = if ($null -ne $Options.X) { $Options.X } else { 0 }
            $containerY = if ($null -ne $Options.Y) { $Options.Y } else { 0 }
            $containerWidth = if ($Options.Width) { $Options.Width } else { $script:TuiState.BufferWidth }
            $containerHeight = if ($Options.Height) { $Options.Height } else { $script:TuiState.BufferHeight }
            
            # Current available area
            $availableX = $containerX
            $availableY = $containerY
            $availableWidth = $containerWidth
            $availableHeight = $containerHeight
            
            # Process components by dock position
            $topComponents = $Components | Where-Object { $_.Props.Dock -eq "Top" }
            $bottomComponents = $Components | Where-Object { $_.Props.Dock -eq "Bottom" }
            $leftComponents = $Components | Where-Object { $_.Props.Dock -eq "Left" }
            $rightComponents = $Components | Where-Object { $_.Props.Dock -eq "Right" }
            $fillComponents = $Components | Where-Object { $_.Props.Dock -eq "Fill" -or -not $_.Props.Dock }
            
            # Dock top components
            foreach ($comp in $topComponents) {
                $comp.X = $availableX
                $comp.Y = $availableY
                $comp.Width = $availableWidth
                $availableY += $comp.Height
                $availableHeight -= $comp.Height
            }
            
            # Dock bottom components
            foreach ($comp in $bottomComponents) {
                $comp.X = $availableX
                $comp.Y = $availableY + $availableHeight - $comp.Height
                $comp.Width = $availableWidth
                $availableHeight -= $comp.Height
            }
            
            # Dock left components
            foreach ($comp in $leftComponents) {
                $comp.X = $availableX
                $comp.Y = $availableY
                $comp.Height = $availableHeight
                $availableX += $comp.Width
                $availableWidth -= $comp.Width
            }
            
            # Dock right components
            foreach ($comp in $rightComponents) {
                $comp.X = $availableX + $availableWidth - $comp.Width
                $comp.Y = $availableY
                $comp.Height = $availableHeight
                $availableWidth -= $comp.Width
            }
            
            # Fill remaining space
            foreach ($comp in $fillComponents) {
                $comp.X = $availableX
                $comp.Y = $availableY
                $comp.Width = $availableWidth
                $comp.Height = $availableHeight
            }
        }
    }
}

#endregion

#region Utility Functions

function global:Get-BorderChars { 
    param([string]$Style) 
    $styles = @{ 
        Single = @{ 
            TopLeft='┌'; TopRight='┐'; BottomLeft='└'; BottomRight='┘'
            Horizontal='─'; Vertical='│' 
        }
        Double = @{ 
            TopLeft='╔'; TopRight='╗'; BottomLeft='╚'; BottomRight='╝'
            Horizontal='═'; Vertical='║' 
        }
        Rounded = @{ 
            TopLeft='╭'; TopRight='╮'; BottomLeft='╰'; BottomRight='╯'
            Horizontal='─'; Vertical='│' 
        } 
    }
    if ($styles.ContainsKey($Style)) { 
        return $styles[$Style] 
    } else { 
        return $styles.Single 
    }
}

function Get-AnsiColorCode { 
    param([ConsoleColor]$Color, [bool]$IsBackground) 
    $map = @{ 
        Black=30; DarkBlue=34; DarkGreen=32; DarkCyan=36
        DarkRed=31; DarkMagenta=35; DarkYellow=33; Gray=37
        DarkGray=90; Blue=94; Green=92; Cyan=96
        Red=91; Magenta=95; Yellow=93; White=97 
    }
    $code = $map[$Color.ToString()]
    if ($IsBackground) { 
        return $code + 10 
    } else { 
        return $code 
    } 
}

function Get-ThemeColorFallback {
    param($ColorName, $Default = [ConsoleColor]::White)
    # This is a fallback function for when theme manager isn't available
    # The theme manager will override this with its own global Get-ThemeColor
    return $Default
}

# Only define global Get-ThemeColor if it doesn't already exist
if (-not (Get-Command -Name "Get-ThemeColor" -ErrorAction SilentlyContinue)) {
    function global:Get-ThemeColor {
        param($ColorName, $Default = [ConsoleColor]::White)
        return Get-ThemeColorFallback -ColorName $ColorName -Default $Default
    }
}

function global:Write-StatusLine { 
    param(
        [string]$Text, 
        [ConsoleColor]$ForegroundColor = 'White', 
        [ConsoleColor]$BackgroundColor = 'DarkBlue'
    ) 
    try { 
        $y = $script:TuiState.BufferHeight
        [Console]::SetCursorPosition(0, $y)
        [Console]::ForegroundColor = $ForegroundColor
        [Console]::BackgroundColor = $BackgroundColor
        [Console]::Write($Text.PadRight([Console]::WindowWidth))
        [Console]::ResetColor() 
    } catch {
        Write-Warning "Status line error: $_"
    } 
}

function global:Subscribe-TuiEvent {
    param($EventName, $Handler)
    if (Get-Command -Name "Subscribe-Event" -ErrorAction SilentlyContinue) {
        $handlerId = Subscribe-Event -EventName $EventName -Handler $Handler
        # Track for cleanup
        $script:TuiState.EventHandlers[$EventName] = $handlerId
        return $handlerId
    }
}

#endregion

#region Component Definitions

function Get-TextInputComponent {
    return @{
        # State
        Value = ""
        CursorPosition = 0
        MaxLength = 50
        
        # Methods
        Render = {
            param($self)
            try {
                $borderColor = if ($self.Focused) { 
                    Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
                } else { 
                    Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
                }
                
                # Draw input box
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor -BackgroundColor ([ConsoleColor]::Black)
                
                # Draw focus indicator
                if ($self.Focused) {
                    # Left bracket
                    Write-BufferString -X ($self.X - 1) -Y ($self.Y + [Math]::Floor($self.Height / 2)) `
                        -Text "[" -ForegroundColor ([ConsoleColor]::Yellow)
                    # Right bracket
                    Write-BufferString -X ($self.X + $self.Width) -Y ($self.Y + [Math]::Floor($self.Height / 2)) `
                        -Text "]" -ForegroundColor ([ConsoleColor]::Yellow)
                }
                
                # Draw text
                $displayText = $self.Value
                if ($displayText.Length > ($self.Width - 3)) {
                    $displayText = $displayText.Substring($displayText.Length - ($self.Width - 3))
                }
                Write-BufferString -X ($self.X + 1) -Y ($self.Y + 1) -Text $displayText
                
                # Draw cursor if focused
                if ($self.Focused -and $self.CursorPosition -lt ($self.Width - 3)) {
                    Write-BufferString -X ($self.X + 1 + $self.CursorPosition) -Y ($self.Y + 1) `
                        -Text "_" -ForegroundColor ([ConsoleColor]::Yellow)
                }
            } catch {
                Write-Warning "TextInput render error: $_"
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                switch ($Key.Key) {
                    ([ConsoleKey]::Backspace) {
                        if ($self.Value.Length -gt 0 -and $self.CursorPosition -gt 0) {
                            $self.Value = $self.Value.Remove($self.CursorPosition - 1, 1)
                            $self.CursorPosition--
                        }
                        return $true
                    }
                    ([ConsoleKey]::Delete) {
                        if ($self.CursorPosition -lt $self.Value.Length) {
                            $self.Value = $self.Value.Remove($self.CursorPosition, 1)
                        }
                        return $true
                    }
                    ([ConsoleKey]::LeftArrow) {
                        if ($self.CursorPosition -gt 0) {
                            $self.CursorPosition--
                        }
                        return $true
                    }
                    ([ConsoleKey]::RightArrow) {
                        if ($self.CursorPosition -lt $self.Value.Length) {
                            $self.CursorPosition++
                        }
                        return $true
                    }
                    ([ConsoleKey]::Home) {
                        $self.CursorPosition = 0
                        return $true
                    }
                    ([ConsoleKey]::End) {
                        $self.CursorPosition = $self.Value.Length
                        return $true
                    }
                    default {
                        if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar) -and 
                            $self.Value.Length -lt $self.MaxLength) {
                            $self.Value = $self.Value.Insert($self.CursorPosition, $Key.KeyChar)
                            $self.CursorPosition++
                            return $true
                        }
                    }
                }
            } catch {
                Write-Warning "TextInput input error: $_"
            }
            return $false
        }
    }
}

function Get-ButtonComponent {
    return @{
        # State
        Text = "Button"
        
        # Methods
        Render = {
            param($self)
            try {
                $bgColor = if ($self.Focused) { 
                    Get-ThemeColor "Accent" -Default ([ConsoleColor]::DarkCyan)
                } else { 
                    Get-ThemeColor "Primary" -Default ([ConsoleColor]::DarkGray)
                }
                
                $text = " $($self.Text) "
                if ($text.Length > $self.Width) {
                    $text = $text.Substring(0, $self.Width)
                }
                
                $x = $self.X + [Math]::Floor(($self.Width - $text.Length) / 2)
                Write-BufferString -X $x -Y $self.Y -Text $text `
                    -ForegroundColor ([ConsoleColor]::White) -BackgroundColor $bgColor
                
                # Draw focus indicator
                if ($self.Focused) {
                    # Left bracket
                    if ($x -gt 0) {
                        Write-BufferString -X ($x - 1) -Y $self.Y `
                            -Text "[" -ForegroundColor ([ConsoleColor]::Yellow)
                    }
                    # Right bracket
                    if (($x + $text.Length) -lt $script:TuiState.BufferWidth) {
                        Write-BufferString -X ($x + $text.Length) -Y $self.Y `
                            -Text "]" -ForegroundColor ([ConsoleColor]::Yellow)
                    }
                }
            } catch {
                Write-Warning "Button render error: $_"
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                if ($Key.Key -eq [ConsoleKey]::Enter -or $Key.Key -eq [ConsoleKey]::Spacebar) {
                    if ($self.OnClick) {
                        & $self.OnClick -self $self
                    }
                    return $true
                }
            } catch {
                Write-Warning "Button input error: $_"
            }
            return $false
        }
    }
}

function Get-TableComponent {
    return @{
        # State
        Data = @()
        Columns = @()
        SelectedRow = 0
        ScrollOffset = 0
        
        # Methods
        Render = {
            param($self)
            try {
                # Simplified table rendering
                $y = $self.Y
                
                # Header
                $headerText = ""
                foreach ($col in $self.Columns) {
                    $headerText += $col.Name.PadRight($col.Width)
                }
                Write-BufferString -X $self.X -Y $y -Text $headerText `
                    -ForegroundColor (Get-ThemeColor "Header" -Default ([ConsoleColor]::Cyan))
                $y++
                
                # Data rows
                $visibleRows = $self.Data | Select-Object -Skip $self.ScrollOffset -First ($self.Height - 1)
                $rowIndex = $self.ScrollOffset
                foreach ($row in $visibleRows) {
                    $rowText = ""
                    foreach ($col in $self.Columns) {
                        $value = if ($row.($col.Property)) { $row.($col.Property) } else { "" }
                        $rowText += $value.ToString().PadRight($col.Width)
                    }
                    
                    $fg = if ($rowIndex -eq $self.SelectedRow) {
                        Get-ThemeColor "Selection" -Default ([ConsoleColor]::Yellow)
                    } else {
                        Get-ThemeColor "Primary" -Default ([ConsoleColor]::White)
                    }
                    
                    Write-BufferString -X $self.X -Y $y -Text $rowText -ForegroundColor $fg
                    $y++
                    $rowIndex++
                }
            } catch {
                Write-Warning "Table render error: $_"
            }
        }
    }
}

#endregion

#region Word Wrap Helper
function global:Get-WordWrappedLines {
    param(
        [string]$Text,
        [int]$MaxWidth
    )
    
    if ([string]::IsNullOrEmpty($Text) -or $MaxWidth -le 0) { return @() }
    
    $lines = @()
    $words = $Text -split '\s+'
    $sb = New-Object System.Text.StringBuilder
    
    foreach ($word in $words) {
        if ($sb.Length -eq 0) {
            [void]$sb.Append($word)
        } elseif (($sb.Length + 1 + $word.Length) -le $MaxWidth) {
            [void]$sb.Append(' ')
            [void]$sb.Append($word)
        } else {
            $lines += $sb.ToString()
            [void]$sb.Clear()
            [void]$sb.Append($word)
        }
    }
    
    if ($sb.Length -gt 0) {
        $lines += $sb.ToString()
    }
    
    return $lines
}
#endregion

# Build export list dynamically
$exportFunctions = @(
    'Start-TuiLoop', 'Request-TuiRefresh', 'Push-Screen', 'Pop-Screen',
    'Write-BufferString', 'Write-BufferBox', 'Clear-BackBuffer',
    'Write-StatusLine', 'Get-BorderChars',
    'Register-Component', 'Set-ComponentFocus', 'Clear-ComponentFocus', 
    'Get-NextFocusableComponent', 'Handle-TabNavigation', 
    'New-Component', 'Apply-Layout',
    'Get-WordWrappedLines', 'Subscribe-TuiEvent',
    'Render-Frame', 'Initialize-TuiEngine'
)

# Only export Get-ThemeColor if we defined it
if (Get-Command -Name "Get-ThemeColor" -ErrorAction SilentlyContinue | Where-Object { $_.Source -eq "tui-engine-v2" }) {
    $exportFunctions += 'Get-ThemeColor'
}

Export-ModuleMember -Function $exportFunctions -Variable @('TuiState')
# Theme Manager Module
# Provides theming and color management for the TUI

$script:CurrentTheme = $null
$script:Themes = @{
    Modern = @{
        Name = "Modern"
        Colors = @{
            # Base colors
            Background = [ConsoleColor]::Black
            Foreground = [ConsoleColor]::White
            
            # UI elements
            Primary = [ConsoleColor]::White
            Secondary = [ConsoleColor]::Gray
            Accent = [ConsoleColor]::Cyan
            Success = [ConsoleColor]::Green
            Warning = [ConsoleColor]::Yellow
            Error = [ConsoleColor]::Red
            Info = [ConsoleColor]::Blue
            
            # Special elements
            Header = [ConsoleColor]::Cyan
            Border = [ConsoleColor]::DarkGray
            Selection = [ConsoleColor]::Yellow
            Highlight = [ConsoleColor]::Cyan
            Subtle = [ConsoleColor]::DarkGray
            
            # Syntax highlighting
            Keyword = [ConsoleColor]::Blue
            String = [ConsoleColor]::Green
            Number = [ConsoleColor]::Magenta
            Comment = [ConsoleColor]::DarkGray
        }
    }
    
    Dark = @{
        Name = "Dark"
        Colors = @{
            Background = [ConsoleColor]::Black
            Foreground = [ConsoleColor]::Gray
            Primary = [ConsoleColor]::Gray
            Secondary = [ConsoleColor]::DarkGray
            Accent = [ConsoleColor]::DarkCyan
            Success = [ConsoleColor]::DarkGreen
            Warning = [ConsoleColor]::DarkYellow
            Error = [ConsoleColor]::DarkRed
            Info = [ConsoleColor]::DarkBlue
            Header = [ConsoleColor]::DarkCyan
            Border = [ConsoleColor]::DarkGray
            Selection = [ConsoleColor]::Yellow
            Highlight = [ConsoleColor]::Cyan
            Subtle = [ConsoleColor]::DarkGray
            Keyword = [ConsoleColor]::DarkBlue
            String = [ConsoleColor]::DarkGreen
            Number = [ConsoleColor]::DarkMagenta
            Comment = [ConsoleColor]::DarkGray
        }
    }
    
    Light = @{
        Name = "Light"
        Colors = @{
            Background = [ConsoleColor]::White
            Foreground = [ConsoleColor]::Black
            Primary = [ConsoleColor]::Black
            Secondary = [ConsoleColor]::DarkGray
            Accent = [ConsoleColor]::Blue
            Success = [ConsoleColor]::Green
            Warning = [ConsoleColor]::DarkYellow
            Error = [ConsoleColor]::Red
            Info = [ConsoleColor]::Blue
            Header = [ConsoleColor]::Blue
            Border = [ConsoleColor]::Gray
            Selection = [ConsoleColor]::Cyan
            Highlight = [ConsoleColor]::Yellow
            Subtle = [ConsoleColor]::Gray
            Keyword = [ConsoleColor]::Blue
            String = [ConsoleColor]::Green
            Number = [ConsoleColor]::Magenta
            Comment = [ConsoleColor]::Gray
        }
    }
    
    Retro = @{
        Name = "Retro"
        Colors = @{
            Background = [ConsoleColor]::Black
            Foreground = [ConsoleColor]::Green
            Primary = [ConsoleColor]::Green
            Secondary = [ConsoleColor]::DarkGreen
            Accent = [ConsoleColor]::Yellow
            Success = [ConsoleColor]::Green
            Warning = [ConsoleColor]::Yellow
            Error = [ConsoleColor]::Red
            Info = [ConsoleColor]::Cyan
            Header = [ConsoleColor]::Yellow
            Border = [ConsoleColor]::DarkGreen
            Selection = [ConsoleColor]::Yellow
            Highlight = [ConsoleColor]::White
            Subtle = [ConsoleColor]::DarkGreen
            Keyword = [ConsoleColor]::Yellow
            String = [ConsoleColor]::Cyan
            Number = [ConsoleColor]::White
            Comment = [ConsoleColor]::DarkGreen
        }
    }
}

function global:Initialize-ThemeManager {
    <#
    .SYNOPSIS
    Initializes the theme manager
    #>
    
    # Set default theme
    Set-TuiTheme -ThemeName "Modern"
    
    Write-Verbose "Theme manager initialized"
}

function global:Set-TuiTheme {
    <#
    .SYNOPSIS
    Sets the current theme
    
    .PARAMETER ThemeName
    The name of the theme to set
    #>
    param(
        [Parameter(Mandatory = $true)]
        [ValidateSet("Modern", "Dark", "Light", "Retro")]
        [string]$ThemeName
    )
    
    # Defensive check: ensure $script:Themes is initialized
    if (-not $script:Themes) {
        Write-Warning "Theme manager not properly initialized, reinitializing themes hashtable"
        $script:Themes = @{
            Modern = @{ Name = "Modern"; Colors = @{ Background = [ConsoleColor]::Black; Foreground = [ConsoleColor]::White } }
        }
    }
    
    if ($script:Themes.ContainsKey($ThemeName)) {
        $script:CurrentTheme = $script:Themes[$ThemeName]
        
        # --- FIX ---
        # Defensively check if RawUI exists. In some environments (like the VS Code
        # Integrated Console), it can be $null and cause a crash.
        if ($Host.UI.RawUI) {
            # Apply console colors
            $Host.UI.RawUI.BackgroundColor = $script:CurrentTheme.Colors.Background
            $Host.UI.RawUI.ForegroundColor = $script:CurrentTheme.Colors.Foreground
        }
        
        Write-Verbose "Theme set to: $ThemeName"
        
        # Publish theme change event
        # Check if Publish-Event exists before calling it
        if (Get-Command -Name Publish-Event -ErrorAction SilentlyContinue) {
            Publish-Event -EventName "Theme.Changed" -Data @{ 
                ThemeName = $ThemeName
                Theme = $script:CurrentTheme 
            }
        }
    } else {
        Write-Warning "Theme not found: $ThemeName"
    }
}

function global:Get-ThemeColor {
    <#
    .SYNOPSIS
    Gets a color from the current theme
    
    .PARAMETER ColorName
    The name of the color to get
    
    .PARAMETER Default
    Default color if not found
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$ColorName,
        
        [Parameter()]
        [ConsoleColor]$Default = [ConsoleColor]::Gray
    )
    
    if ($script:CurrentTheme -and $script:CurrentTheme.Colors.ContainsKey($ColorName)) {
        return $script:CurrentTheme.Colors[$ColorName]
    } else {
        return $Default
    }
}

function global:Get-TuiTheme {
    <#
    .SYNOPSIS
    Gets the current theme
    #>
    
    return $script:CurrentTheme
}

function global:Get-AvailableThemes {
    <#
    .SYNOPSIS
    Gets all available themes
    #>
    
    return $script:Themes.Keys | Sort-Object
}

function global:New-TuiTheme {
    <#
    .SYNOPSIS
    Creates a new theme
    
    .PARAMETER Name
    The name of the new theme
    
    .PARAMETER BaseTheme
    The name of the theme to base this on
    
    .PARAMETER Colors
    Hashtable of color overrides
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$Name,
        
        [Parameter()]
        [string]$BaseTheme = "Modern",
        
        [Parameter()]
        [hashtable]$Colors = @{}
    )
    
    # Clone base theme
    $newTheme = @{
        Name = $Name
        Colors = @{}
    }
    
    if ($script:Themes.ContainsKey($BaseTheme)) {
        foreach ($colorKey in $script:Themes[$BaseTheme].Colors.Keys) {
            $newTheme.Colors[$colorKey] = $script:Themes[$BaseTheme].Colors[$colorKey]
        }
    }
    
    # Apply overrides
    foreach ($colorKey in $Colors.Keys) {
        $newTheme.Colors[$colorKey] = $Colors[$colorKey]
    }
    
    # Save theme
    $script:Themes[$Name] = $newTheme
    
    Write-Verbose "Created new theme: $Name"
    
    return $newTheme
}

function global:Export-TuiTheme {
    <#
    .SYNOPSIS
    Exports a theme to JSON
    
    .PARAMETER ThemeName
    The name of the theme to export
    
    .PARAMETER Path
    The path to save the theme
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$ThemeName,
        
        [Parameter(Mandatory = $true)]
        [string]$Path
    )
    
    if ($script:Themes.ContainsKey($ThemeName)) {
        $theme = $script:Themes[$ThemeName]
        
        # Convert ConsoleColor enums to strings for JSON
        $exportTheme = @{
            Name = $theme.Name
            Colors = @{}
        }
        
        foreach ($colorKey in $theme.Colors.Keys) {
            $exportTheme.Colors[$colorKey] = $theme.Colors[$colorKey].ToString()
        }
        
        $exportTheme | ConvertTo-Json -Depth 3 | Set-Content -Path $Path
        
        Write-Verbose "Exported theme to: $Path"
    } else {
        Write-Warning "Theme not found: $ThemeName"
    }
}

function global:Import-TuiTheme {
    <#
    .SYNOPSIS
    Imports a theme from JSON
    
    .PARAMETER Path
    The path to the theme file
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$Path
    )
    
    if (Test-Path $Path) {
        try {
            $importedTheme = Get-Content $Path -Raw | ConvertFrom-Json
            
            $theme = @{
                Name = $importedTheme.Name
                Colors = @{}
            }
            
            # Convert string color names back to ConsoleColor enums
            foreach ($colorProp in $importedTheme.Colors.PSObject.Properties) {
                $theme.Colors[$colorProp.Name] = [ConsoleColor]$colorProp.Value
            }
            
            $script:Themes[$theme.Name] = $theme
            
            Write-Verbose "Imported theme: $($theme.Name)"
            
            return $theme
        } catch {
            Write-Error "Failed to import theme: $_"
        }
    } else {
        Write-Warning "Theme file not found: $Path"
    }
}

# Export functions
Export-ModuleMember -Function @(
    'Initialize-ThemeManager',
    'Set-TuiTheme',
    'Get-ThemeColor',
    'Get-TuiTheme',
    'Get-AvailableThemes',
    'New-TuiTheme',
    'Export-TuiTheme',
    'Import-TuiTheme'
)
# Text Resources Module
# Simple text management without external dependencies

$script:TextResources = @{
    # Common UI strings
    Common = @{
        OK = "OK"
        Cancel = "Cancel"
        Save = "Save"
        Delete = "Delete"
        Edit = "Edit"
        Add = "Add"
        Remove = "Remove"
        Back = "Back"
        Next = "Next"
        Previous = "Previous"
        Close = "Close"
        Error = "Error"
        Warning = "Warning"
        Info = "Information"
        Success = "Success"
        Loading = "Loading..."
        PleaseWait = "Please wait..."
    }
    
    # Dashboard specific
    Dashboard = @{
        Title = "PMC Terminal Dashboard"
        QuickActions = "Quick Actions"
        ActiveTimers = "Active Timers"
        TodaysTasks = "Today's Tasks"
        Stats = "Statistics"
        NoTimersActive = "No active timers"
        NoTasksToday = "No tasks for today"
    }
    
    # Task screen specific
    Tasks = @{
        Title = "Task Management"
        AddTask = "Add Task"
        EditTask = "Edit Task"
        DeleteConfirm = "Are you sure you want to delete this task?"
        FilterAll = "All"
        FilterActive = "Active"
        FilterCompleted = "Completed"
        SortByPriority = "Priority"
        SortByDueDate = "Due Date"
        SortByCreated = "Created"
    }
    
    # Form labels
    Forms = @{
        Title = "Title"
        Description = "Description"
        Category = "Category"
        Priority = "Priority"
        DueDate = "Due Date"
        Status = "Status"
        Project = "Project"
        Hours = "Hours"
        Date = "Date"
    }
    
    # Validation messages
    Validation = @{
        Required = "{0} is required"
        MinLength = "{0} must be at least {1} characters"
        MaxLength = "{0} cannot exceed {1} characters"
        InvalidDate = "Invalid date format"
        InvalidNumber = "Must be a valid number"
    }
    
    # Status messages
    Status = @{
        Saved = "Changes saved successfully"
        Deleted = "Item deleted successfully"
        Updated = "Item updated successfully"
        Created = "Item created successfully"
        Error = "An error occurred: {0}"
    }
}

function global:Get-Text {
    <#
    .SYNOPSIS
    Retrieves a text resource by key path
    
    .PARAMETER Key
    Dot-separated path to the text resource (e.g., "Common.OK")
    
    .PARAMETER Format
    Optional format arguments for string interpolation
    
    .EXAMPLE
    Get-Text "Common.OK"
    Get-Text "Validation.Required" -Format "Username"
    Get-Text "Status.Error" -Format $_.Exception.Message
    #>
    param(
        [Parameter(Mandatory=$true)]
        [string]$Key,
        
        [Parameter(ValueFromRemainingArguments=$true)]
        [object[]]$Format
    )
    Invoke-WithErrorHandling -Component "TextResources.GetText" -ScriptBlock {
        # Navigate the nested hashtable
        $parts = $Key -split '\.'
        $current = $script:TextResources
        
        foreach ($part in $parts) {
            if ($current -is [hashtable] -and $current.ContainsKey($part)) {
                $current = $current[$part]
            } else {
                Write-Warning "Text resource not found: '$Key'"
                return $Key  # Return the key as fallback
            }
        }
        
        # Format the string if arguments provided
        if ($Format -and $Format.Count -gt 0) {
            try {
                return $current -f $Format
            } catch {
                Write-Warning "Failed to format text resource '$Key': $_"
                return $current
            }
        }
        
        return $current
    } -Context @{ Key = $Key; FormatArgs = $Format } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to retrieve text resource for key '$($Exception.Context.Key)': $($Exception.Message)" -Data $Exception.Context
        return $Key # Return key as fallback on error
    }
}

function global:Set-TextResource {
    <#
    .SYNOPSIS
    Sets or updates a text resource
    
    .PARAMETER Key
    Dot-separated path to the text resource
    
    .PARAMETER Value
    The text value to set
    
    .EXAMPLE
    Set-TextResource "Custom.WelcomeMessage" "Welcome to my app!"
    #>
    param(
        [Parameter(Mandatory=$true)]
        [string]$Key,
        
        [Parameter(Mandatory=$true)]
        [string]$Value
    )
    Invoke-WithErrorHandling -Component "TextResources.SetTextResource" -ScriptBlock {
        $parts = $Key -split '\.'
        $current = $script:TextResources
        
        # Navigate to the parent
        for ($i = 0; $i -lt $parts.Count - 1; $i++) {
            $part = $parts[$i]
            if (-not $current.ContainsKey($part)) {
                $current[$part] = @{}
            }
            $current = $current[$part]
        }
        
        # Set the value
        $current[$parts[-1]] = $Value
    } -Context @{ Key = $Key; Value = $Value } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to set text resource for key '$($Exception.Context.Key)': $($Exception.Message)" -Data $Exception.Context
    }
}

function global:Get-TextResources {
    <#
    .SYNOPSIS
    Gets all text resources (useful for export/import)
    #>
    Invoke-WithErrorHandling -Component "TextResources.GetTextResources" -ScriptBlock {
        return $script:TextResources.Clone()
    } -Context @{} -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to get all text resources: $($Exception.Message)" -Data $Exception.Context
        return @{} # Return empty hashtable on error
    }
}

function global:Import-TextResources {
    <#
    .SYNOPSIS
    Imports text resources from a file
    
    .PARAMETER Path
    Path to JSON file containing text resources
    #>
    param(
        [Parameter(Mandatory=$true)]
        [string]$Path
    )
    Invoke-WithErrorHandling -Component "TextResources.ImportTextResources" -ScriptBlock {
        if (Test-Path $Path) {
            try {
                $imported = Get-Content $Path -Raw | ConvertFrom-Json -AsHashtable
                $script:TextResources = $imported
                Write-Host "Text resources imported successfully"
            } catch {
                Write-Log -Level Error -Message "Failed to import text resources from '$Path': $_" -Data @{ FilePath = $Path; Exception = $_ }
            }
        } else {
            Write-Log -Level Error -Message "File not found: $Path" -Data @{ FilePath = $Path }
        }
    } -Context @{ FilePath = $Path } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to import text resources from '$($Exception.Context.FilePath)': $($Exception.Message)" -Data $Exception.Context
    }
}

function global:Export-TextResources {
    <#
    .SYNOPSIS
    Exports text resources to a file
    
    .PARAMETER Path
    Path to save the JSON file
    #>
    param(
        [Parameter(Mandatory=$true)]
        [string]$Path
    )
    Invoke-WithErrorHandling -Component "TextResources.ExportTextResources" -ScriptBlock {
        try {
            $script:TextResources | ConvertTo-Json -Depth 10 | Set-Content $Path
            Write-Host "Text resources exported successfully"
        } catch {
            Write-Log -Level Error -Message "Failed to export text resources to '$Path': $_" -Data @{ FilePath = $Path; Exception = $_ }
        }
    } -Context @{ FilePath = $Path } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to export text resources to '$($Exception.Context.FilePath)': $($Exception.Message)" -Data $Exception.Context
    }
}

# Export functions
Export-ModuleMember -Function @(
    'Get-Text',
    'Set-TextResource',
    'Get-TextResources',
    'Import-TextResources',
    'Export-TextResources'
)
# State Manager Module
# Simple, practical reactive state management for PowerShell TUI

function global:New-TuiState {
    <#
    .SYNOPSIS
    Creates a reactive state object for managing application or screen state
    
    .DESCRIPTION
    This creates a PowerShell object that tracks state changes and notifies
    subscribers when values change. It's designed to be simple and practical.
    
    .PARAMETER InitialState
    Hashtable of initial state values
    
    .PARAMETER Actions
    Hashtable of named actions (methods) that can mutate the state
    
    .EXAMPLE
    $state = New-TuiState -InitialState @{ count = 0; name = "Test" } -Actions @{
        Increment = { $this.count++ }
        SetName = { param($name) $this.name = $name }
    }
    $state.Subscribe('count', { param($new, $old) Write-Host "Count changed from $old to $new" })
    $state.Increment()
    #>
    param(
        [hashtable]$InitialState = @{},
        [hashtable]$Actions = @{}
    )
    
    # Create the state object
    $stateObject = [PSCustomObject]@{
        # Private properties
        _data = $InitialState.Clone()
        _subscribers = @{}
        _suspendNotifications = $false
    }
    
    # Add dynamic properties for each state key
    foreach ($key in $InitialState.Keys) {
        $stateObject | Add-Member -MemberType ScriptProperty -Name $key -Value {
            # Getter
            $this._data[$key]
        }.GetNewClosure() -SecondValue {
            # Setter
            param($value)
            $this.SetValue($key, $value)
        }.GetNewClosure()
    }
    
    # Core methods
    $stateObject | Add-Member -MemberType ScriptMethod -Name 'SetValue' -Value {
        param([string]$key, $value)
        
        $oldValue = $this._data[$key]
        
        # Skip if value hasn't changed
        if ($oldValue -eq $value) { return }
        
        # Update the value
        $this._data[$key] = $value
        
        # Notify subscribers unless suspended
        if (-not $this._suspendNotifications) {
            $this._NotifySubscribers($key, $value, $oldValue)
        }
    }
    
    $stateObject | Add-Member -MemberType ScriptMethod -Name 'GetValue' -Value {
        param([string]$key)
        return $this._data[$key]
    }
    
    $stateObject | Add-Member -MemberType ScriptMethod -Name 'Subscribe' -Value {
        param(
            [string]$key,
            [scriptblock]$handler
        )
        
        if (-not $this._subscribers.ContainsKey($key)) {
            $this._subscribers[$key] = @()
        }
        
        # Generate unique ID for this subscription
        $subscriptionId = [Guid]::NewGuid().ToString()
        
        $this._subscribers[$key] += @{
            Id = $subscriptionId
            Handler = $handler
        }
        
        # Call handler immediately with current value
        try {
            & $handler $this._data[$key] $null
        } catch {
            Write-Warning "State subscription handler error: $_"
        }
        
        # Return subscription ID for unsubscribing
        return $subscriptionId
    }
    
    $stateObject | Add-Member -MemberType ScriptMethod -Name 'Unsubscribe' -Value {
        param([string]$subscriptionId)
        
        foreach ($key in $this._subscribers.Keys) {
            $this._subscribers[$key] = @($this._subscribers[$key] | Where-Object { $_.Id -ne $subscriptionId })
        }
    }
    
    $stateObject | Add-Member -MemberType ScriptMethod -Name 'Update' -Value {
        param([hashtable]$updates)
        
        # Suspend notifications during bulk update
        $this._suspendNotifications = $true
        
        try {
            foreach ($key in $updates.Keys) {
                $this.SetValue($key, $updates[$key])
            }
        } finally {
            $this._suspendNotifications = $false
        }
        
        # Notify all affected keys
        foreach ($key in $updates.Keys) {
            if ($this._data[$key] -ne $this._data[$key]) { # Check if changed
                $this._NotifySubscribers($key, $this._data[$key], $null)
            }
        }
    }
    
    $stateObject | Add-Member -MemberType ScriptMethod -Name 'GetState' -Value {
        # Return a copy of the current state
        return $this._data.Clone()
    }
    
    $stateObject | Add-Member -MemberType ScriptMethod -Name '_NotifySubscribers' -Value {
        param($key, $newValue, $oldValue)
        
        # Notify specific key subscribers
        if ($this._subscribers.ContainsKey($key)) {
            foreach ($subscription in $this._subscribers[$key]) {
                try {
                    & $subscription.Handler $newValue $oldValue
                } catch {
                    Write-Warning "State notification error for key '$key': $_"
                }
            }
        }
        
        # Notify wildcard subscribers
        if ($this._subscribers.ContainsKey('*')) {
            foreach ($subscription in $this._subscribers['*']) {
                try {
                    & $subscription.Handler @{
                        Key = $key
                        NewValue = $newValue
                        OldValue = $oldValue
                    }
                } catch {
                    Write-Warning "Wildcard state notification error: $_"
                }
            }
        }
    }
    
    # Add user-defined actions as methods
    foreach ($actionName in $Actions.Keys) {
        $stateObject | Add-Member -MemberType ScriptMethod -Name $actionName -Value $Actions[$actionName]
    }
    
    return $stateObject
}

function global:New-ComputedState {
    <#
    .SYNOPSIS
    Creates a computed/derived state value that updates automatically
    
    .PARAMETER Source
    The source state object to derive from
    
    .PARAMETER Keys
    Array of state keys to watch for changes
    
    .PARAMETER Compute
    Scriptblock that computes the derived value
    
    .EXAMPLE
    $filtered = New-ComputedState -Source $state -Keys @('tasks', 'filter') -Compute {
        param($state)
        $state.tasks | Where-Object { $_.Status -eq $state.filter }
    }
    #>
    param(
        [PSCustomObject]$Source,
        [string[]]$Keys,
        [scriptblock]$Compute
    )
    
    $computed = [PSCustomObject]@{
        _source = $Source
        _value = $null
        _compute = $Compute
        _subscriptions = @()
    }
    
    # Add Value property
    $computed | Add-Member -MemberType ScriptProperty -Name 'Value' -Value {
        $this._value
    }
    
    # Recompute method
    $computed | Add-Member -MemberType ScriptMethod -Name '_Recompute' -Value {
        try {
            $this._value = & $this._compute $this._source
        } catch {
            Write-Warning "Computed state error: $_"
        }
    }
    
    # Initial computation
    $computed._Recompute()
    
    # Subscribe to changes
    foreach ($key in $Keys) {
        $subId = $Source.Subscribe($key, {
            $computed._Recompute()
        })
        $computed._subscriptions += $subId
    }
    
    # Cleanup method
    $computed | Add-Member -MemberType ScriptMethod -Name 'Dispose' -Value {
        foreach ($subId in $this._subscriptions) {
            $this._source.Unsubscribe($subId)
        }
    }
    
    return $computed
}

# Export functions
Export-ModuleMember -Function @('New-TuiState', 'New-ComputedState')
# Enhanced Granular Logger Module for PMC Terminal
# Provides EXTREMELY detailed logging functionality to track down all issues

$script:LogPath = $null
$script:LogLevel = "Info"  # Reduced for performance
$script:LogQueue = @()
$script:MaxLogSize = 5MB  # Increased for detailed logging
$script:LogInitialized = $false
$script:CallDepth = 0
$script:TraceAllCalls = $false

function global:Initialize-Logger {
    param(
        [string]$LogDirectory = (Join-Path $env:TEMP "PMCTerminal"),
        [string]$LogFileName = "pmc_terminal_{0:yyyy-MM-dd}.log" -f (Get-Date),
        [string]$Level = "Debug"
    )
    
    try {
        # Create log directory if it doesn't exist
        if (-not (Test-Path $LogDirectory)) {
            New-Item -ItemType Directory -Path $LogDirectory -Force | Out-Null
        }
        
        $script:LogPath = Join-Path $LogDirectory $LogFileName
        $script:LogLevel = $Level
        $script:LogInitialized = $true
        
        # Write initialization message with full system context
        Write-Log -Level Info -Message "Logger initialized" -Data @{
            LogPath = $script:LogPath
            PowerShellVersion = $PSVersionTable.PSVersion.ToString()
            OS = "$($PSVersionTable.OS)"
            ProcessId = $PID
            InitializedAt = Get-Date -Format "yyyy-MM-dd HH:mm:ss.fff"
        }
        
    } catch {
        Write-Warning "Failed to initialize logger: $_"
        $script:LogInitialized = $false
    }
}

function global:Write-Log {
    param(
        [ValidateSet("Debug", "Verbose", "Info", "Warning", "Error", "Trace")]
        [string]$Level = "Info",
        [Parameter(Mandatory)]
        [string]$Message,
        [object]$Data = $null,
        [switch]$Force  # Force logging even if level is below threshold
    )
    
    # Skip if logger not initialized, unless this is Force logging
    if (-not $script:LogInitialized -and -not $Force) { return }
    
    $levelPriority = @{
        Debug = 0
        Trace = 0
        Verbose = 1
        Info = 2
        Warning = 3
        Error = 4
    }
    
    if (-not $Force -and $levelPriority[$Level] -lt $levelPriority[$script:LogLevel]) { return }
    
    try {
        # Get call stack information for precise location tracking
        $callStack = Get-PSCallStack
        $caller = if ($callStack.Count -gt 1) { $callStack[1] } else { $callStack[0] }
        
        $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss.fff"
        $threadId = [System.Threading.Thread]::CurrentThread.ManagedThreadId
        
        # Build comprehensive context
        $logContext = @{
            Timestamp = $timestamp
            Level = $Level
            ThreadId = $threadId
            CallDepth = $script:CallDepth
            Message = $Message
            Caller = @{
                Command = $caller.Command
                Location = $caller.Location
                ScriptName = $caller.ScriptName
                LineNumber = $caller.ScriptLineNumber
                Arguments = $caller.Arguments
            }
            FullCallStack = $callStack | ForEach-Object {
                @{
                    Command = $_.Command
                    Location = $_.Location
                    ScriptName = $_.ScriptName
                    LineNumber = $_.ScriptLineNumber
                }
            }
        }
        
        # Add user data if provided
        if ($Data) {
            $logContext.UserData = if ($Data -is [Exception]) {
                @{
                    Type = "Exception"
                    Message = $Data.Message
                    StackTrace = $Data.StackTrace
                    InnerException = if ($Data.InnerException) { $Data.InnerException.Message } else { $null }
                }
            } else {
                try {
                    # Try to serialize safely
                    $serialized = ConvertTo-SerializableObject -Object $Data
                    $serialized
                } catch {
                    @{
                        Type = "SerializationFailed"
                        StringRepresentation = $Data.ToString()
                        Error = $_.Exception.Message
                    }
                }
            }
        }
        
        # Create formatted log entry
        $indent = "  " * $script:CallDepth
        $callerInfo = if ($caller.ScriptName) {
            "$([System.IO.Path]::GetFileName($caller.ScriptName)):$($caller.ScriptLineNumber)"
        } else {
            $caller.Command
        }
        
        $logEntry = "$timestamp[$Level   ]$indent[$callerInfo] $Message"
        
        if ($Data) {
            $dataStr = if ($Data -is [Exception]) {
                "`n${indent}  Exception: $($Data.Message)`n${indent}  StackTrace: $($Data.StackTrace)"
            } else {
                try {
                    $json = ConvertTo-SerializableObject -Object $Data | ConvertTo-Json -Compress -Depth 3 -WarningAction SilentlyContinue -ErrorAction SilentlyContinue
                    "`n${indent}  Data: $json"
                } catch {
                    "`n${indent}  Data: $($Data.ToString())"
                }
            }
            $logEntry += $dataStr
        }
        
        # Add to in-memory queue (for debug screen)
        $script:LogQueue += $logContext
        
        # Keep only last 2000 entries in memory for detailed debugging
        if ($script:LogQueue.Count -gt 2000) {
            $script:LogQueue = $script:LogQueue[-2000..-1]
        }
        
        # Write to file with enhanced error handling
        if ($script:LogPath) {
            try {
                # Ensure directory exists
                $logDir = Split-Path $script:LogPath -Parent
                if (-not (Test-Path $logDir)) {
                    New-Item -ItemType Directory -Path $logDir -Force | Out-Null
                }
                
                # Check file size and rotate if needed
                if ((Test-Path $script:LogPath) -and (Get-Item $script:LogPath).Length -gt $script:MaxLogSize) {
                    $archivePath = $script:LogPath -replace '\.log$', "_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
                    Move-Item $script:LogPath $archivePath -Force
                }
                
                # Force flush to ensure content is written
                Add-Content -Path $script:LogPath -Value $logEntry -Encoding UTF8 -Force
                
            } catch {
                # If file writing fails, at least output to console
                Write-Host "LOG WRITE FAILED: $logEntry" -ForegroundColor Yellow
                Write-Host "Error: $_" -ForegroundColor Red
            }
        }
        
        # Also output to console for immediate feedback if Error level
        if ($Level -eq "Error" -or $Level -eq "Warning") {
            $color = if ($Level -eq "Error") { "Red" } else { "Yellow" }
            Write-Host $logEntry -ForegroundColor $color
        }
        
    } catch {
        # Even the logger's error handling should be logged
        try {
            $errorEntry = "$(Get-Date -Format "yyyy-MM-dd HH:mm:ss.fff")[LOGGER ERROR] Failed to log message '$Message': $_"
            if ($script:LogPath) {
                Add-Content -Path $script:LogPath -Value $errorEntry -Encoding UTF8
            }
            Write-Host $errorEntry -ForegroundColor Red
        } catch {
            # Ultimate fallback - just write to host
            Write-Host "CRITICAL: Logger completely failed: $_" -ForegroundColor Red
        }
    }
}

function global:Trace-FunctionEntry {
    param(
        [string]$FunctionName,
        [object]$Parameters = $null
    )
    
    $script:CallDepth++
    Write-Log -Level Trace -Message "ENTER: $FunctionName" -Data @{
        Parameters = $Parameters
        CallDepth = $script:CallDepth
        Action = "FunctionEntry"
    }
}

function global:Trace-FunctionExit {
    param(
        [string]$FunctionName,
        [object]$ReturnValue = $null,
        [switch]$WithError
    )
    
    Write-Log -Level Trace -Message "EXIT: $FunctionName" -Data @{
        ReturnValue = $ReturnValue
        CallDepth = $script:CallDepth
        Action = if ($WithError) { "FunctionExitWithError" } else { "FunctionExit" }
        HasError = $WithError.IsPresent
    }
    $script:CallDepth--
    if ($script:CallDepth -lt 0) { $script:CallDepth = 0 }
}

function global:Trace-Step {
    param(
        [string]$StepName,
        [object]$StepData = $null,
        [string]$Module = $null
    )
    
    $caller = (Get-PSCallStack)[1]
    $moduleInfo = if ($Module) { $Module } else { 
        if ($caller.ScriptName) { [System.IO.Path]::GetFileNameWithoutExtension($caller.ScriptName) } else { "Unknown" }
    }
    
    Write-Log -Level Debug -Message "STEP: $StepName" -Data @{
        StepData = $StepData
        Module = $moduleInfo
        Action = "Step"
        Caller = @{
            Command = $caller.Command
            Location = $caller.Location
            LineNumber = $caller.ScriptLineNumber
        }
    }
}

function global:Trace-StateChange {
    param(
        [string]$StateType,
        [object]$OldValue = $null,
        [object]$NewValue = $null,
        [string]$PropertyPath = $null
    )
    
    Write-Log -Level Debug -Message "STATE: $StateType changed" -Data @{
        StateType = $StateType
        PropertyPath = $PropertyPath
        OldValue = ConvertTo-SerializableObject -Object $OldValue
        NewValue = ConvertTo-SerializableObject -Object $NewValue
        Action = "StateChange"
    }
}

function global:Trace-ComponentLifecycle {
    param(
        [string]$ComponentType,
        [string]$ComponentId,
        [string]$Phase,  # Create, Initialize, Render, Update, Destroy
        [object]$ComponentData = $null
    )
    
    Write-Log -Level Debug -Message "COMPONENT: $ComponentType [$ComponentId] $Phase" -Data @{
        ComponentType = $ComponentType
        ComponentId = $ComponentId
        Phase = $Phase
        ComponentData = ConvertTo-SerializableObject -Object $ComponentData
        Action = "ComponentLifecycle"
    }
}

function global:Trace-ServiceCall {
    param(
        [string]$ServiceName,
        [string]$MethodName,
        [object]$Parameters = $null,
        [object]$Result = $null,
        [switch]$IsError
    )
    
    $action = if ($IsError) { "ServiceCallError" } else { "ServiceCall" }
    Write-Log -Level Debug -Message "SERVICE: $ServiceName.$MethodName" -Data @{
        ServiceName = $ServiceName
        MethodName = $MethodName
        Parameters = ConvertTo-SerializableObject -Object $Parameters
        Result = ConvertTo-SerializableObject -Object $Result
        Action = $action
        IsError = $IsError.IsPresent
    }
}

function ConvertTo-SerializableObject {
    param([object]$Object)
    
    if ($null -eq $Object) { return $null }
    
    # Handle different object types safely
    switch ($Object.GetType().Name) {
        "Hashtable" {
            $result = @{}
            foreach ($key in $Object.Keys) {
                try {
                    $result[$key] = ConvertTo-SerializableObject -Object $Object[$key]
                } catch {
                    $result[$key] = "<SerializationError: $($_.Exception.Message)>"
                }
            }
            return $result
        }
        "PSCustomObject" {
            $result = @{}
            foreach ($prop in $Object.PSObject.Properties) {
                try {
                    $result[$prop.Name] = ConvertTo-SerializableObject -Object $prop.Value
                } catch {
                    $result[$prop.Name] = "<SerializationError: $($_.Exception.Message)>"
                }
            }
            return $result
        }
        "Object[]" {
            $result = @()
            for ($i = 0; $i -lt [Math]::Min($Object.Count, 10); $i++) {  # Limit array size for performance
                try {
                    $result += ConvertTo-SerializableObject -Object $Object[$i]
                } catch {
                    $result += "<SerializationError: $($_.Exception.Message)>"
                }
            }
            if ($Object.Count -gt 10) {
                $result += "<... $($Object.Count - 10) more items>"
            }
            return $result
        }
        default {
            try {
                # For simple types, return as-is or convert to string
                if ($Object -is [string] -or $Object -is [int] -or $Object -is [bool] -or $Object -is [double]) {
                    return $Object
                } else {
                    return $Object.ToString()
                }
            } catch {
                return "<ToString failed: $($_.Exception.Message)>"
            }
        }
    }
}

function global:Get-LogEntries {
    param(
        [int]$Count = 100,
        [string]$Level = $null,
        [string]$Module = $null,
        [string]$Action = $null
    )
    
    try {
        $entries = $script:LogQueue
        
        if ($Level) {
            $entries = $entries | Where-Object { $_.Level -eq $Level }
        }
        
        if ($Module) {
            $entries = $entries | Where-Object { 
                $_.Caller.ScriptName -and ([System.IO.Path]::GetFileNameWithoutExtension($_.Caller.ScriptName) -like "*$Module*")
            }
        }
        
        if ($Action) {
            $entries = $entries | Where-Object { $_.UserData.Action -eq $Action }
        }
        
        return $entries | Select-Object -Last $Count
    } catch {
        Write-Warning "Error getting log entries: $_"
        return @()
    }
}

function global:Get-CallTrace {
    param([int]$Depth = 10)
    
    try {
        $callStack = Get-PSCallStack
        $trace = @()
        
        for ($i = 0; $i -lt [Math]::Min($callStack.Count, $Depth); $i++) {
            $call = $callStack[$i]
            $trace += @{
                Level = $i
                Command = $call.Command
                Location = $call.Location
                ScriptName = $call.ScriptName
                LineNumber = $call.ScriptLineNumber
                Arguments = $call.Arguments
            }
        }
        
        return $trace
    } catch {
        Write-Warning "Error getting call trace: $_"
        return @()
    }
}

function global:Clear-LogQueue {
    try {
        $script:LogQueue = @()
        Write-Log -Level Info -Message "Log queue cleared"
    } catch {
        Write-Warning "Error clearing log queue: $_"
    }
}

function global:Set-LogLevel {
    param(
        [ValidateSet("Debug", "Verbose", "Info", "Warning", "Error", "Trace")]
        [string]$Level
    )
    
    try {
        $oldLevel = $script:LogLevel
        $script:LogLevel = $Level
        Write-Log -Level Info -Message "Log level changed from $oldLevel to $Level"
    } catch {
        Write-Warning "Error setting log level to '$Level': $_"
    }
}

function global:Enable-CallTracing {
    $script:TraceAllCalls = $true
    Write-Log -Level Info -Message "Call tracing enabled"
}

function global:Disable-CallTracing {
    $script:TraceAllCalls = $false
    Write-Log -Level Info -Message "Call tracing disabled"
}

function global:Get-LogPath {
    return $script:LogPath
}

function global:Get-LogStatistics {
    try {
        $stats = @{
            TotalEntries = $script:LogQueue.Count
            LogPath = $script:LogPath
            LogLevel = $script:LogLevel
            CallTracingEnabled = $script:TraceAllCalls
            LogFileSize = if ($script:LogPath -and (Test-Path $script:LogPath)) { 
                (Get-Item $script:LogPath).Length 
            } else { 0 }
            EntriesByLevel = @{}
            EntriesByModule = @{}
            EntriesByAction = @{}
        }
        
        # Count entries by level
        foreach ($entry in $script:LogQueue) {
            $level = $entry.Level
            if (-not $stats.EntriesByLevel.ContainsKey($level)) {
                $stats.EntriesByLevel[$level] = 0
            }
            $stats.EntriesByLevel[$level]++
            
            # Count by module
            if ($entry.Caller.ScriptName) {
                $module = [System.IO.Path]::GetFileNameWithoutExtension($entry.Caller.ScriptName)
                if (-not $stats.EntriesByModule.ContainsKey($module)) {
                    $stats.EntriesByModule[$module] = 0
                }
                $stats.EntriesByModule[$module]++
            }
            
            # Count by action
            if ($entry.UserData -and $entry.UserData.Action) {
                $action = $entry.UserData.Action
                if (-not $stats.EntriesByAction.ContainsKey($action)) {
                    $stats.EntriesByAction[$action] = 0
                }
                $stats.EntriesByAction[$action]++
            }
        }
        
        return $stats
    } catch {
        Write-Warning "Error getting log statistics: $_"
        return @{}
    }
}

Export-ModuleMember -Function @(
    'Initialize-Logger',
    'Write-Log',
    'Trace-FunctionEntry',
    'Trace-FunctionExit', 
    'Trace-Step',
    'Trace-StateChange',
    'Trace-ComponentLifecycle',
    'Trace-ServiceCall',
    'Get-LogEntries',
    'Get-CallTrace',
    'Clear-LogQueue',
    'Set-LogLevel',
    'Enable-CallTracing',
    'Disable-CallTracing',
    'Get-LogPath',
    'Get-LogStatistics'
)
# Event System Module
# Provides pub/sub event functionality for decoupled communication

$script:EventHandlers = @{}
$script:EventHistory = @()
$script:MaxEventHistory = 100

function global:Initialize-EventSystem {
    <#
    .SYNOPSIS
    Initializes the event system for the application
    #>
    Invoke-WithErrorHandling -Component "EventSystem.Initialize" -ScriptBlock {
        $script:EventHandlers = @{}
        $script:EventHistory = @()
        Write-Verbose "Event system initialized"
    } -Context @{} -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to initialize Event System: $($Exception.Message)" -Data $Exception.Context
    }
}

function global:Publish-Event {
    <#
    .SYNOPSIS
    Publishes an event to all registered handlers
    
    .PARAMETER EventName
    The name of the event to publish
    
    .PARAMETER Data
    Optional data to pass to event handlers
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$EventName,
        
        [Parameter()]
        [hashtable]$Data = @{}
    )
    Invoke-WithErrorHandling -Component "EventSystem.PublishEvent" -ScriptBlock {
        # Record event in history
        $eventRecord = @{
            EventName = $EventName
            Data = $Data
            Timestamp = Get-Date
        }
        
        $script:EventHistory += $eventRecord
        if ($script:EventHistory.Count -gt $script:MaxEventHistory) {
            $script:EventHistory = $script:EventHistory[-$script:MaxEventHistory..-1]
        }
        
        # Execute handlers
        if ($script:EventHandlers.ContainsKey($EventName)) {
            foreach ($handler in $script:EventHandlers[$EventName]) {
                try { # Internal try/catch for handler execution
                    $eventData = @{
                        EventName = $EventName
                        Data = $Data
                        Timestamp = $eventRecord.Timestamp
                    }
                    
                    & $handler.ScriptBlock -EventData $eventData
                } catch {
                    Write-Log -Level Warning -Message "Error in event handler for '$EventName' (Handler ID: $($handler.HandlerId)): $_" -Data @{ EventName = $EventName; HandlerId = $handler.HandlerId; Exception = $_ }
                }
            }
        }
        
        Write-Verbose "Published event: $EventName"
    } -Context @{ EventName = $EventName; EventData = $Data } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to publish event '$($Exception.Context.EventName)': $($Exception.Message)" -Data $Exception.Context
    }
}

function global:Subscribe-Event {
    <#
    .SYNOPSIS
    Subscribes to an event with a handler
    
    .PARAMETER EventName
    The name of the event to subscribe to
    
    .PARAMETER Handler
    The script block to execute when the event is published
    
    .PARAMETER HandlerId
    Optional unique identifier for the handler
    
    .PARAMETER Source
    Optional source component ID for cleanup tracking
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$EventName,
        
        [Parameter(Mandatory = $true)]
        [scriptblock]$Handler,
        
        [Parameter()]
        [string]$HandlerId = [Guid]::NewGuid().ToString(),
        
        [Parameter()]
        [string]$Source = $null
    )
    Invoke-WithErrorHandling -Component "EventSystem.SubscribeEvent" -ScriptBlock {
        if (-not $script:EventHandlers.ContainsKey($EventName)) {
            $script:EventHandlers[$EventName] = @()
        }
        
        $handlerInfo = @{
            HandlerId = $HandlerId
            ScriptBlock = $Handler
            SubscribedAt = Get-Date
            Source = $Source
        }
        
        $script:EventHandlers[$EventName] += $handlerInfo
        
        Write-Verbose "Subscribed to event: $EventName (Handler: $HandlerId)"
        
        # Only return handler ID, don't print it
        return $HandlerId
    } -Context @{ EventName = $EventName; HandlerId = $HandlerId; Source = $Source } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to subscribe to event '$($Exception.Context.EventName)': $($Exception.Message)" -Data $Exception.Context
        return $null # Return null on error
    }
}

function global:Unsubscribe-Event {
    <#
    .SYNOPSIS
    Unsubscribes from an event
    
    .PARAMETER EventName
    The name of the event to unsubscribe from (optional if HandlerId is provided)
    
    .PARAMETER HandlerId
    The unique identifier of the handler to remove
    #>
    param(
        [Parameter()]
        [string]$EventName,
        
        [Parameter(Mandatory = $true)]
        [string]$HandlerId
    )
    Invoke-WithErrorHandling -Component "EventSystem.UnsubscribeEvent" -ScriptBlock {
        if ($EventName) {
            # Fast path when event name is known
            if ($script:EventHandlers.ContainsKey($EventName)) {
                $script:EventHandlers[$EventName] = @($script:EventHandlers[$EventName] | Where-Object { $_.HandlerId -ne $HandlerId })
                
                if ($script:EventHandlers[$EventName].Count -eq 0) {
                    $script:EventHandlers.Remove($EventName)
                }
                
                Write-Verbose "Unsubscribed from event: $EventName (Handler: $HandlerId)"
            }
        } else {
            # Search all events for the handler ID
            $found = $false
            foreach ($eventKey in @($script:EventHandlers.Keys)) {
                $handlers = $script:EventHandlers[$eventKey]
                $newHandlers = @($handlers | Where-Object { $_.HandlerId -ne $HandlerId })
                
                if ($newHandlers.Count -lt $handlers.Count) {
                    $found = $true
                    if ($newHandlers.Count -eq 0) {
                        $script:EventHandlers.Remove($eventKey)
                    } else {
                        $script:EventHandlers[$eventKey] = $newHandlers
                    }
                    Write-Verbose "Unsubscribed from event: $eventKey (Handler: $HandlerId)"
                    break
                }
            }
            
            if (-not $found) {
                Write-Warning "Handler ID not found: $HandlerId"
            }
        }
    } -Context @{ EventName = $EventName; HandlerId = $HandlerId } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to unsubscribe from event '$($Exception.Context.EventName)' with ID '$($Exception.Context.HandlerId)': $($Exception.Message)" -Data $Exception.Context
    }
}

function global:Get-EventHandlers {
    <#
    .SYNOPSIS
    Gets all registered event handlers
    
    .PARAMETER EventName
    Optional event name to filter by
    #>
    param(
        [Parameter()]
        [string]$EventName
    )
    Invoke-WithErrorHandling -Component "EventSystem.GetEventHandlers" -ScriptBlock {
        if ($EventName) {
            if ($script:EventHandlers.ContainsKey($EventName)) {
                return $script:EventHandlers[$EventName]
            } else {
                return @()
            }
        } else {
            return $script:EventHandlers
        }
    } -Context @{ EventName = $EventName } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to get event handlers for '$($Exception.Context.EventName)': $($Exception.Message)" -Data $Exception.Context
        return @{} # Return empty on error
    }
}

function global:Clear-EventHandlers {
    <#
    .SYNOPSIS
    Clears all event handlers for a specific event or all events
    
    .PARAMETER EventName
    Optional event name to clear handlers for
    #>
    param(
        [Parameter()]
        [string]$EventName
    )
    Invoke-WithErrorHandling -Component "EventSystem.ClearEventHandlers" -ScriptBlock {
        if ($EventName) {
            if ($script:EventHandlers.ContainsKey($EventName)) {
                $script:EventHandlers.Remove($EventName)
                Write-Verbose "Cleared handlers for event: $EventName"
            }
        } else {
            $script:EventHandlers = @{}
            Write-Verbose "Cleared all event handlers"
        }
    } -Context @{ EventName = $EventName } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to clear event handlers for '$($Exception.Context.EventName)': $($Exception.Message)" -Data $Exception.Context
    }
}

function global:Get-EventHistory {
    <#
    .SYNOPSIS
    Gets the event history
    
    .PARAMETER EventName
    Optional event name to filter by
    
    .PARAMETER Last
    Number of recent events to return
    #>
    param(
        [Parameter()]
        [string]$EventName,
        
        [Parameter()]
        [int]$Last = 0
    )
    Invoke-WithErrorHandling -Component "EventSystem.GetEventHistory" -ScriptBlock {
        $history = $script:EventHistory
        
        if ($EventName) {
            $history = $history | Where-Object { $_.EventName -eq $EventName }
        }
        
        if ($Last -gt 0) {
            $history = $history | Select-Object -Last $Last
        }
        
        return $history
    } -Context @{ EventName = $EventName; LastCount = $Last } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to get event history for '$($Exception.Context.EventName)': $($Exception.Message)" -Data $Exception.Context
        return @() # Return empty array on error
    }
}

function global:Remove-ComponentEventHandlers {
    <#
    .SYNOPSIS
    Removes all event handlers associated with a specific component
    
    .PARAMETER ComponentId
    The ID of the component whose handlers should be removed
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$ComponentId
    )
    Invoke-WithErrorHandling -Component "EventSystem.RemoveComponentEventHandlers" -ScriptBlock {
        $removedCount = 0
        
        # Iterate through all events and remove handlers with matching component ID
        foreach ($eventName in @($script:EventHandlers.Keys)) {
            $handlers = $script:EventHandlers[$eventName]
            $newHandlers = @()
            
            foreach ($handler in $handlers) {
                # Check if handler has Source property matching ComponentId
                if ($handler.Source -ne $ComponentId) {
                    $newHandlers += $handler
                } else {
                    $removedCount++
                }
            }
            
            if ($newHandlers.Count -eq 0) {
                $script:EventHandlers.Remove($eventName)
            } else {
                $script:EventHandlers[$eventName] = $newHandlers
            }
        }
        
        Write-Verbose "Removed $removedCount event handlers for component: $ComponentId"
    } -Context @{ ComponentId = $ComponentId } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to remove event handlers for component '$($Exception.Context.ComponentId)': $($Exception.Message)" -Data $Exception.Context
    }
}

# Export functions
Export-ModuleMember -Function @(
    'Initialize-EventSystem',
    'Publish-Event',
    'Subscribe-Event',
    'Unsubscribe-Event',
    'Get-EventHandlers',
    'Clear-EventHandlers',
    'Get-EventHistory',
    'Remove-ComponentEventHandlers'
)
# Dialog System Module - FIXED VERSION
# Uses engine's word wrap helper and respects the framework

$script:DialogState = @{
    CurrentDialog = $null
    DialogStack   = [System.Collections.Stack]::new()
}

#region --- Public API & Factory Functions ---

function global:Show-TuiDialog {
    <# .SYNOPSIS Internal function to display a dialog component. #>
    param([hashtable]$DialogComponent)
    Invoke-WithErrorHandling -Component "DialogSystem.ShowDialog" -ScriptBlock {
        if ($script:DialogState.CurrentDialog) {
            $script:DialogState.DialogStack.Push($script:DialogState.CurrentDialog)
        }
        $script:DialogState.CurrentDialog = $DialogComponent
        Request-TuiRefresh
    } -Context @{ DialogType = $DialogComponent.Type; DialogTitle = $DialogComponent.Title } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to show dialog '$($Exception.Context.DialogTitle)': $($Exception.Message)" -Data $Exception.Context
    }
}

function global:Close-TuiDialog {
    <# .SYNOPSIS Closes the current dialog and restores the previous one, if any. #>
    Invoke-WithErrorHandling -Component "DialogSystem.CloseDialog" -ScriptBlock {
        if ($script:DialogState.DialogStack.Count -gt 0) {
            $script:DialogState.CurrentDialog = $script:DialogState.DialogStack.Pop()
        } else {
            $script:DialogState.CurrentDialog = $null
        }
        Request-TuiRefresh
    } -Context @{} -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to close dialog: $($Exception.Message)" -Data $Exception.Context
    }
}

function global:Show-ConfirmDialog {
    <# .SYNOPSIS Displays a standard Yes/No confirmation dialog. #>
    param(
        [string]$Title = "Confirm",
        [string]$Message,
        [scriptblock]$OnConfirm,
        [scriptblock]$OnCancel = {}
    )
    Invoke-WithErrorHandling -Component "DialogSystem.ShowConfirmDialog" -ScriptBlock {
        $dialog = New-TuiDialog -Props @{
            Title         = $Title
            Message       = $Message
            Buttons       = @("Yes", "No")
            Width         = [Math]::Min(80, [Math]::Max(50, $Message.Length + 10))
            Height        = 10
            OnButtonClick = {
                param($Button, $Index)
                Invoke-WithErrorHandling -Component "ConfirmDialog.OnButtonClick" -ScriptBlock {
                    Close-TuiDialog
                    if ($Index -eq 0) { & $OnConfirm } else { & $OnCancel }
                } -Context @{ Button = $Button; Index = $Index; DialogTitle = $Title } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "Confirm Dialog button click error: $($Exception.Message)" -Data $Exception.Context
                }
            }
            OnCancel      = { 
                Invoke-WithErrorHandling -Component "ConfirmDialog.OnCancel" -ScriptBlock {
                    Close-TuiDialog; & $OnCancel 
                } -Context @{ DialogTitle = $Title } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "Confirm Dialog cancel error: $($Exception.Message)" -Data $Exception.Context
                }
            }
        }
        Show-TuiDialog -DialogComponent $dialog
    } -Context @{ Title = $Title; Message = $Message } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to show confirm dialog '$($Exception.Context.Title)': $($Exception.Message)" -Data $Exception.Context
    }
}

function global:Show-AlertDialog {
    <# .SYNOPSIS Displays a simple alert with an OK button. #>
    param(
        [string]$Title = "Alert",
        [string]$Message
    )
    Invoke-WithErrorHandling -Component "DialogSystem.ShowAlertDialog" -ScriptBlock {
        $dialog = New-TuiDialog -Props @{
            Title         = $Title
            Message       = $Message
            Buttons       = @("OK")
            Width         = [Math]::Min(80, [Math]::Max(40, $Message.Length + 10))
            Height        = 10
            OnButtonClick = { 
                Invoke-WithErrorHandling -Component "AlertDialog.OnButtonClick" -ScriptBlock {
                    Close-TuiDialog 
                } -Context @{ DialogTitle = $Title } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "Alert Dialog button click error: $($Exception.Message)" -Data $Exception.Context
                }
            }
            OnCancel      = { 
                Invoke-WithErrorHandling -Component "AlertDialog.OnCancel" -ScriptBlock {
                    Close-TuiDialog 
                } -Context @{ DialogTitle = $Title } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "Alert Dialog cancel error: $($Exception.Message)" -Data $Exception.Context
                }
            }
        }
        Show-TuiDialog -DialogComponent $dialog
    } -Context @{ Title = $Title; Message = $Message } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to show alert dialog '$($Exception.Context.Title)': $($Exception.Message)" -Data $Exception.Context
    }
}

function global:Show-InputDialog {
    <# .SYNOPSIS Displays a dialog to get text input from the user. #>
    param(
        [string]$Title = "Input",
        [string]$Prompt,
        [string]$DefaultValue = "",
        [scriptblock]$OnSubmit,
        [scriptblock]$OnCancel = {}
    )
    Invoke-WithErrorHandling -Component "DialogSystem.ShowInputDialog" -ScriptBlock {
        # Create a screen that contains the input components
        $inputScreen = @{
            Name = "InputDialog"
            State = @{
                InputValue = $DefaultValue
                FocusedIndex = 0  # Start with textbox focused
            }
            _focusableNames = @("InputTextBox", "OKButton", "CancelButton")
            _focusedIndex = 0
            
            Render = {
                param($self)
                Invoke-WithErrorHandling -Component "$($self.Name).Render" -ScriptBlock {
                    # Calculate dialog dimensions
                    $dialogWidth = [Math]::Min(70, [Math]::Max(50, $Prompt.Length + 10))
                    $dialogHeight = 10
                    $dialogX = [Math]::Floor(($global:TuiState.BufferWidth - $dialogWidth) / 2)
                    $dialogY = [Math]::Floor(($global:TuiState.BufferHeight - $dialogHeight) / 2)
                    
                    # Draw dialog box
                    Write-BufferBox -X $dialogX -Y $dialogY -Width $dialogWidth -Height $dialogHeight `
                        -Title " $Title " -BorderColor (Get-ThemeColor "Accent")
                    
                    # Draw prompt
                    $promptX = $dialogX + 2
                    $promptY = $dialogY + 2
                    Write-BufferString -X $promptX -Y $promptY -Text $Prompt
                    
                    # Draw text input
                    $inputY = $promptY + 2
                    $inputWidth = $dialogWidth - 4
                    $isFocused = ($self._focusedIndex -eq 0)
                    $borderColor = if ($isFocused) { Get-ThemeColor "Warning" } else { Get-ThemeColor "Primary" }
                    
                    Write-BufferBox -X $promptX -Y $inputY -Width $inputWidth -Height 3 `
                        -BorderColor $borderColor
                    
                    # Draw input value
                    $displayText = $self.State.InputValue
                    if ($displayText.Length > ($inputWidth - 3)) {
                        $displayText = $displayText.Substring(0, $inputWidth - 3) # Ensure it fits
                    }
                    Write-BufferString -X ($promptX + 1) -Y ($inputY + 1) -Text $displayText
                    
                    # Draw cursor if textbox is focused
                    if ($isFocused) {
                        $cursorPos = [Math]::Min($self.State.InputValue.Length, $inputWidth - 3)
                        Write-BufferString -X ($promptX + 1 + $cursorPos) -Y ($inputY + 1) `
                            -Text "_" -ForegroundColor (Get-ThemeColor "Warning")
                    }
                    
                    # Draw buttons
                    $buttonY = $dialogY + $dialogHeight - 2
                    $buttonSpacing = 15
                    $buttonsWidth = $buttonSpacing * 2
                    $buttonX = $dialogX + [Math]::Floor(($dialogWidth - $buttonsWidth) / 2)
                    
                    # OK button
                    $okFocused = ($self._focusedIndex -eq 1)
                    $okText = if ($okFocused) { "[ OK ]" } else { "  OK  " }
                    $okColor = if ($okFocused) { Get-ThemeColor "Warning" } else { Get-ThemeColor "Primary" }
                    Write-BufferString -X $buttonX -Y $buttonY -Text $okText -ForegroundColor $okColor
                    
                    # Cancel button
                    $cancelFocused = ($self._focusedIndex -eq 2)
                    $cancelText = if ($cancelFocused) { "[ Cancel ]" } else { "  Cancel  " }
                    $cancelColor = if ($cancelFocused) { Get-ThemeColor "Warning" } else { Get-ThemeColor "Primary" }
                    Write-BufferString -X ($buttonX + $buttonSpacing) -Y $buttonY -Text $cancelText -ForegroundColor $cancelColor
                } -Context @{ DialogName = $self.Name; Prompt = $Prompt; CurrentValue = $self.State.InputValue } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "Input Dialog Render error for '$($Exception.Context.DialogName)': $($Exception.Message)" -Data $Exception.Context
                }
            }
            
            HandleInput = {
                param($self, $Key)
                Invoke-WithErrorHandling -Component "$($self.Name).HandleInput" -ScriptBlock {
                    # Handle Tab navigation
                    if ($Key.Key -eq [ConsoleKey]::Tab) {
                        $direction = if ($Key.Modifiers -band [ConsoleModifiers]::Shift) { -1 } else { 1 }
                        $self._focusedIndex = ($self._focusedIndex + $direction + 3) % 3
                        Request-TuiRefresh
                        return $true
                    }
                    
                    # Handle Escape
                    if ($Key.Key -eq [ConsoleKey]::Escape) {
                        Close-TuiDialog
                        Invoke-WithErrorHandling -Component "InputDialog.OnCancel" -ScriptBlock {
                            & $OnCancel
                        } -Context @{ DialogTitle = $Title } -ErrorHandler {
                            param($Exception)
                            Write-Log -Level Error -Message "Input Dialog OnCancel error: $($Exception.Message)" -Data $Exception.Context
                        }
                        return $true
                    }
                    
                    # Handle based on focused element
                    switch ($self._focusedIndex) {
                        0 {  # TextBox
                            switch ($Key.Key) {
                                ([ConsoleKey]::Enter) {
                                    Close-TuiDialog
                                    Invoke-WithErrorHandling -Component "InputDialog.OnSubmit" -ScriptBlock {
                                        & $OnSubmit -Value $self.State.InputValue
                                    } -Context @{ DialogTitle = $Title; InputValue = $self.State.InputValue } -ErrorHandler {
                                        param($Exception)
                                        Write-Log -Level Error -Message "Input Dialog OnSubmit error: $($Exception.Message)" -Data $Exception.Context
                                    }
                                    return $true
                                }
                                ([ConsoleKey]::Backspace) {
                                    if ($self.State.InputValue.Length -gt 0) {
                                        $self.State.InputValue = $self.State.InputValue.Substring(0, $self.State.InputValue.Length - 1)
                                        Request-TuiRefresh
                                    }
                                    return $true
                                }
                                default {
                                    if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar)) {
                                        $self.State.InputValue += $Key.KeyChar
                                        Request-TuiRefresh
                                        return $true
                                    }
                                }
                            }
                        }
                        1 {  # OK Button
                            if ($Key.Key -eq [ConsoleKey]::Enter -or $Key.Key -eq [ConsoleKey]::Spacebar) {
                                Close-TuiDialog
                                Invoke-WithErrorHandling -Component "InputDialog.OnSubmit" -ScriptBlock {
                                    & $OnSubmit -Value $self.State.InputValue
                                } -Context @{ DialogTitle = $Title; InputValue = $self.State.InputValue } -ErrorHandler {
                                    param($Exception)
                                    Write-Log -Level Error -Message "Input Dialog OnSubmit error: $($Exception.Message)" -Data $Exception.Context
                                }
                                return $true
                            }
                        }
                        2 {  # Cancel Button
                            if ($Key.Key -eq [ConsoleKey]::Enter -or $Key.Key -eq [ConsoleKey]::Spacebar) {
                                Close-TuiDialog
                                Invoke-WithErrorHandling -Component "InputDialog.OnCancel" -ScriptBlock {
                                    & $OnCancel
                                } -Context @{ DialogTitle = $Title } -ErrorHandler {
                                    param($Exception)
                                    Write-Log -Level Error -Message "Input Dialog OnCancel error: $($Exception.Message)" -Data $Exception.Context
                                }
                                return $true
                            }
                        }
                    }
                    
                    return $false
                } -Context @{ DialogName = $self.Name; Key = $Key; FocusedIndex = $self._focusedIndex } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "Input Dialog HandleInput error for '$($Exception.Context.DialogName)': $($Exception.Message)" -Data $Exception.Context
                    return $false
                }
            }
        }
        
        $script:DialogState.CurrentDialog = $inputScreen
        Request-TuiRefresh
    } -Context @{ Title = $Title; Prompt = $Prompt; DefaultValue = $DefaultValue } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to show input dialog '$($Exception.Context.Title)': $($Exception.Message)" -Data $Exception.Context
    }
}

#endregion

#region --- Engine Integration & Initialization ---

function global:Initialize-DialogSystem {
    <# .SYNOPSIS Subscribes to high-level application events to show dialogs. #>
    Invoke-WithErrorHandling -Component "DialogSystem.Initialize" -ScriptBlock {
        Subscribe-Event -EventName "Confirm.Request" -Handler {
            param($EventData)
            Invoke-WithErrorHandling -Component "DialogSystem.ConfirmEventHandler" -ScriptBlock {
                $dialogParams = $EventData.Data
                Show-ConfirmDialog @dialogParams
            } -Context @{ EventData = $EventData } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "Confirm.Request event handler error: $($Exception.Message)" -Data $Exception.Context
            }
        }
        
        Subscribe-Event -EventName "Alert.Show" -Handler {
            param($EventData)
            Invoke-WithErrorHandling -Component "DialogSystem.AlertEventHandler" -ScriptBlock {
                $dialogParams = $EventData.Data
                Show-AlertDialog @dialogParams
            } -Context @{ EventData = $EventData } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "Alert.Show event handler error: $($Exception.Message)" -Data $Exception.Context
            }
        }
        
        Subscribe-Event -EventName "Input.Request" -Handler {
            param($EventData)
            Invoke-WithErrorHandling -Component "DialogSystem.InputEventHandler" -ScriptBlock {
                $dialogParams = $EventData.Data
                Show-InputDialog @dialogParams
            } -Context @{ EventData = $EventData } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "Input.Request event handler error: $($Exception.Message)" -Data $Exception.Context
            }
        }
        
        Write-Verbose "Dialog System initialized and event handlers registered."
    } -Context @{} -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to initialize Dialog System: $($Exception.Message)" -Data $Exception.Context
    }
}

function global:Render-Dialogs {
    <# .SYNOPSIS Engine Hook: Renders the current dialog over the screen. #>
    Invoke-WithErrorHandling -Component "DialogSystem.RenderDialogs" -ScriptBlock {
        if ($script:DialogState.CurrentDialog) {
            # If it's a component with its own render method
            if ($script:DialogState.CurrentDialog.Render) {
                & $script:DialogState.CurrentDialog.Render -self $script:DialogState.CurrentDialog
            }
        }
    } -Context @{ CurrentDialog = $script:DialogState.CurrentDialog.Name } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Error rendering dialog '$($Exception.Context.CurrentDialog)': $($Exception.Message)" -Data $Exception.Context
    }
}

function global:Handle-DialogInput {
    <# .SYNOPSIS Engine Hook: Intercepts input if a dialog is active. #>
    param($Key)
    Invoke-WithErrorHandling -Component "DialogSystem.HandleDialogInput" -ScriptBlock {
        if ($script:DialogState.CurrentDialog) {
            if ($script:DialogState.CurrentDialog.HandleInput) {
                return & $script:DialogState.CurrentDialog.HandleInput -self $script:DialogState.CurrentDialog -Key $Key
            }
        }
        return $false
    } -Context @{ CurrentDialog = $script:DialogState.CurrentDialog.Name; Key = $Key } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Error handling dialog input for '$($Exception.Context.CurrentDialog)': $($Exception.Message)" -Data $Exception.Context
        return $false
    }
}

function global:Update-DialogSystem {
    <# .SYNOPSIS Engine Hook: Updates dialog system state. #>
    Invoke-WithErrorHandling -Component "DialogSystem.UpdateDialogSystem" -ScriptBlock {
        # Placeholder for any periodic updates needed
    } -Context @{} -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Error updating dialog system: $($Exception.Message)" -Data $Exception.Context
    }
}

function global:New-TuiDialog {
    <# .SYNOPSIS Creates a simple dialog component. #>
    param([hashtable]$Props = @{})
    
    $dialog = @{
        Type = "Dialog"
        Title = if ($Props.Title) { $Props.Title } else { "Dialog" }
        Message = if ($Props.Message) { $Props.Message } else { "" }
        Buttons = if ($Props.Buttons) { $Props.Buttons } else { @("OK") }
        SelectedButton = 0
        Width = if ($Props.Width) { $Props.Width } else { 50 }
        Height = if ($Props.Height) { $Props.Height } else { 10 }
        X = 0
        Y = 0
        OnButtonClick = if ($Props.OnButtonClick) { $Props.OnButtonClick } else { {} }
        OnCancel = if ($Props.OnCancel) { $Props.OnCancel } else { {} }
        
        Render = {
            param($self)
            Invoke-WithErrorHandling -Component "$($self.Type).Render" -ScriptBlock {
                # Center the dialog
                $self.X = [Math]::Floor(($global:TuiState.BufferWidth - $self.Width) / 2)
                $self.Y = [Math]::Floor(($global:TuiState.BufferHeight - $self.Height) / 2)
                
                # Draw dialog box
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -Title $self.Title -BorderColor (Get-ThemeColor "Accent")
                
                # Use engine's word wrap helper
                $messageY = $self.Y + 2
                $messageX = $self.X + 2
                $maxWidth = $self.Width - 4
                
                $wrappedLines = Get-WordWrappedLines -Text $self.Message -MaxWidth $maxWidth
                
                foreach ($line in $wrappedLines) {
                    if ($messageY -ge ($self.Y + $self.Height - 3)) { break }  # Don't overwrite buttons
                    Write-BufferString -X $messageX -Y $messageY -Text $line -ForegroundColor (Get-ThemeColor "Primary")
                    $messageY++
                }
                
                # Buttons
                $buttonY = $self.Y + $self.Height - 3
                $totalButtonWidth = ($self.Buttons.Count * 12) + (($self.Buttons.Count - 1) * 2)
                $buttonX = $self.X + [Math]::Floor(($self.Width - $totalButtonWidth) / 2)
                
                for ($i = 0; $i -lt $self.Buttons.Count; $i++) {
                    $isSelected = ($i -eq $self.SelectedButton)
                    $buttonText = if ($isSelected) { "[ $($self.Buttons[$i]) ]" } else { "  $($self.Buttons[$i])  " }
                    $color = if ($isSelected) { Get-ThemeColor "Warning" } else { Get-ThemeColor "Primary" }
                    
                    Write-BufferString -X $buttonX -Y $buttonY -Text $buttonText -ForegroundColor $color
                    $buttonX += 14
                }
            } -Context @{ DialogTitle = $self.Title; DialogMessage = $self.Message } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "Dialog Render error for '$($Exception.Context.DialogTitle)': $($Exception.Message)" -Data $Exception.Context
            }
        }
        
        HandleInput = {
            param($self, $Key)
            Invoke-WithErrorHandling -Component "$($self.Type).HandleInput" -ScriptBlock {
                switch ($Key.Key) {
                    ([ConsoleKey]::LeftArrow) {
                        $self.SelectedButton = [Math]::Max(0, $self.SelectedButton - 1)
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::RightArrow) {
                        $self.SelectedButton = [Math]::Min($self.Buttons.Count - 1, $self.SelectedButton + 1)
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::Tab) {
                        $self.SelectedButton = ($self.SelectedButton + 1) % $self.Buttons.Count
                        Request-TuiRefresh
                        return $true
                    }
                    
                    ([ConsoleKey]::Enter) {
                        Invoke-WithErrorHandling -Component "$($self.Type).OnButtonClick" -ScriptBlock {
                            & $self.OnButtonClick -Button $self.Buttons[$self.SelectedButton] -Index $self.SelectedButton
                        } -Context @{ DialogTitle = $self.Title; Button = $self.Buttons[$self.SelectedButton]; Index = $self.SelectedButton } -ErrorHandler {
                            param($Exception)
                            Write-Log -Level Error -Message "Dialog OnButtonClick error: $($Exception.Message)" -Data $Exception.Context
                        }
                        return $true
                    }
                    ([ConsoleKey]::Spacebar) {
                        Invoke-WithErrorHandling -Component "$($self.Type).OnButtonClick" -ScriptBlock {
                            & $self.OnButtonClick -Button $self.Buttons[$self.SelectedButton] -Index $self.SelectedButton
                        } -Context @{ DialogTitle = $self.Title; Button = $self.Buttons[$self.SelectedButton]; Index = $self.SelectedButton } -ErrorHandler {
                            param($Exception)
                            Write-Log -Level Error -Message "Dialog OnButtonClick error: $($Exception.Message)" -Data $Exception.Context
                        }
                        return $true
                    }
                    ([ConsoleKey]::Escape) {
                        Invoke-WithErrorHandling -Component "$($self.Type).OnCancel" -ScriptBlock {
                            & $self.OnCancel
                        } -Context @{ DialogTitle = $self.Title } -ErrorHandler {
                            param($Exception)
                            Write-Log -Level Error -Message "Dialog OnCancel error: $($Exception.Message)" -Data $Exception.Context
                        }
                        return $true
                    }
                }
                
                return $false
            } -Context @{ DialogTitle = $self.Title; Key = $Key; SelectedButton = $self.SelectedButton } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "Dialog HandleInput error for '$($Exception.Context.DialogTitle)': $($Exception.Message)" -Data $Exception.Context
                return $false
            }
        }
    }
    
    return $dialog
}

function global:Show-ProgressDialog {
    <# .SYNOPSIS Shows a progress dialog with updating percentage. #>
    param(
        [string]$Title = "Progress",
        [string]$Message = "Processing...",
        [int]$PercentComplete = 0,
        [switch]$ShowCancel
    )
    Invoke-WithErrorHandling -Component "DialogSystem.ShowProgressDialog" -ScriptBlock {
        $dialog = @{
            Type = "ProgressDialog"
            Title = $Title
            Message = $Message
            PercentComplete = $PercentComplete
            Width = 60
            Height = 8
            ShowCancel = $ShowCancel
            IsCancelled = $false
            
            Render = {
                param($self)
                Invoke-WithErrorHandling -Component "$($self.Type).Render" -ScriptBlock {
                    # Center the dialog
                    $x = [Math]::Floor(($global:TuiState.BufferWidth - $self.Width) / 2)
                    $y = [Math]::Floor(($global:TuiState.BufferHeight - $self.Height) / 2)
                    
                    # Draw dialog box
                    Write-BufferBox -X $x -Y $y -Width $self.Width -Height $self.Height `
                        -Title " $($self.Title) " -BorderColor (Get-ThemeColor "Accent")
                    
                    # Draw message
                    Write-BufferString -X ($x + 2) -Y ($y + 2) -Text $self.Message
                    
                    # Draw progress bar
                    $barY = $y + 4
                    $barWidth = $self.Width - 4
                    $filledWidth = [Math]::Floor($barWidth * ($self.PercentComplete / 100))
                    
                    # Progress bar background
                    Write-BufferString -X ($x + 2) -Y $barY `
                        -Text ("─" * $barWidth) -ForegroundColor (Get-ThemeColor "Border")
                    
                    # Progress bar fill
                    if ($filledWidth -gt 0) {
                        Write-BufferString -X ($x + 2) -Y $barY `
                            -Text ("█" * $filledWidth) -ForegroundColor (Get-ThemeColor "Success")
                    }
                    
                    # Percentage text
                    $percentText = "$($self.PercentComplete)%"
                    $percentX = $x + [Math]::Floor(($self.Width - $percentText.Length) / 2)
                    Write-BufferString -X $percentX -Y $barY -Text $percentText
                    
                    # Cancel button if requested
                    if ($self.ShowCancel) {
                        $buttonY = $y + $self.Height - 2
                        $buttonText = if ($self.IsCancelled) { "[ Cancelling... ]" } else { "[ Cancel ]" }
                        $buttonX = $x + [Math]::Floor(($self.Width - $buttonText.Length) / 2)
                        Write-BufferString -X $buttonX -Y $buttonY -Text $buttonText `
                            -ForegroundColor (Get-ThemeColor "Warning")
                    }
                } -Context @{ DialogTitle = $self.Title; Percent = $self.PercentComplete } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "Progress Dialog Render error for '$($Exception.Context.DialogTitle)': $($Exception.Message)" -Data $Exception.Context
                }
            }
            
            HandleInput = {
                param($self, $Key)
                Invoke-WithErrorHandling -Component "$($self.Type).HandleInput" -ScriptBlock {
                    if ($self.ShowCancel -and -not $self.IsCancelled) {
                        if ($Key.Key -eq [ConsoleKey]::Escape -or 
                            $Key.Key -eq [ConsoleKey]::Enter -or 
                            $Key.Key -eq [ConsoleKey]::Spacebar) {
                            $self.IsCancelled = $true
                            Request-TuiRefresh
                            return $true
                        }
                    }
                    
                    return $false
                } -Context @{ DialogTitle = $self.Title; Key = $Key } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "Progress Dialog HandleInput error for '$($Exception.Context.DialogTitle)': $($Exception.Message)" -Data $Exception.Context
                    return $false
                }
            }
            
            UpdateProgress = {
                param($self, [int]$PercentComplete, [string]$Message = $null)
                Invoke-WithErrorHandling -Component "$($self.Type).UpdateProgress" -ScriptBlock {
                    $self.PercentComplete = [Math]::Min(100, [Math]::Max(0, $PercentComplete))
                    if ($Message) { $self.Message = $Message }
                    Request-TuiRefresh
                } -Context @{ DialogTitle = $self.Title; NewPercent = $PercentComplete; NewMessage = $Message } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "Progress Dialog UpdateProgress error for '$($Exception.Context.DialogTitle)': $($Exception.Message)" -Data $Exception.Context
                }
            }
        }
        
        $script:DialogState.CurrentDialog = $dialog
        Request-TuiRefresh
        return $dialog
    } -Context @{ Title = $Title; Message = $Message; Percent = $PercentComplete } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to show progress dialog '$($Exception.Context.Title)': $($Exception.Message)" -Data $Exception.Context
        return $null # Return null on error
    }
}

function global:Show-ListDialog {
    <# .SYNOPSIS Shows a dialog with a selectable list of items. #>
    param(
        [string]$Title = "Select Item",
        [string]$Prompt = "Choose an item:",
        [array]$Items,
        [scriptblock]$OnSelect,
        [scriptblock]$OnCancel = {},
        [switch]$AllowMultiple
    )
    Invoke-WithErrorHandling -Component "DialogSystem.ShowListDialog" -ScriptBlock {
        $dialog = @{
            Type = "ListDialog"
            Title = $Title
            Prompt = $Prompt
            Items = $Items
            SelectedIndex = 0
            SelectedItems = @()
            Width = 60
            Height = [Math]::Min(20, $Items.Count + 8)
            AllowMultiple = $AllowMultiple
            
            Render = {
                param($self)
                Invoke-WithErrorHandling -Component "$($self.Type).Render" -ScriptBlock {
                    $x = [Math]::Floor(($global:TuiState.BufferWidth - $self.Width) / 2)
                    $y = [Math]::Floor(($global:TuiState.BufferHeight - $self.Height) / 2)
                    
                    # Draw dialog box
                    Write-BufferBox -X $x -Y $y -Width $self.Width -Height $self.Height `
                        -Title " $($self.Title) " -BorderColor (Get-ThemeColor "Accent")
                    
                    # Draw prompt
                    Write-BufferString -X ($x + 2) -Y ($y + 2) -Text $self.Prompt
                    
                    # Calculate list area
                    $listY = $y + 4
                    $listHeight = $self.Height - 7
                    $listWidth = $self.Width - 4
                    
                    # Draw scrollable list
                    $startIndex = [Math]::Max(0, $self.SelectedIndex - [Math]::Floor($listHeight / 2))
                    $endIndex = [Math]::Min($self.Items.Count - 1, $startIndex + $listHeight - 1)
                    
                    for ($i = $startIndex; $i -le $endIndex; $i++) {
                        $itemY = $listY + ($i - $startIndex)
                        $item = $self.Items[$i]
                        $isSelected = ($i -eq $self.SelectedIndex)
                        $isChecked = $self.SelectedItems -contains $i
                        
                        # Selection indicator
                        $prefix = ""
                        if ($self.AllowMultiple) {
                            $prefix = if ($isChecked) { "[X] " } else { "[ ] " }
                        }
                        
                        $itemText = "$prefix$item"
                        if ($itemText.Length -gt $listWidth - 2) {
                            $itemText = $itemText.Substring(0, $listWidth - 5) + "..."
                        }
                        
                        $bgColor = if ($isSelected) { Get-ThemeColor "Selection" } else { $null }
                        $fgColor = if ($isSelected) { Get-ThemeColor "Background" } else { Get-ThemeColor "Primary" }
                        
                        Write-BufferString -X ($x + 2) -Y $itemY -Text $itemText `
                            -ForegroundColor $fgColor -BackgroundColor $bgColor
                    }
                    
                    # Draw scrollbar if needed
                    if ($self.Items.Count -gt $listHeight) {
                        $scrollbarX = $x + $self.Width - 2
                        $scrollbarHeight = $listHeight
                        $thumbSize = [Math]::Max(1, [Math]::Floor($scrollbarHeight * $listHeight / $self.Items.Count))
                        $thumbPos = [Math]::Floor($scrollbarHeight * $self.SelectedIndex / $self.Items.Count)
                        
                        for ($i = 0; $i -lt $scrollbarHeight; $i++) {
                            $char = if ($i -ge $thumbPos -and $i -lt ($thumbPos + $thumbSize)) { "█" } else { "│" }
                            Write-BufferString -X $scrollbarX -Y ($listY + $i) -Text $char `
                                -ForegroundColor (Get-ThemeColor "Border")
                        }
                    }
                    
                    # Draw buttons
                    $buttonY = $y + $self.Height - 2
                    if ($self.AllowMultiple) {
                        $okText = "[ OK ]"
                        $cancelText = "[ Cancel ]"
                        $buttonSpacing = 15
                        $totalWidth = 30
                        $startX = $x + [Math]::Floor(($self.Width - $totalWidth) / 2)
                        
                        Write-BufferString -X $startX -Y $buttonY -Text $okText `
                            -ForegroundColor (Get-ThemeColor "Success")
                        Write-BufferString -X ($startX + $buttonSpacing) -Y $buttonY -Text $cancelText `
                            -ForegroundColor (Get-ThemeColor "Primary")
                    }
                } -Context @{ DialogTitle = $self.Title; Prompt = $self.Prompt; SelectedIndex = $self.SelectedIndex } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "List Dialog Render error for '$($Exception.Context.DialogTitle)': $($Exception.Message)" -Data $Exception.Context
                }
            }
            
            HandleInput = {
                param($self, $Key)
                Invoke-WithErrorHandling -Component "$($self.Type).HandleInput" -ScriptBlock {
                    switch ($Key.Key) {
                        ([ConsoleKey]::UpArrow) {
                            $self.SelectedIndex = [Math]::Max(0, $self.SelectedIndex - 1)
                            Request-TuiRefresh
                            return $true
                        }
                        ([ConsoleKey]::DownArrow) {
                            $self.SelectedIndex = [Math]::Min($self.Items.Count - 1, $self.SelectedIndex + 1)
                            Request-TuiRefresh
                            return $true
                        }
                        ([ConsoleKey]::Spacebar) {
                            if ($self.AllowMultiple) {
                                if ($self.SelectedItems -contains $self.SelectedIndex) {
                                    $self.SelectedItems = $self.SelectedItems | Where-Object { $_ -ne $self.SelectedIndex }
                                } else {
                                    $self.SelectedItems += $self.SelectedIndex
                                }
                                Request-TuiRefresh
                                return $true
                            }
                        }
                        ([ConsoleKey]::Enter) {
                            Close-TuiDialog
                            if ($self.AllowMultiple) {
                                $selectedValues = $self.SelectedItems | ForEach-Object { $self.Items[$_] }
                                Invoke-WithErrorHandling -Component "ListDialog.OnSelect" -ScriptBlock {
                                    & $OnSelect -Selected $selectedValues
                                } -Context @{ DialogTitle = $self.Title; SelectedValues = $selectedValues } -ErrorHandler {
                                    param($Exception)
                                    Write-Log -Level Error -Message "List Dialog OnSelect error: $($Exception.Message)" -Data $Exception.Context
                                }
                            } else {
                                Invoke-WithErrorHandling -Component "ListDialog.OnSelect" -ScriptBlock {
                                    & $OnSelect -Selected $self.Items[$self.SelectedIndex]
                                } -Context @{ DialogTitle = $self.Title; SelectedValue = $self.Items[$self.SelectedIndex] } -ErrorHandler {
                                    param($Exception)
                                    Write-Log -Level Error -Message "List Dialog OnSelect error: $($Exception.Message)" -Data $Exception.Context
                                }
                            }
                            return $true
                        }
                        ([ConsoleKey]::Escape) {
                            Close-TuiDialog
                            Invoke-WithErrorHandling -Component "ListDialog.OnCancel" -ScriptBlock {
                                & $OnCancel
                            } -Context @{ DialogTitle = $self.Title } -ErrorHandler {
                                param($Exception)
                                Write-Log -Level Error -Message "List Dialog OnCancel error: $($Exception.Message)" -Data $Exception.Context
                            }
                            return $true
                        }
                    }
                    
                    return $false
                } -Context @{ DialogTitle = $self.Title; Key = $Key; SelectedIndex = $self.SelectedIndex } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "List Dialog HandleInput error for '$($Exception.Context.DialogTitle)': $($Exception.Message)" -Data $Exception.Context
                    return $false
                }
            }
        }
        
        $script:DialogState.CurrentDialog = $dialog
        Request-TuiRefresh
    } -Context @{ Title = $Title; Prompt = $Prompt; ItemsCount = $Items.Count } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to show list dialog '$($Exception.Context.Title)': $($Exception.Message)" -Data $Exception.Context
    }
}

#endregion

# Export all public functions
Export-ModuleMember -Function @(
    'Initialize-DialogSystem',
    'Show-TuiDialog',
    'Close-TuiDialog',
    'Show-ConfirmDialog',
    'Show-AlertDialog',
    'Show-InputDialog',
    'Show-ProgressDialog',
    'Show-ListDialog',
    'Render-Dialogs',
    'Handle-DialogInput',
    'Update-DialogSystem',
    'New-TuiDialog'
)
# Data Manager Module
# Unified data persistence and CRUD operations with event integration

$script:Data = @{
    Projects = @{}
    Tasks = @()
    TimeEntries = @()
    ActiveTimers = @{}
    TodoTemplates = @{}
    Settings = @{
        DefaultView = "Dashboard"
        Theme = "Modern"
        AutoSave = $true
        BackupCount = 5
    }
    # Additional properties for compatibility with action handlers
    time_entries = @()    # underscore format for action compatibility
    timers = @()          # for action compatibility
}

$script:DataPath = Join-Path ([Environment]::GetFolderPath("LocalApplicationData")) "PMCTerminal\pmc-data.json"
$script:BackupPath = Join-Path ([Environment]::GetFolderPath("LocalApplicationData")) "PMCTerminal\backups"
$script:LastSaveTime = $null
$script:DataModified = $false

function global:Initialize-DataManager {
    <#
    .SYNOPSIS
    Initializes the data management system
    #>
    Invoke-WithErrorHandling -Component "DataManager.Initialize" -ScriptBlock {
        # Ensure data directory exists
        $dataDir = Split-Path $script:DataPath -Parent
        if (-not (Test-Path $dataDir)) {
            New-Item -ItemType Directory -Path $dataDir -Force | Out-Null
        }
        
        # Ensure backup directory exists
        if (-not (Test-Path $script:BackupPath)) {
            New-Item -ItemType Directory -Path $script:BackupPath -Force | Out-Null
        }
        
        # Initialize event handlers
        Initialize-DataEventHandlers
        
        # Make data globally accessible
        $global:Data = $script:Data
        
        Write-Verbose "Data manager initialized"
    } -Context @{} -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to initialize Data Manager: $($Exception.Message)" -Data $Exception.Context
    }
}

function global:Load-UnifiedData {
    <#
    .SYNOPSIS
    Loads data from the persistent storage
    #>
    Invoke-WithErrorHandling -Component "DataManager.LoadData" -ScriptBlock {
        if (Test-Path $script:DataPath) {
            try {
                $jsonContent = Get-Content $script:DataPath -Raw
                # Use -Depth to ensure deeply nested objects are properly deserialized
                $loadedData = $jsonContent | ConvertFrom-Json -AsHashtable -Depth 20
                
                # Merge with default structure to ensure all keys exist
                foreach ($key in $loadedData.Keys) {
                    $script:Data[$key] = $loadedData[$key]
                }
                
                $script:LastSaveTime = (Get-Item $script:DataPath).LastWriteTime
                Write-Verbose "Data loaded from $script:DataPath"
                
                # Publish event
                Publish-Event -EventName "Data.Loaded" -Data @{ 
                    Path = $script:DataPath
                    ItemCount = @{
                        Projects = $script:Data.Projects.Count
                        Tasks = $script:Data.Tasks.Count
                        TimeEntries = $script:Data.TimeEntries.Count
                        ActiveTimers = $script:Data.ActiveTimers.Count
                    }
                }
            } catch {
                Write-Log -Level Warning -Message "Failed to load data from '$script:DataPath': $_" -Data @{ FilePath = $script:DataPath; Exception = $_ }
                Write-Warning "Using default data structure"
            }
        } else {
            Write-Verbose "No existing data file found at $script:DataPath"
            # Initialize with sample data
            Initialize-SampleData
        }
        
        # Sync global variable
        $global:Data = $script:Data
    } -Context @{ DataPath = $script:DataPath } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to load unified data from '$($Exception.Context.DataPath)': $($Exception.Message)" -Data $Exception.Context
    }
}

function global:Save-UnifiedData {
    <#
    .SYNOPSIS
    Saves data to persistent storage with backup
    #>
    Invoke-WithErrorHandling -Component "DataManager.SaveData" -ScriptBlock {
        try {
            # Create backup if file exists
            if (Test-Path $script:DataPath) {
                $backupName = "pmc-data_$(Get-Date -Format 'yyyyMMdd_HHmmss').json"
                $backupFile = Join-Path $script:BackupPath $backupName
                Copy-Item $script:DataPath $backupFile -Force
                
                # Clean old backups
                $backups = Get-ChildItem $script:BackupPath -Filter "pmc-data_*.json" | 
                           Sort-Object LastWriteTime -Descending
                
                if ($backups.Count -gt $script:Data.Settings.BackupCount) {
                    $backups | Select-Object -Skip $script:Data.Settings.BackupCount | 
                              Remove-Item -Force
                }
            }
            
            # Save data with increased depth to handle nested objects
            # Use -Compress to reduce file size and -WarningAction to suppress depth warnings
            $jsonContent = $script:Data | ConvertTo-Json -Depth 20 -Compress -WarningAction SilentlyContinue
            Set-Content -Path $script:DataPath -Value $jsonContent -Force
            
            $script:LastSaveTime = Get-Date
            $script:DataModified = $false
            
            Write-Verbose "Data saved to $script:DataPath"
            
            # Publish event
            Publish-Event -EventName "Data.Saved" -Data @{ Path = $script:DataPath }
            
        } catch {
            # This is a critical but potentially recoverable error. We'll use a generic TuiException.
            throw [TuiException]::new(
                "Failed to save application data to disk.",
                @{
                    FilePath = $script:DataPath
                    OriginalException = $_
                }
            )
        }
    } -Context @{ DataPath = $script:DataPath } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to save unified data to '$($Exception.Context.DataPath)': $($Exception.Message)" -Data $Exception.Context
        # Re-throw as HeliosException for central handling
        throw [HeliosException]::new("Failed to save application data to disk.", @{ FilePath = $Exception.Context.DataPath; OriginalException = $Exception.OriginalError })
    }
}

function global:Initialize-DataEventHandlers {
    <#
    .SYNOPSIS
    Sets up event handlers for data operations
    #>
    Invoke-WithErrorHandling -Component "DataManager.InitializeEventHandlers" -ScriptBlock {
        # Time Entry Creation
        $null = Subscribe-Event -EventName "Data.Create.TimeEntry" -Handler {
            param($EventData)
            Invoke-WithErrorHandling -Component "DataManager.TimeEntryCreateHandler" -ScriptBlock {
                $data = $EventData.Data
                
                # Validate required fields
                if (-not $data.Project) { throw "Project is required" }
                if (-not $data.Hours -or $data.Hours -le 0) { throw "Valid hours required" }
                
                $newEntry = @{
                    Id = New-Guid
                    ProjectKey = $data.Project
                    Hours = [double]$data.Hours
                    Description = if ($data.Description) { $data.Description } else { "" }
                    Date = if ($data.Date) { $data.Date } else { (Get-Date).ToString("yyyy-MM-dd") }
                    EnteredAt = (Get-Date).ToString("o")
                    TaskId = $data.TaskId
                }
                
                $script:Data.TimeEntries += $newEntry
                $script:DataModified = $true
                
                if ($script:Data.Settings.AutoSave) {
                    Save-UnifiedData
                }
                
                Publish-Event -EventName "Notification.Show" -Data @{ 
                    Text = "Time entry saved: $($data.Hours)h for $($data.Project)"
                    Type = "Success" 
                }
                
                Publish-Event -EventName "Data.TimeEntry.Created" -Data @{ Entry = $newEntry }
                
            } -Context @{ EventData = $EventData.Data } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "Failed to create time entry: $($Exception.Message)" -Data $Exception.Context
                Publish-Event -EventName "Notification.Show" -Data @{ 
                    Text = "Failed to create time entry: $($Exception.Message)"
                    Type = "Error" 
                }
            }
        }
        
        # Project Creation
        $null = Subscribe-Event -EventName "Data.Create.Project" -Handler {
            param($EventData)
            Invoke-WithErrorHandling -Component "DataManager.ProjectCreateHandler" -ScriptBlock {
                $data = $EventData.Data
                
                if (-not $data.Key) { throw "Project key is required" }
                if (-not $data.Name) { throw "Project name is required" }
                
                if ($script:Data.Projects.ContainsKey($data.Key)) {
                    throw "Project key '$($data.Key)' already exists"
                }
                
                $newProject = @{
                    Key = $data.Key
                    Name = $data.Name
                    Client = if ($data.Client) { $data.Client } else { "" }
                    BillingType = if ($data.BillingType) { $data.BillingType } else { "NonBillable" }
                    Rate = [double](if ($data.Rate) { $data.Rate } else { 0 })
                    Budget = [double](if ($data.Budget) { $data.Budget } else { 0 })
                    Id1 = if ($data.Id1) { $data.Id1 } else { "" }
                    Id2 = if ($data.Id2) { $data.Id2 } else { "" }
                    CreatedAt = (Get-Date).ToString("o")
                    Active = $true
                }
                
                $script:Data.Projects[$data.Key] = $newProject
                $script:DataModified = $true
                
                if ($script:Data.Settings.AutoSave) {
                    Save-UnifiedData
                }
                
                Publish-Event -EventName "Notification.Show" -Data @{ 
                    Text = "Project created: $($data.Name)"
                    Type = "Success" 
                }
                
                Publish-Event -EventName "Data.Project.Created" -Data @{ Project = $newProject }
                
            } -Context @{ EventData = $EventData.Data } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "Failed to create project: $($Exception.Message)" -Data $Exception.Context
                Publish-Event -EventName "Notification.Show" -Data @{ 
                    Text = "Failed to create project: $($Exception.Message)"
                    Type = "Error" 
                }
            }
        }
        
        # Task Creation
        $null = Subscribe-Event -EventName "Data.Create.Task" -Handler {
            param($EventData)
            Invoke-WithErrorHandling -Component "DataManager.TaskCreateHandler" -ScriptBlock {
                $data = $EventData.Data
                
                if (-not $data.Description) { throw "Task description is required" }
                
                $newTask = @{
                    Id = New-Guid
                    Description = $data.Description
                    ProjectKey = $data.ProjectKey
                    Priority = if ($data.Priority) { $data.Priority } else { "Medium" }
                    DueDate = $data.DueDate
                    Tags = @(if ($data.Tags) { $data.Tags } else { @() })
                    Completed = $false
                    CreatedAt = (Get-Date).ToString("o")
                    Progress = 0
                }
                
                $script:Data.Tasks += $newTask
                $script:DataModified = $true
                
                if ($script:Data.Settings.AutoSave) {
                    Save-UnifiedData
                }
                
                Publish-Event -EventName "Notification.Show" -Data @{ 
                    Text = "Task created: $($data.Description)"
                    Type = "Success" 
                }
                
                Publish-Event -EventName "Data.Task.Created" -Data @{ Task = $newTask }
                
            } -Context @{ EventData = $EventData.Data } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "Failed to create task: $($Exception.Message)" -Data $Exception.Context
                Publish-Event -EventName "Notification.Show" -Data @{ 
                    Text = "Failed to create task: $($Exception.Message)"
                    Type = "Error" 
                }
            }
        }
        
        # Timer Start
        $null = Subscribe-Event -EventName "Data.Timer.Start" -Handler {
            param($EventData)
            Invoke-WithErrorHandling -Component "DataManager.TimerStartHandler" -ScriptBlock {
                $data = $EventData.Data
                
                if (-not $data.ProjectKey) { throw "Project is required to start timer" }
                
                $timerKey = "$($data.ProjectKey)_$(Get-Date -Format 'yyyyMMddHHmmss')"
                
                $newTimer = @{
                    Key = $timerKey
                    ProjectKey = $data.ProjectKey
                    TaskId = $data.TaskId
                    Description = if ($data.Description) { $data.Description } else { "" }
                    StartTime = (Get-Date).ToString("o")
                }
                
                $script:Data.ActiveTimers[$timerKey] = $newTimer
                $script:DataModified = $true
                
                if ($script:Data.Settings.AutoSave) {
                    Save-UnifiedData
                }
                
                $project = $script:Data.Projects[$data.ProjectKey]
                Publish-Event -EventName "Notification.Show" -Data @{ 
                    Text = "Timer started for: $($project.Name)"
                    Type = "Success" 
                }
                
                Publish-Event -EventName "Data.Timer.Started" -Data @{ Timer = $newTimer }
                
            } -Context @{ EventData = $EventData.Data } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "Failed to start timer: $($Exception.Message)" -Data $Exception.Context
                Publish-Event -EventName "Notification.Show" -Data @{ 
                    Text = "Failed to start timer: $($Exception.Message)"
                    Type = "Error" 
                }
            }
        }
        
        # Timer Stop
        $null = Subscribe-Event -EventName "Data.Timer.Stop" -Handler {
            param($EventData)
            Invoke-WithErrorHandling -Component "DataManager.TimerStopHandler" -ScriptBlock {
                $data = $EventData.Data
                
                if (-not $data.TimerKey) { throw "Timer key is required" }
                
                if (-not $script:Data.ActiveTimers.ContainsKey($data.TimerKey)) {
                    throw "Timer not found: $($data.TimerKey)"
                }
                
                $timer = $script:Data.ActiveTimers[$data.TimerKey]
                $startTime = [DateTime]$timer.StartTime
                $elapsed = (Get-Date) - $startTime
                
                # Create time entry from timer
                $timeEntry = @{
                    Id = New-Guid
                    ProjectKey = $timer.ProjectKey
                    Hours = [Math]::Round($elapsed.TotalHours, 2)
                    Description = $timer.Description
                    Date = $startTime.ToString("yyyy-MM-dd")
                    EnteredAt = (Get-Date).ToString("o")
                    TaskId = $timer.TaskId
                    FromTimer = $true
                }
                
                $script:Data.TimeEntries += $timeEntry
                $script:Data.ActiveTimers.Remove($data.TimerKey)
                $script:DataModified = $true
                
                if ($script:Data.Settings.AutoSave) {
                    Save-UnifiedData
                }
                
                Publish-Event -EventName "Notification.Show" -Data @{ 
                    Text = "Timer stopped: $([Math]::Round($elapsed.TotalHours, 2))h recorded"
                    Type = "Success" 
                }
                
                Publish-Event -EventName "Data.Timer.Stopped" -Data @{ 
                    Timer = $timer
                    TimeEntry = $timeEntry 
                }
                
            } -Context @{ EventData = $EventData.Data } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "Failed to stop timer: $($Exception.Message)" -Data $Exception.Context
                Publish-Event -EventName "Notification.Show" -Data @{ 
                    Text = "Failed to stop timer: $($Exception.Message)"
                    Type = "Error" 
                }
            }
        }
        
        # Stop All Timers
        $null = Subscribe-Event -EventName "Data.Timer.StopAll" -Handler {
            param($EventData)
            Invoke-WithErrorHandling -Component "DataManager.TimerStopAllHandler" -ScriptBlock {
                $timerKeys = @($script:Data.ActiveTimers.Keys)
                foreach ($timerKey in $timerKeys) {
                    Publish-Event -EventName "Data.Timer.Stop" -Data @{ TimerKey = $timerKey }
                }
            } -Context @{ EventData = $EventData.Data } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "Failed to stop all timers: $($Exception.Message)" -Data $Exception.Context
                Publish-Event -EventName "Notification.Show" -Data @{ 
                    Text = "Failed to stop all timers: $($Exception.Message)"
                    Type = "Error" 
                }
            }
        }
    } -Context @{} -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to initialize Data Manager event handlers: $($Exception.Message)" -Data $Exception.Context
    }
}

function global:Get-ProjectOrTemplate {
    <#
    .SYNOPSIS
    Gets a project or template by key
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$Key
    )
    Invoke-WithErrorHandling -Component "DataManager.GetProjectOrTemplate" -ScriptBlock {
        if ($script:Data.Projects.ContainsKey($Key)) {
            return $script:Data.Projects[$Key]
        } elseif ($script:Data.TodoTemplates.ContainsKey($Key)) {
            return $script:Data.TodoTemplates[$Key]
        } else {
            return @{ 
                Key = $Key
                Name = $Key
                Client = ""
                BillingType = "NonBillable"
                Rate = 0
            }
        }
    } -Context @{ Key = $Key } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to get project or template for key '$($Exception.Context.Key)': $($Exception.Message)" -Data $Exception.Context
        return $null # Return null on error
    }
}

function global:New-Guid {
    <#
    .SYNOPSIS
    Generates a new unique identifier
    #>
    Invoke-WithErrorHandling -Component "DataManager.NewGuid" -ScriptBlock {
        return [Guid]::NewGuid().ToString()
    } -Context @{} -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to generate new GUID: $($Exception.Message)" -Data $Exception.Context
        return "" # Return empty string on error
    }
}

function Initialize-SampleData {
    <#
    .SYNOPSIS
    Initializes sample data for first-time users
    #>
    Invoke-WithErrorHandling -Component "DataManager.InitializeSampleData" -ScriptBlock {
        # Sample projects
        $script:Data.Projects["INTERNAL"] = @{
            Key = "INTERNAL"
            Name = "Internal Work"
            Client = "Company"
            BillingType = "NonBillable"
            Rate = 0
            Budget = 0
            Active = $true
            CreatedAt = (Get-Date).ToString("o")
        }
        
        $script:Data.Projects["SAMPLE"] = @{
            Key = "SAMPLE"
            Name = "Sample Project"
            Client = "Sample Client"
            BillingType = "Billable"
            Rate = 100
            Budget = 10000
            Active = $true
            CreatedAt = (Get-Date).ToString("o")
        }
        
        # Sample todo templates
        $script:Data.TodoTemplates["PERSONAL"] = @{
            Key = "PERSONAL"
            Name = "Personal Tasks"
            Client = ""
            BillingType = "NonBillable"
            Rate = 0
            IsTemplate = $true
        }
        
        Write-Verbose "Sample data initialized"
    } -Context @{} -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to initialize sample data: $($Exception.Message)" -Data $Exception.Context
    }
}

# Helper function to get week dates
function global:Get-WeekDates {
    param([DateTime]$Date)
    Invoke-WithErrorHandling -Component "DataManager.GetWeekDates" -ScriptBlock {
        $monday = $Date.AddDays(1 - [int]$Date.DayOfWeek)
        if ($Date.DayOfWeek -eq [DayOfWeek]::Sunday) {
            $monday = $monday.AddDays(-7)
        }
        
        return @(
            @{ Name = "Monday"; Date = $monday.Date }
            @{ Name = "Tuesday"; Date = $monday.AddDays(1).Date }
            @{ Name = "Wednesday"; Date = $monday.AddDays(2).Date }
            @{ Name = "Thursday"; Date = $monday.AddDays(3).Date }
            @{ Name = "Friday"; Date = $monday.AddDays(4).Date }
        )
    } -Context @{ Date = $Date } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to get week dates for '$($Exception.Context.Date)': $($Exception.Message)" -Data $Exception.Context
        return @() # Return empty array on error
    }
}

function global:Get-WeekStart {
    param([DateTime]$Date)
    Invoke-WithErrorHandling -Component "DataManager.GetWeekStart" -ScriptBlock {
        $monday = $Date.AddDays(1 - [int]$Date.DayOfWeek)
        if ($Date.DayOfWeek -eq [DayOfWeek]::Sunday) {
            $monday = $monday.AddDays(-7)
        }
        
        return $monday.Date
    } -Context @{ Date = $Date } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to get week start for '$($Exception.Context.Date)': $($Exception.Message)" -Data $Exception.Context
        return $null # Return null on error
    }
}

# Export functions
Export-ModuleMember -Function @(
    'Initialize-DataManager',
    'Load-UnifiedData',
    'Save-UnifiedData',
    'Initialize-DataEventHandlers',
    'Get-ProjectOrTemplate',
    'New-Guid',
    'Get-WeekDates',
    'Get-WeekStart'
) -Variable @('Data')
# Enhanced Exception Module for Helios
# Provides EXTREMELY detailed error tracking and context capture.
# This module is now self-contained and relies on the main script to load its dependencies.

# Define custom exception types using PowerShell 5-compatible approach
# FIX: Only add the type if it doesn't already exist to prevent errors on module re-import.
# Enhanced error handling to prevent compilation failures
try {
    if (-not ([System.AppDomain]::CurrentDomain.GetAssemblies() | ForEach-Object { try { $_.GetType('Helios.HeliosException', $false) } catch { $null } } | Where-Object { $_ -ne $null })) {
        Add-Type -TypeDefinition @"
        using System;
        using System.Collections;

        namespace Helios {
            public class HeliosException : Exception {
                public Hashtable Context { get; set; }
                public string Component { get; set; }
                public object OriginalError { get; set; }
                public DateTime Timestamp { get; set; }
                
                public HeliosException(string message, Hashtable context) : base(message) {
                    this.Context = context ?? new Hashtable();
                    this.Component = context != null && context.ContainsKey("Component") ? context["Component"].ToString() : "Unknown";
                    this.Timestamp = DateTime.Now;
                }
            }
            
            public class NavigationException : HeliosException { public NavigationException(string message, Hashtable context) : base(message, context) { } }
            public class ServiceInitializationException : HeliosException { public ServiceInitializationException(string message, Hashtable context) : base(message, context) { } }
            public class ComponentRenderException : HeliosException { public ComponentRenderException(string message, Hashtable context) : base(message, context) { } }
            public class StateMutationException : HeliosException { public StateMutationException(string message, Hashtable context) : base(message, context) { } }
            public class InputHandlingException : HeliosException { public InputHandlingException(string message, Hashtable context) : base(message, context) { } }
            public class DataLoadException : HeliosException { public DataLoadException(string message, Hashtable context) : base(message, context) { } }
            public class ThemeException : HeliosException { public ThemeException(string message, Hashtable context) : base(message, context) { } }
        }
"@ -ErrorAction Stop
        Write-Verbose "Custom Helios exception types compiled successfully"
    }
} catch {
    # If Add-Type fails, log the error prominently and use PowerShell fallbacks
    Write-Warning "CRITICAL: Failed to compile custom exception types: $($_.Exception.Message)"
    Write-Warning "This may cause 'Unable to find type [StateMutationException]' errors"
    Write-Warning "Falling back to PowerShell objects for exception handling"
    
    # Create fallback exception types as PowerShell objects
    $global:HeliosExceptionTypes = @{
        HeliosException = @{
            New = { param($message, $context) 
                [PSCustomObject]@{
                    Message = $message
                    Context = $context
                    Component = if ($context -and $context.Component) { $context.Component } else { "Unknown" }
                    Timestamp = Get-Date
                    GetType = { @{ FullName = "Helios.HeliosException" } }
                }
            }
        }
        StateMutationException = @{
            New = { param($message, $context)
                [PSCustomObject]@{
                    Message = $message
                    Context = $context
                    Component = if ($context -and $context.Component) { $context.Component } else { "Unknown" }
                    Timestamp = Get-Date
                    GetType = { @{ FullName = "Helios.StateMutationException" } }
                }
            }
        }
    }
}

# Global error tracking
$script:ErrorHistory = [System.Collections.ArrayList]::new()
$script:MaxErrorHistory   = 500
$script:GlobalErrorHandler = $null

# Enhanced error handler with automatic logging
function global:Set-HeliosErrorHandler {
    param(
        [scriptblock]$CustomHandler = $null
    )
    $script:GlobalErrorHandler = $CustomHandler
    if(Get-Command Write-Log -ErrorAction SilentlyContinue) {
        Write-Log -Level Info -Message "Helios error handler configured" -Data @{ HasCustomHandler = ($null -ne $CustomHandler) }
    }
}

# Get EXTREMELY detailed error information
function global:Get-DetailedError {
    param(
        [System.Management.Automation.ErrorRecord]$ErrorRecord,
        [hashtable]$AdditionalContext = @{}
    )
    try {
        $callStack = Get-PSCallStack
        $errorInfo = @{
            Timestamp = Get-Date -Format "o"
            Summary = $ErrorRecord.Exception.Message
            Type = $ErrorRecord.Exception.GetType().FullName
            Category = $ErrorRecord.CategoryInfo.Category.ToString()
            CategoryActivity = $ErrorRecord.CategoryInfo.Activity
            CategoryReason = $ErrorRecord.CategoryInfo.Reason
            CategoryTargetName = $ErrorRecord.CategoryInfo.TargetName
            CategoryTargetType = $ErrorRecord.CategoryInfo.TargetType
            TargetObject = $null
            ScriptName = $ErrorRecord.InvocationInfo.ScriptName
            LineNumber = $ErrorRecord.InvocationInfo.ScriptLineNumber
            ColumnNumber = $ErrorRecord.InvocationInfo.OffsetInLine
            Line = $ErrorRecord.InvocationInfo.Line
            Command = $ErrorRecord.InvocationInfo.InvocationName
            PositionMessage = $ErrorRecord.InvocationInfo.PositionMessage
            StackTrace = @()
            InnerExceptions = @()
            HeliosContext = @{}
            SystemContext = @{}
            AdditionalContext = $AdditionalContext
        }
        
        try {
            if ($ErrorRecord.TargetObject) {
                $errorInfo.TargetObject = @{
                    Type = $ErrorRecord.TargetObject.GetType().FullName
                    ToString = $ErrorRecord.TargetObject.ToString()
                }
            }
        } catch {
            $errorInfo.TargetObject = "Failed to serialize target object: $($_.Exception.Message)"
        }
        
        foreach ($frame in $callStack) {
            try {
                $frameInfo = @{
                    Command = $frame.Command
                    Location = $frame.Location
                    ScriptName = $frame.ScriptName
                    ScriptLineNumber = $frame.ScriptLineNumber
                    Module = if ($frame.ScriptName) { [System.IO.Path]::GetFileNameWithoutExtension($frame.ScriptName) } else { "Interactive" }
                }
                $errorInfo.StackTrace += $frameInfo
            } catch {
                $errorInfo.StackTrace += @{
                    Command = "Failed to capture frame"
                    Error = $_.Exception.Message
                }
            }
        }
        
        $innerEx = $ErrorRecord.Exception.InnerException
        while ($innerEx) {
            try {
                $errorInfo.InnerExceptions += @{
                    Message = $innerEx.Message
                    Type = $innerEx.GetType().FullName
                    StackTrace = $innerEx.StackTrace
                }
                $innerEx = $innerEx.InnerException
            } catch {
                # Stop iterating if we can't process an inner exception
                break
            }
        }
        
        $errorInfo.Component = Identify-HeliosComponent -ErrorRecord $ErrorRecord
        
        try {
            $errorInfo.SystemContext = @{
                ProcessId = $PID
                ThreadId = [System.Threading.Thread]::CurrentThread.ManagedThreadId
                PowerShellVersion = $PSVersionTable.PSVersion.ToString()
                ExecutionPolicy = (Get-ExecutionPolicy).ToString()
                CurrentLocation = (Get-Location).Path
                MemoryUsage = [System.GC]::GetTotalMemory($false)
                LoadedModules = try {(Get-Module).Name} catch {"<failed>"}
            }
        } catch {
            $errorInfo.SystemContext = @{ Error = "Failed to capture system context" }
        }
        
        return $errorInfo
        
    } catch {
        return @{
            Timestamp = Get-Date -Format "o"
            Summary = "CRITICAL: Error analysis failed"
            OriginalError = $ErrorRecord.Exception.Message
            AnalysisError = $_.Exception.Message
            Type = "ErrorAnalysisFailure"
        }
    }
}

function global:Identify-HeliosComponent {
    param(
        [System.Management.Automation.ErrorRecord]$ErrorRecord
    )
    try {
        $scriptName = $ErrorRecord.InvocationInfo.ScriptName
        if (-not $scriptName) {
            $callStack = Get-PSCallStack
            foreach ($frame in $callStack) {
                if ($frame.ScriptName) {
                    $scriptName = $frame.ScriptName
                    break
                }
            }
        }
        
        if (-not $scriptName) { return "Interactive/Unknown" }
        
        $fileName = [System.IO.Path]::GetFileNameWithoutExtension($scriptName)
        
        $componentMap = @{
            'app-store' = 'AppStore'
            'navigation' = 'Navigation'
            'tui-engine' = 'TUI Engine'
            'tui-framework' = 'TUI Framework'
            'dashboard-screen' = 'Dashboard'
            'task-screen' = 'Tasks'
            'main-helios' = 'Application'
            'data-manager' = 'Data Manager'
            'theme-manager' = 'Theme Manager'
            'keybindings' = 'Keybindings'
            'exceptions' = 'Exceptions'
            'logger' = 'Logger'
        }
        
        foreach ($pattern in $componentMap.Keys) {
            if ($fileName -match $pattern) {
                return $componentMap[$pattern]
            }
        }
        
        return "Unknown ($fileName)"
        
    } catch {
        return "Component Identification Failed"
    }
}

function global:Invoke-WithErrorHandling {
    param(
        [scriptblock]$ScriptBlock,
        [string]$Component = "Unknown",
        [hashtable]$Context = @{},
        [scriptblock]$ErrorHandler = $null,
        [string]$OperationName = "Unknown Operation"
    )
    if (Get-Command Trace-FunctionEntry -ErrorAction SilentlyContinue) {
        Trace-FunctionEntry -FunctionName "Invoke-WithErrorHandling" -Parameters @{ Component = $Component; OperationName = $OperationName }
    }
    try {
        return (& $ScriptBlock)
    } catch {
        $errorContext = if ($Context) { 
            $newContext = @{}
            foreach ($key in $Context.Keys) {
                $newContext[$key] = $Context[$key]
            }
            $newContext
        } else { @{} }
        $errorContext.Component = $Component
        $errorContext.OperationName = $OperationName
        
        $errorMessage = "An unknown error occurred in $Component"
        $detailedError = $null
        $originalExceptionObject = $_

        if ($originalExceptionObject -is [System.Management.Automation.ErrorRecord]) {
            $errorMessage = $originalExceptionObject.Exception.Message
            $detailedError = Get-DetailedError -ErrorRecord $originalExceptionObject -AdditionalContext $errorContext
        } elseif ($originalExceptionObject -is [Exception]) {
            $errorMessage = $originalExceptionObject.Message
        } elseif ($originalExceptionObject -is [string]) {
            $errorMessage = $originalExceptionObject
        }
        
        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            # FIX: Delimit the last variable with ${} to avoid parsing errors with the colon.
            Write-Log -Level Error -Message "Error in $Component during $OperationName ${errorMessage}" -Data $detailedError
        }
        
        [void]$script:ErrorHistory.Add($detailedError)
        if ($script:ErrorHistory.Count -gt $script:MaxErrorHistory) {
            $script:ErrorHistory.RemoveAt(0)
        }
        
        $heliosEx = [PSCustomObject]@{
            Message = $errorMessage
            Component = $Component
            Context = $errorContext
            Timestamp = (Get-Date)
            OriginalError = $originalExceptionObject
            OperationName = $OperationName
            ExceptionType = 'HeliosException'
        }
        
        if ($ErrorHandler) {
            try {
                & $ErrorHandler -Exception $heliosEx -DetailedError $detailedError
            } catch {
                if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
                    Write-Log -Level Error -Message "Error handler itself failed" -Data @{ OriginalError = $heliosEx.Message; HandlerError = $_.Exception.Message }
                }
            }
        } else {
            $properException = New-Object System.Management.Automation.RuntimeException($heliosEx.Message)
            $properException.Data.Add("HeliosException", $heliosEx)
            throw $properException
        }
    }
}

Export-ModuleMember -Function @(
    'Set-HeliosErrorHandler',
    'Get-DetailedError',
    'Identify-HeliosComponent',
    'Invoke-WithErrorHandling'
)
# Task Screen - Simplified with separate list/form views and defensive programming
# Fixed all scope issues and null reference errors

function Get-TaskManagementScreen {
    param([hashtable]$Services)
    
    $screen = @{
        Name = "TaskManagementScreen"
        Components = @{}
        Children = @()
        _subscriptions = @()
        _services = $null
        _formMode = $null  # null = list view, "create" = new task, "edit" = edit task
        _selectedTask = $null
        _focusIndex = 0
        _focusableComponents = @()
        Visible = $true
        ZIndex = 0
        
        Init = {
            param($self, $services)
            
            # Defensive service validation
            if (-not $services) {
                Write-Log -Level Error -Message "Task Screen Init: No services provided"
                if ($self._services) {
                    $services = $self._services
                } elseif ($global:Services) {
                    $services = $global:Services
                } else {
                    Write-Log -Level Critical -Message "Task Screen Init: No services available"
                    return
                }
            }
            
            $self._services = $services
            Write-Log -Level Info -Message "Task Screen Init: Starting initialization"
            
            # Create root container
            $rootPanel = New-TuiStackPanel -Props @{
                X = 0
                Y = 0
                Width = $global:TuiState.BufferWidth
                Height = $global:TuiState.BufferHeight
                ShowBorder = $false
                Orientation = "Vertical"
            }
            
            if (-not $rootPanel) {
                Write-Log -Level Critical -Message "Task Screen Init: Failed to create root panel"
                return
            }
            
            $self.Components.rootPanel = $rootPanel
            $self.Children = @($rootPanel)
            
            # Create list view panel
            $listPanel = New-TuiStackPanel -Props @{
                Name = "listPanel"
                X = 1
                Y = 1
                Width = ($global:TuiState.BufferWidth - 2)
                Height = ($global:TuiState.BufferHeight - 2)
                ShowBorder = $true
                Title = " Task Management "
                Orientation = "Vertical"
                Spacing = 1
                Padding = 1
                Visible = $true
            }
            
            # Header with instructions
            $headerLabel = New-TuiLabel -Props @{
                Text = "Tasks - [N]ew, [E]dit, [D]elete, [Space] Toggle, [ESC] Back"
                Height = 1
            }
            & $listPanel.AddChild -self $listPanel -Child $headerLabel | Out-Null
            
            # Task table
            $capturedSelf = $self
            $capturedServices = $services
            
            $taskTable = New-TuiDataTable -Props @{
                Name = "taskTable"
                IsFocusable = $true
                ShowBorder = $true
                Height = ($global:TuiState.BufferHeight - 8)
                Columns = @(
                    @{ Name = "Status"; Width = 6; Align = "Center" }
                    @{ Name = "Priority"; Width = 8; Align = "Center" }
                    @{ Name = "Title"; Width = 40; Align = "Left" }
                    @{ Name = "Category"; Width = 15; Align = "Left" }
                    @{ Name = "DueDate"; Width = 10; Align = "Center" }
                )
                Data = @()
                OnRowSelect = {
                    param($SelectedData, $SelectedIndex)
                    # Row selection handled by keyboard shortcuts
                    Write-Log -Level Debug -Message "Task selected: $($SelectedData.Title)"
                }
            }
            
            & $listPanel.AddChild -self $listPanel -Child $taskTable | Out-Null
            & $rootPanel.AddChild -self $rootPanel -Child $listPanel | Out-Null
            
            # Create form view panel (initially hidden)
            $formPanel = New-TuiStackPanel -Props @{
                Name = "formPanel"
                X = 1
                Y = 1
                Width = ($global:TuiState.BufferWidth - 2)
                Height = ($global:TuiState.BufferHeight - 2)
                ShowBorder = $true
                Title = " Task Form "
                Orientation = "Vertical"
                Spacing = 1
                Padding = 2
                Visible = $false
            }
            
            # Form fields
            $titleInput = New-TuiTextBox -Props @{
                Name = "titleInput"
                IsFocusable = $true
                Label = "Title:"
                Width = 60
                Height = 3
                MaxLength = 100
                Text = ""
            }
            
            $descInput = New-TuiTextBox -Props @{
                Name = "descInput"
                IsFocusable = $true
                Label = "Description:"
                Width = 60
                Height = 5
                MaxLength = 500
                Multiline = $true
                Text = ""
            }
            
            $priorityDropdown = New-TuiDropdown -Props @{
                Name = "priorityDropdown"
                IsFocusable = $true
                Label = "Priority:"
                Width = 20
                Options = @(
                    @{ Display = "Low"; Value = "low" }
                    @{ Display = "Medium"; Value = "medium" }
                    @{ Display = "High"; Value = "high" }
                )
                Value = "medium"
            }
            
            $categoryInput = New-TuiTextBox -Props @{
                Name = "categoryInput"
                IsFocusable = $true
                Label = "Category:"
                Width = 30
                Height = 3
                MaxLength = 50
                Text = "General"
            }
            
            $dueDateInput = New-TuiTextBox -Props @{
                Name = "dueDateInput"
                IsFocusable = $true
                Label = "Due Date (YYYY-MM-DD):"
                Width = 20
                Height = 3
                MaxLength = 10
                Text = ""
            }
            
            # Button panel
            $buttonPanel = New-TuiStackPanel -Props @{
                Orientation = "Horizontal"
                Spacing = 2
                Height = 3
            }
            
            $saveButton = New-TuiButton -Props @{
                Text = "[S]ave"
                Width = 10
                IsFocusable = $true
                OnClick = {
                    Write-Log -Level Info -Message "Save button clicked"
                    & $capturedSelf.SaveTask -self $capturedSelf
                }
            }
            
            $cancelButton = New-TuiButton -Props @{
                Text = "[C]ancel"
                Width = 10
                IsFocusable = $true
                OnClick = {
                    Write-Log -Level Info -Message "Cancel button clicked"
                    & $capturedSelf.ShowListView -self $capturedSelf
                }
            }
            
            & $buttonPanel.AddChild -self $buttonPanel -Child $saveButton | Out-Null
            & $buttonPanel.AddChild -self $buttonPanel -Child $cancelButton | Out-Null
            
            # Add all form fields to form panel
            & $formPanel.AddChild -self $formPanel -Child $titleInput | Out-Null
            & $formPanel.AddChild -self $formPanel -Child $descInput | Out-Null
            & $formPanel.AddChild -self $formPanel -Child $priorityDropdown | Out-Null
            & $formPanel.AddChild -self $formPanel -Child $categoryInput | Out-Null
            & $formPanel.AddChild -self $formPanel -Child $dueDateInput | Out-Null
            & $formPanel.AddChild -self $formPanel -Child $buttonPanel | Out-Null
            
            & $rootPanel.AddChild -self $rootPanel -Child $formPanel | Out-Null
            
            # Store component references
            $self.Components.listPanel = $listPanel
            $self.Components.formPanel = $formPanel
            $self.Components.taskTable = $taskTable
            $self.Components.titleInput = $titleInput
            $self.Components.descInput = $descInput
            $self.Components.priorityDropdown = $priorityDropdown
            $self.Components.categoryInput = $categoryInput
            $self.Components.dueDateInput = $dueDateInput
            $self.Components.saveButton = $saveButton
            $self.Components.cancelButton = $cancelButton
            
            # Store focusable components for form
            $self._formFocusableComponents = @(
                $titleInput,
                $descInput,
                $priorityDropdown,
                $categoryInput,
                $dueDateInput,
                $saveButton,
                $cancelButton
            )
            
            # Helper functions
            $self.ShowListView = {
                param($self)
                Write-Log -Level Debug -Message "Showing list view"
                $self._formMode = $null
                $self._selectedTask = $null
                $self._focusIndex = 0
                $self.Components.listPanel.Visible = $true
                $self.Components.formPanel.Visible = $false
                if ($self.Components.taskTable.Focus) {
                    & $self.Components.taskTable.Focus -self $self.Components.taskTable
                }
                Request-TuiRefresh
            }
            
            $self.ShowFormView = {
                param($self, $mode, $task)
                Write-Log -Level Debug -Message "Showing form view: $mode"
                $self._formMode = $mode
                $self._selectedTask = $task
                $self._focusIndex = 0
                
                # Update form title
                $self.Components.formPanel.Title = if ($mode -eq "create") { " New Task " } else { " Edit Task " }
                
                # Clear or populate form fields
                if ($mode -eq "create") {
                    $self.Components.titleInput.Text = ""
                    $self.Components.descInput.Text = ""
                    $self.Components.priorityDropdown.Value = "medium"
                    $self.Components.categoryInput.Text = "General"
                    $self.Components.dueDateInput.Text = ""
                } elseif ($task) {
                    $self.Components.titleInput.Text = if ($task.Title) { $task.Title } else { "" }
                    $self.Components.descInput.Text = if ($task.Description) { $task.Description } else { "" }
                    $self.Components.priorityDropdown.Value = if ($task.Priority) { $task.Priority } else { "medium" }
                    $self.Components.categoryInput.Text = if ($task.Category) { $task.Category } else { "General" }
                    $self.Components.dueDateInput.Text = if ($task.DueDate -and $task.DueDate -ne "N/A") { $task.DueDate } else { "" }
                }
                
                # Show form
                $self.Components.listPanel.Visible = $false
                $self.Components.formPanel.Visible = $true
                
                # Focus first field
                if ($self.Components.titleInput.Focus) {
                    & $self.Components.titleInput.Focus -self $self.Components.titleInput
                }
                
                Request-TuiRefresh
            }
            
            $self.SaveTask = {
                param($self)
                Write-Log -Level Info -Message "SaveTask called"
                
                if (-not $self._services -or -not $self._services.Store) {
                    Write-Log -Level Error -Message "SaveTask: Services not available"
                    return
                }
                
                # Validate input
                $title = $self.Components.titleInput.Text
                if ([string]::IsNullOrWhiteSpace($title)) {
                    Write-Log -Level Warning -Message "SaveTask: Title is required"
                    return
                }
                
                # Build payload
                $payload = @{
                    Title = $title.Trim()
                    Description = $self.Components.descInput.Text
                    Priority = $self.Components.priorityDropdown.Value
                    Category = $self.Components.categoryInput.Text
                    DueDate = $self.Components.dueDateInput.Text
                }
                
                # Dispatch appropriate action
                if ($self._formMode -eq "create") {
                    Write-Log -Level Info -Message "Creating new task: $title"
                    & $self._services.Store.Dispatch -self $self._services.Store -actionName "TASK_CREATE" -payload $payload
                } elseif ($self._formMode -eq "edit" -and $self._selectedTask) {
                    $payload.TaskId = $self._selectedTask.Id
                    Write-Log -Level Info -Message "Updating task: $($self._selectedTask.Id)"
                    & $self._services.Store.Dispatch -self $self._services.Store -actionName "TASK_UPDATE" -payload $payload
                }
                
                # Return to list view
                & $self.ShowListView -self $self
            }
            
            # Subscribe to task updates
            $screen = $self
            $self._subscriptions += & $services.Store.Subscribe -self $services.Store -path "tasks" -handler {
                param($data)
                if ($screen.Components.taskTable) {
                    $newTasks = if ($data.NewValue) { @($data.NewValue) } else { @() }
                    $screen.Components.taskTable.Data = $newTasks
                    if ($screen.Components.taskTable.ProcessData) {
                        & $screen.Components.taskTable.ProcessData -self $screen.Components.taskTable
                    }
                    Request-TuiRefresh
                }
            }
            
            # Initial data load
            & $services.Store.Dispatch -self $services.Store -actionName "TASKS_REFRESH"
            
            # Focus on task table
            if ($taskTable.Focus) {
                & $taskTable.Focus -self $taskTable
            }
            
            Write-Log -Level Info -Message "Task Screen Init: Completed successfully"
        }
        
        HandleInput = {
            param($self, $key)
            
            if (-not $key) { return $false }
            
            # Handle form mode input
            if ($self._formMode) {
                # Form navigation
                if ($key.Key -eq "Tab") {
                    if ($key.Modifiers -band [System.ConsoleModifiers]::Shift) {
                        # Previous field
                        $self._focusIndex--
                        if ($self._focusIndex -lt 0) {
                            $self._focusIndex = $self._formFocusableComponents.Count - 1
                        }
                    } else {
                        # Next field
                        $self._focusIndex++
                        if ($self._focusIndex -ge $self._formFocusableComponents.Count) {
                            $self._focusIndex = 0
                        }
                    }
                    
                    $focusComponent = $self._formFocusableComponents[$self._focusIndex]
                    if ($focusComponent -and $focusComponent.Focus) {
                        & $focusComponent.Focus -self $focusComponent
                    }
                    return $true
                }
                
                # Form shortcuts
                switch ($key.Character) {
                    's' { & $self.SaveTask -self $self; return $true }
                    'S' { & $self.SaveTask -self $self; return $true }
                    'c' { & $self.ShowListView -self $self; return $true }
                    'C' { & $self.ShowListView -self $self; return $true }
                }
                
                # ESC to cancel
                if ($key.Key -eq "Escape") {
                    & $self.ShowListView -self $self
                    return $true
                }
                
                # Pass to focused component
                $focusComponent = $self._formFocusableComponents[$self._focusIndex]
                if ($focusComponent -and $focusComponent.HandleInput) {
                    return & $focusComponent.HandleInput -self $focusComponent -key $key
                }
            } else {
                # List mode input
                switch ($key.Character) {
                    'n' { & $self.ShowFormView -self $self -mode "create"; return $true }
                    'N' { & $self.ShowFormView -self $self -mode "create"; return $true }
                    'e' {
                        $selected = $self.Components.taskTable.GetSelectedData()
                        if ($selected) {
                            & $self.ShowFormView -self $self -mode "edit" -task $selected
                        }
                        return $true
                    }
                    'E' {
                        $selected = $self.Components.taskTable.GetSelectedData()
                        if ($selected) {
                            & $self.ShowFormView -self $self -mode "edit" -task $selected
                        }
                        return $true
                    }
                    'd' {
                        $selected = $self.Components.taskTable.GetSelectedData()
                        if ($selected -and $self._services -and $self._services.Store) {
                            Write-Log -Level Info -Message "Deleting task: $($selected.Id)"
                            & $self._services.Store.Dispatch -self $self._services.Store -actionName "TASK_DELETE" -payload @{ TaskId = $selected.Id }
                        }
                        return $true
                    }
                    'D' {
                        $selected = $self.Components.taskTable.GetSelectedData()
                        if ($selected -and $self._services -and $self._services.Store) {
                            Write-Log -Level Info -Message "Deleting task: $($selected.Id)"
                            & $self._services.Store.Dispatch -self $self._services.Store -actionName "TASK_DELETE" -payload @{ TaskId = $selected.Id }
                        }
                        return $true
                    }
                    ' ' {
                        # Space to toggle completion
                        $selected = $self.Components.taskTable.GetSelectedData()
                        if ($selected -and $self._services -and $self._services.Store) {
                            $newStatus = $selected.Status -ne "✓"
                            Write-Log -Level Info -Message "Toggling task status: $($selected.Id)"
                            & $self._services.Store.Dispatch -self $self._services.Store -actionName "TASK_UPDATE" -payload @{ 
                                TaskId = $selected.Id
                                Completed = $newStatus
                            }
                        }
                        return $true
                    }
                }
                
                # ESC to go back
                if ($key.Key -eq "Escape" -and $self._services -and $self._services.Navigation) {
                    & $self._services.Navigation.GoTo -self $self._services.Navigation -Path "/dashboard" -Services $self._services
                    return $true
                }
                
                # Pass to task table
                if ($self.Components.taskTable -and $self.Components.taskTable.HandleInput) {
                    return & $self.Components.taskTable.HandleInput -self $self.Components.taskTable -key $key
                }
            }
            
            return $false
        }
        
        OnExit = {
            param($self)
            Write-Log -Level Info -Message "Task Screen OnExit: Cleaning up"
            
            # Unsubscribe from all subscriptions
            if ($self._subscriptions -and @($self._subscriptions).Count -gt 0) {
                foreach ($subId in $self._subscriptions) {
                    if ($subId -and $self._services -and $self._services.Store) {
                        try {
                            & $self._services.Store.Unsubscribe -self $self._services.Store -subId $subId
                        } catch {
                            Write-Log -Level Warning -Message "Failed to unsubscribe: $_"
                        }
                    }
                }
                $self._subscriptions = @()
            }
        }
        
        Render = {
            param($self)
            # Components handle their own rendering
        }
    }
    
    return $screen
}

# Alias for compatibility
function Get-TaskScreen {
    param([hashtable]$Services)
    return Get-TaskManagementScreen -Services $Services
}

Export-ModuleMember -Function @('Get-TaskManagementScreen', 'Get-TaskScreen')
# Dashboard Screen - Simplified Navigation-Only Version
# Fixed all scope issues, null checks, and race conditions

function Get-DashboardScreen {
    param([hashtable]$Services)
    
    $screen = @{
        Name = "DashboardScreen"
        Components = @{}
        Children = @()
        _subscriptions = @()
        _focusIndex = 0
        _services = $null
        Visible = $true
        ZIndex = 0
        
        Init = {
            param($self, $services)
            
            # Extreme defensive service validation
            if (-not $services) {
                Write-Log -Level Error -Message "Dashboard Init: No services provided"
                # Try fallback options
                if ($self._services) {
                    $services = $self._services
                    Write-Log -Level Warning -Message "Dashboard Init: Using stored services"
                } elseif ($global:Services) {
                    $services = $global:Services
                    Write-Log -Level Warning -Message "Dashboard Init: Using global services"
                } else {
                    Write-Log -Level Critical -Message "Dashboard Init: No services available anywhere"
                    return
                }
            }
            
            # Store services on screen instance
            $self._services = $services
            
            # Validate critical services exist
            if (-not $services.Store) {
                Write-Log -Level Critical -Message "Dashboard Init: Store service missing"
                return
            }
            if (-not $services.Navigation) {
                Write-Log -Level Critical -Message "Dashboard Init: Navigation service missing"
                return
            }
            
            Write-Log -Level Info -Message "Dashboard Init: Services validated successfully"
            
            # Create simple root panel
            $rootPanel = New-TuiStackPanel -Props @{
                X = 2
                Y = 2
                Width = [Math]::Max(60, ($global:TuiState.BufferWidth - 4))
                Height = [Math]::Max(20, ($global:TuiState.BufferHeight - 4))
                ShowBorder = $true
                Title = " PMC Terminal v4.2 - Main Menu "
                Orientation = "Vertical"
                Spacing = 1
                Padding = 2
            }
            
            # Ensure panel is properly initialized
            if (-not $rootPanel) {
                Write-Log -Level Critical -Message "Dashboard Init: Failed to create root panel"
                return
            }
            
            # Store reference and add to children
            $self.Components.rootPanel = $rootPanel
            $self.Children = @($rootPanel)  # Ensure it's an array
            
            # Add instruction label
            $instructionLabel = New-TuiLabel -Props @{
                Text = "Use Arrow Keys or Number Keys to Navigate"
                Height = 1
                Width = 40
                X = 2
                Y = 1
            }
            
            if ($instructionLabel) {
                & $rootPanel.AddChild -self $rootPanel -Child $instructionLabel | Out-Null
            }
            
            # Create menu data - simple array of options
            $menuItems = @(
                @{ Index = "1"; Action = "New Time Entry"; Path = "/time-entry" }
                @{ Index = "2"; Action = "Start Timer"; Path = "/timer-start" }
                @{ Index = "3"; Action = "View Tasks"; Path = "/task" }
                @{ Index = "4"; Action = "View Projects"; Path = "/project" }
                @{ Index = "5"; Action = "Reports"; Path = "/reports" }
                @{ Index = "6"; Action = "Settings"; Path = "/settings" }
                @{ Index = "0"; Action = "Exit"; Path = "/exit" }
            )
            
            # Create navigation menu using DataTable (simpler than custom list)
            # Capture services in closure BEFORE creating component
            $capturedServices = $services
            $capturedSelf = $self
            
            $navigationMenu = New-TuiDataTable -Props @{
                Name = "navigationMenu"
                IsFocusable = $true
                ShowBorder = $true
                BorderStyle = "Double"
                Title = " Main Menu "
                Height = [Math]::Min(15, $menuItems.Count + 4)
                Width = 50
                Columns = @(
                    @{ Name = "Index"; Width = 5; Align = "Center" }
                    @{ Name = "Action"; Width = 40; Align = "Left" }
                )
                Data = $menuItems
                OnRowSelect = {
                    param($SelectedData, $SelectedIndex)
                    
                    # Extreme defensive checks
                    if ($null -eq $SelectedData) {
                        Write-Log -Level Warning -Message "Dashboard: OnRowSelect called with null data"
                        return
                    }
                    
                    if ($null -eq $capturedServices) {
                        Write-Log -Level Error -Message "Dashboard: Captured services is null in handler"
                        return
                    }
                    
                    if ($null -eq $capturedServices.Navigation) {
                        Write-Log -Level Error -Message "Dashboard: Navigation service is null in handler"
                        return
                    }
                    
                    # Get the path from selected data
                    $path = $SelectedData.Path
                    if ([string]::IsNullOrWhiteSpace($path)) {
                        Write-Log -Level Warning -Message "Dashboard: No path in selected data"
                        return
                    }
                    
                    Write-Log -Level Info -Message "Dashboard: Navigating to $path"
                    
                    # Handle special cases
                    if ($path -eq "/exit") {
                        Write-Log -Level Info -Message "Dashboard: Exit requested"
                        if (Get-Command Stop-TuiEngine -ErrorAction SilentlyContinue) {
                            Stop-TuiEngine
                        }
                        return
                    }
                    
                    # Navigate using captured services
                    try {
                        & $capturedServices.Navigation.GoTo -self $capturedServices.Navigation -Path $path -Services $capturedServices
                    } catch {
                        Write-Log -Level Error -Message "Dashboard: Navigation failed to $path" -Data @{
                            Error = $_.Exception.Message
                            Path = $path
                        }
                    }
                }
            }
            
            # Validate menu was created
            if (-not $navigationMenu) {
                Write-Log -Level Critical -Message "Dashboard Init: Failed to create navigation menu"
                return
            }
            
            # Process data immediately
            if ($navigationMenu.ProcessData) {
                & $navigationMenu.ProcessData -self $navigationMenu
            }
            
            # Add menu to panel
            & $rootPanel.AddChild -self $rootPanel -Child $navigationMenu | Out-Null
            
            # Store component reference
            $self.Components.navigationMenu = $navigationMenu
            $self._navigationMenu = $navigationMenu
            
            # Add status label at bottom
            $statusLabel = New-TuiLabel -Props @{
                Text = "Press ESC to return to this menu from any screen"
                Height = 1
                Width = 45
                X = 2
                Y = 1
            }
            
            if ($statusLabel) {
                & $rootPanel.AddChild -self $rootPanel -Child $statusLabel | Out-Null
            }
            
            # Set initial focus
            if ($navigationMenu.Focus) {
                & $navigationMenu.Focus -self $navigationMenu
            }
            
            # Request initial refresh
            Request-TuiRefresh
            
            Write-Log -Level Info -Message "Dashboard Init: Completed successfully"
        }
        
        HandleInput = {
            param($self, $key)
            
            # Defensive null checks
            if ($null -eq $key) { return $false }
            if ($null -eq $self._navigationMenu) {
                Write-Log -Level Warning -Message "Dashboard HandleInput: Navigation menu not available"
                return $false
            }
            
            # Handle number key shortcuts
            if ($key.Character -match '[0-6]') {
                $index = [int]$key.Character.ToString()
                
                # Get menu items safely
                $menuData = if ($self._navigationMenu.Data) { @($self._navigationMenu.Data) } else { @() }
                
                if ($index -eq 0) {
                    # Exit
                    Write-Log -Level Info -Message "Dashboard: Exit via hotkey"
                    if (Get-Command Stop-TuiEngine -ErrorAction SilentlyContinue) {
                        Stop-TuiEngine
                    }
                    return $true
                } elseif ($index -gt 0 -and $index -le $menuData.Count) {
                    # Navigate to the selected item
                    $selectedItem = $menuData[$index - 1]
                    if ($selectedItem -and $selectedItem.Path -and $self._services -and $self._services.Navigation) {
                        try {
                            & $self._services.Navigation.GoTo -self $self._services.Navigation -Path $selectedItem.Path -Services $self._services
                        } catch {
                            Write-Log -Level Error -Message "Dashboard: Hotkey navigation failed" -Data @{
                                Key = $index
                                Path = $selectedItem.Path
                                Error = $_.Exception.Message
                            }
                        }
                    }
                    return $true
                }
            }
            
            # Pass other keys to the menu
            if ($self._navigationMenu.HandleInput) {
                return & $self._navigationMenu.HandleInput -self $self._navigationMenu -key $key
            }
            
            return $false
        }
        
        OnEnter = {
            param($self)
            Write-Log -Level Info -Message "Dashboard OnEnter"
            
            # Ensure focus on menu
            if ($self._navigationMenu -and $self._navigationMenu.Focus) {
                & $self._navigationMenu.Focus -self $self._navigationMenu
            }
            
            Request-TuiRefresh
        }
        
        OnExit = {
            param($self)
            Write-Log -Level Info -Message "Dashboard OnExit: Cleaning up"
            
            # Clean up any subscriptions (though we don't have any in this simple version)
            if ($self._subscriptions -and $self._subscriptions.Count -gt 0) {
                foreach ($subId in $self._subscriptions) {
                    if ($subId -and $self._services -and $self._services.Store -and $self._services.Store.Unsubscribe) {
                        try {
                            & $self._services.Store.Unsubscribe -self $self._services.Store -subId $subId
                        } catch {
                            Write-Log -Level Warning -Message "Dashboard OnExit: Failed to unsubscribe" -Data @{
                                SubId = $subId
                                Error = $_.Exception.Message
                            }
                        }
                    }
                }
                $self._subscriptions = @()
            }
        }
        
        Render = {
            param($self)
            # The panel and components handle their own rendering
            # This is only for non-component chrome if needed
        }
    }
    
    return $screen
}

Export-ModuleMember -Function Get-DashboardScreen
@{
    # Module manifest for app-store service
    RootModule = 'app-store.psm1'
    ModuleVersion = '1.0.0'
    GUID = 'a1b2c3d4-5e6f-7a8b-9c0d-1e2f3a4b5c6d'
    Author = 'PMC Terminal Team'
    CompanyName = 'PMC Terminal'
    Copyright = '(c) 2025 PMC Terminal. All rights reserved.'
    Description = 'Centralized state management service using Redux-like pattern for PMC Terminal'
    
    # Minimum PowerShell version
    PowerShellVersion = '5.1'
    
    # Functions to export
    FunctionsToExport = @('Initialize-AppStore')
    
    # Variables to export
    VariablesToExport = @()
    
    # Aliases to export
    AliasesToExport = @()
    
    # Cmdlets to export
    CmdletsToExport = @()
    
    # Required modules
    RequiredModules = @(
        @{ ModuleName = 'tui-framework'; ModuleVersion = '1.0.0' }
    )
    
    # Module dependencies that must be loaded
    NestedModules = @()
    
    # Private data
    PrivateData = @{
        PSData = @{
            Tags = @('StateManagement', 'Redux', 'TUI', 'PMC')
            ProjectUri = 'https://github.com/pmc-terminal/pmc-terminal'
            ReleaseNotes = 'Initial release of centralized state management service'
        }
    }
}
# FILE: services/app-store.psm1
# PURPOSE: Provides a single, reactive source of truth for all shared application state using a Redux-like pattern.

function Initialize-AppStore {
    param(
        [hashtable]$InitialData = @{},
        [bool]$EnableDebugLogging = $false
    )
    
    # Initialize state structure properly
    $stateData = if ($InitialData) { $InitialData.Clone() } else { @{} }
    
    $store = @{
        _state = @{
            _data = $stateData
            _subscribers = @{}
            _changeQueue = @()
        }
        _actions = @{}
        _middleware = @()
        _history = @()  # For time-travel debugging
        _enableDebugLogging = $EnableDebugLogging
        
        GetState = { 
            param($self, [string]$path = $null) 
            if ([string]::IsNullOrEmpty($path)) {
                # Directly access state data
                return $self._state._data
            }
            # Navigate path manually
            $parts = $path -split '\.'
            $current = $self._state._data
            foreach ($part in $parts) {
                if ($null -eq $current) { return $null }
                $current = $current[$part]
            }
            return $current
        }
        
        Subscribe = { 
            param($self, [string]$path, [scriptblock]$handler, [bool]$DeferInitialCall = $false) 
            if (-not $handler) { throw "Handler scriptblock is required for Subscribe" }
            
            # Manually implement subscribe to avoid $this issues
            $state = $self._state
            $subId = [Guid]::NewGuid().ToString()
            
            if (-not $state._subscribers) { $state._subscribers = @{} }
            if (-not $state._subscribers.ContainsKey($path)) {
                $state._subscribers[$path] = @()
            }
            
            $state._subscribers[$path] += @{
                Id = $subId
                Handler = $handler
            }
            
            # Call handler with current value unless deferred
            if (-not $DeferInitialCall) {
                $currentValue = & $self.GetState -self $self -path $path
                try {
                    & $handler @{ NewValue = $currentValue; OldValue = $null; Path = $path }
                } catch {
                    Write-Warning "State subscriber error: $_"
                }
            }
            
            return $subId
        }
        
        Unsubscribe = { 
            param($self, $subId) 
            if ($subId -and $self._state._subscribers) {
                # Manually remove subscription
                foreach ($path in @($self._state._subscribers.Keys)) {
                    $self._state._subscribers[$path] = @($self._state._subscribers[$path] | Where-Object { $_.Id -ne $subId })
                    if ($self._state._subscribers[$path].Count -eq 0) {
                        $self._state._subscribers.Remove($path)
                    }
                }
            }
        }
        
        RegisterAction = { 
            param($self, [string]$actionName, [scriptblock]$scriptBlock) 
            if ([string]::IsNullOrWhiteSpace($actionName)) { throw "Action name cannot be empty" }
            if (-not $scriptBlock) { throw "Script block is required for action '$actionName'" }
            $self._actions[$actionName] = $scriptBlock 
            if ($self._enableDebugLogging) { Write-Log -Level Debug -Message "Registered action: $actionName" }
        }
        
        AddMiddleware = {
            param($self, [scriptblock]$middleware)
            $self._middleware += $middleware
        }
        
        Dispatch = {
            param($self, [string]$actionName, $payload = $null)
            
            if ([string]::IsNullOrWhiteSpace($actionName)) { return @{ Success = $false; Error = "Action name cannot be empty" } }
            
            $action = @{ Type = $actionName; Payload = $payload; Timestamp = [DateTime]::UtcNow }
            
            foreach ($mw in $self._middleware) {
                if ($null -ne $mw) {
                    $action = & $mw -Action $action -Store $self
                    if (-not $action) { return @{ Success = $false; Error = "Action cancelled by middleware" } }
                }
            }
            
            if (-not $self._actions.ContainsKey($actionName)) {
                if ($self._enableDebugLogging) { Write-Log -Level Warning -Message "Action '$actionName' not found." }
                return @{ Success = $false; Error = "Action '$actionName' not registered." }
            }
            
            if ($self._enableDebugLogging) { Write-Log -Level Debug -Message "Dispatching action '$actionName'" -Data $payload }
            
            try {
                $previousState = & $self.GetState -self $self
                
                # Create action context with fixed UpdateState
                $storeInstance = $self
                $actionContext = @{
                    GetState = { 
                        param($path = $null) 
                        $store = $storeInstance
                        if ($path) {
                            return & $store.GetState -self $store -path $path
                        } else {
                            return & $store.GetState -self $store
                        }
                    }.GetNewClosure()
                    
                    UpdateState = { 
                        param($updates) 
                        $store = $storeInstance
                        if (-not $updates -or $updates.Count -eq 0) { 
                            Write-Log -Level Debug -Message "UpdateState called with empty updates"
                            return 
                        }
                        
                        Write-Log -Level Debug -Message "UpdateState called with keys: $($updates.Keys -join ', ')"
                        
                        # Use direct update method that handles all the complexity
                        try {
                            & $store._directUpdateState -self $store -updates $updates
                            Write-Log -Level Debug -Message "UpdateState: Successfully updated state"
                        } catch {
                            Write-Log -Level Error -Message "UpdateState failed: $_"
                            throw
                        }
                    }.GetNewClosure()
                    
                    Dispatch = { 
                        param($name, $p = $null) 
                        $store = $storeInstance
                        return & $store.Dispatch -self $store -actionName $name -payload $p
                    }.GetNewClosure()
                }
                
                # Execute the action
                & $self._actions[$actionName] -Context $actionContext -Payload $payload
                
                # Update history
                if ($self._history.Count -gt 100) { $self._history = $self._history[-100..-1] }
                $self._history += @{ Action = $action; PreviousState = $previousState; NextState = (& $self.GetState -self $self) }
                
                return @{ Success = $true }
            } 
            catch {
                # Use PowerShell RuntimeException with attached context data to avoid type dependency issues
                $contextData = @{
                    ActionName = $actionName
                    Payload = $payload
                    OriginalException = $_.Exception.Message
                    Component = "AppStore"
                    OperationName = "Dispatch"
                    Timestamp = [DateTime]::UtcNow
                }
                
                $runtimeException = New-Object System.Management.Automation.RuntimeException("Error executing action '$actionName': $($_.Exception.Message)")
                $runtimeException.Data.Add("HeliosException", $contextData)
                
                if ($self._enableDebugLogging) { 
                    Write-Log -Level Error -Message "Action dispatch failed" -Data $contextData 
                }
                
                throw $runtimeException
            }
        }
        
        _updateState = { 
            param($self, [hashtable]$updates)
            if ($updates -and $self._state) {
                # Direct update implementation
                $state = $self._state
                foreach ($key in $updates.Keys) {
                    $oldValue = $state._data[$key]
                    $state._data[$key] = $updates[$key]
                    
                    if ($oldValue -ne $updates[$key] -and $state._subscribers -and $state._subscribers.ContainsKey($key)) {
                        foreach ($sub in $state._subscribers[$key]) {
                            try {
                                & $sub.Handler @{ NewValue = $updates[$key]; OldValue = $oldValue; Path = $key }
                            } catch {
                                Write-Warning "State notification error: $_"
                            }
                        }
                    }
                }
            }
        }
        
        _directUpdateState = {
            param($self, [hashtable]$updates)
            if (-not $updates -or $updates.Count -eq 0) { return }
            
            Write-Log -Level Debug -Message "_directUpdateState called with $($updates.Count) updates"
            
            # Ensure state structure exists
            $state = $self._state
            if (-not $state._data) { $state._data = @{} }
            
            # Helper function to set nested paths
            $setNestedValue = {
                param($obj, $path, $value)
                $parts = $path -split '\.'
                $current = $obj
                for ($i = 0; $i -lt $parts.Count - 1; $i++) {
                    if (-not $current.ContainsKey($parts[$i])) {
                        $current[$parts[$i]] = @{}
                    }
                    $current = $current[$parts[$i]]
                }
                $current[$parts[-1]] = $value
            }
            
            # Process updates
            foreach ($key in $updates.Keys) {
                $newValue = $updates[$key]
                
                if ($key.Contains('.')) {
                    # Handle nested paths like "stats.todayHours"
                    $oldValue = & $self.GetState -self $self -path $key
                    & $setNestedValue -obj $state._data -path $key -value $newValue
                } else {
                    # Handle simple keys
                    $oldValue = $state._data[$key]
                    $state._data[$key] = $newValue
                }
                
                # Notify subscribers for exact path
                if ($state._subscribers -and $state._subscribers.ContainsKey($key)) {
                    foreach ($sub in $state._subscribers[$key]) {
                        try {
                            & $sub.Handler @{ NewValue = $newValue; OldValue = $oldValue; Path = $key }
                        } catch {
                            Write-Warning "Subscriber notification error for '$key': $_"
                        }
                    }
                }
                
                # Also notify parent path subscribers for nested updates
                if ($key.Contains('.')) {
                    $parts = $key -split '\.'
                    $parentPath = $parts[0]
                    if ($state._subscribers -and $state._subscribers.ContainsKey($parentPath)) {
                        $parentValue = $state._data[$parentPath]
                        foreach ($sub in $state._subscribers[$parentPath]) {
                            try {
                                & $sub.Handler @{ NewValue = $parentValue; OldValue = $parentValue; Path = $parentPath }
                            } catch {
                                Write-Warning "Parent subscriber notification error for '$parentPath': $_"
                            }
                        }
                    }
                }
            }
        }
        
        GetHistory = { param($self) ; return $self._history }
        
        RestoreState = {
            param($self, [int]$stepsBack = 1)
            if ($stepsBack -gt $self._history.Count) { throw "Cannot go back $stepsBack steps. Only $($self._history.Count) actions in history." }
            $targetState = $self._history[-$stepsBack].PreviousState
            & $self._updateState -self $self -updates $targetState
        }
    }
    
    # Register built-in actions
    & $store.RegisterAction -self $store -actionName "RESET_STATE" -scriptBlock {
        param($Context, $Payload)
        & $Context.UpdateState $InitialData
    }
    
    & $store.RegisterAction -self $store -actionName "UPDATE_STATE" -scriptBlock {
        param($Context, $Payload)
        if ($Payload -is [hashtable]) {
            & $Context.UpdateState $Payload
        }
    }
    
    return $store
}

Export-ModuleMember -Function "Initialize-AppStore"
@{
    # Module manifest for keybindings service
    RootModule = 'keybindings.psm1'
    ModuleVersion = '1.0.0'
    GUID = 'c3d4e5f6-7a8b-9c0d-1e2f-3a4b5c6d7e8f'
    Author = 'PMC Terminal Team'
    CompanyName = 'PMC Terminal'
    Copyright = '(c) 2025 PMC Terminal. All rights reserved.'
    Description = 'Centralized keybinding management service with context support for PMC Terminal'
    
    # Minimum PowerShell version
    PowerShellVersion = '5.1'
    
    # Functions to export
    FunctionsToExport = @('Initialize-KeybindingService')
    
    # Variables to export
    VariablesToExport = @()
    
    # Aliases to export
    AliasesToExport = @()
    
    # Cmdlets to export
    CmdletsToExport = @()
    
    # Required modules
    RequiredModules = @()
    
    # Module dependencies that must be loaded
    NestedModules = @()
    
    # Private data
    PrivateData = @{
        PSData = @{
            Tags = @('Keybindings', 'Input', 'TUI', 'PMC')
            ProjectUri = 'https://github.com/pmc-terminal/pmc-terminal'
            ReleaseNotes = 'Initial release of keybinding service with context-aware bindings and chord support'
        }
    }
}
@{
    # Module manifest for keybindings service
    RootModule = 'keybindings.psm1'
    ModuleVersion = '1.0.0'
    GUID = 'c3d4e5f6-7a8b-9c0d-1e2f-3a4b5c6d7e8f'
    Author = 'PMC Terminal Team'
    CompanyName = 'PMC Terminal'
    Copyright = '(c) 2025 PMC Terminal. All rights reserved.'
    Description = 'Centralized keybinding management service with context support for PMC Terminal'
    
    # Minimum PowerShell version
    PowerShellVersion = '5.1'
    
    # Functions to export
    FunctionsToExport = @('Initialize-KeybindingService')
    
    # Variables to export
    VariablesToExport = @()
    
    # Aliases to export
    AliasesToExport = @()
    
    # Cmdlets to export
    CmdletsToExport = @()
    
    # Required modules
    RequiredModules = @()
    
    # Module dependencies that must be loaded
    NestedModules = @()
    
    # Private data
    PrivateData = @{
        PSData = @{
            Tags = @('Keybindings', 'Input', 'TUI', 'PMC')
            ProjectUri = 'https://github.com/pmc-terminal/pmc-terminal'
            ReleaseNotes = 'Initial release of keybinding service with context-aware bindings and chord support'
        }
    }
}
# FILE: services/keybindings.psm1
# PURPOSE: Centralizes keybinding logic to make them configurable and declarative.

function Initialize-KeybindingService {
    param(
        [hashtable]$CustomBindings = @{},
        [bool]$EnableChords = $false  # For future multi-key sequences
    )
    Invoke-WithErrorHandling -Component "KeybindingService.Initialize" -ScriptBlock {
        # Default keybindings - can be overridden
        $defaultKeyMap = @{
            # Application-level
            "App.Quit" = @{ Key = 'Q'; Modifiers = @() }
            "App.ForceQuit" = @{ Key = 'Q'; Modifiers = @('Ctrl') }
            "App.Back" = @{ Key = [ConsoleKey]::Escape; Modifiers = @() }
            "App.Refresh" = @{ Key = 'R'; Modifiers = @() }
            "App.DebugLog" = @{ Key = [ConsoleKey]::F12; Modifiers = @() }
            "App.Help" = @{ Key = [ConsoleKey]::F1; Modifiers = @() }
            
            # List operations
            "List.New" = @{ Key = 'N'; Modifiers = @() }
            "List.Edit" = @{ Key = 'E'; Modifiers = @() }
            "List.Delete" = @{ Key = 'D'; Modifiers = @() }
            "List.Toggle" = @{ Key = [ConsoleKey]::Spacebar; Modifiers = @() }
            "List.SelectAll" = @{ Key = 'A'; Modifiers = @('Ctrl') }
            
            # Navigation
            "Nav.Up" = @{ Key = [ConsoleKey]::UpArrow; Modifiers = @() }
            "Nav.Down" = @{ Key = [ConsoleKey]::DownArrow; Modifiers = @() }
            "Nav.Left" = @{ Key = [ConsoleKey]::LeftArrow; Modifiers = @() }
            "Nav.Right" = @{ Key = [ConsoleKey]::RightArrow; Modifiers = @() }
            "Nav.PageUp" = @{ Key = [ConsoleKey]::PageUp; Modifiers = @() }
            "Nav.PageDown" = @{ Key = [ConsoleKey]::PageDown; Modifiers = @() }
            "Nav.Home" = @{ Key = [ConsoleKey]::Home; Modifiers = @() }
            "Nav.End" = @{ Key = [ConsoleKey]::End; Modifiers = @() }
            
            # Quick navigation (number keys)
            "QuickNav.1" = @{ Key = '1'; Modifiers = @() }
            "QuickNav.2" = @{ Key = '2'; Modifiers = @() }
            "QuickNav.3" = @{ Key = '3'; Modifiers = @() }
            "QuickNav.4" = @{ Key = '4'; Modifiers = @() }
            "QuickNav.5" = @{ Key = '5'; Modifiers = @() }
            "QuickNav.6" = @{ Key = '6'; Modifiers = @() }
            "QuickNav.7" = @{ Key = '7'; Modifiers = @() }
            "QuickNav.8" = @{ Key = '8'; Modifiers = @() }
            "QuickNav.9" = @{ Key = '9'; Modifiers = @() }
            
            # Form operations
            "Form.Submit" = @{ Key = [ConsoleKey]::Enter; Modifiers = @('Ctrl') }
            "Form.Cancel" = @{ Key = [ConsoleKey]::Escape; Modifiers = @() }
            "Form.Clear" = @{ Key = 'C'; Modifiers = @('Ctrl', 'Shift') }
            
            # Text editing
            "Edit.Cut" = @{ Key = 'X'; Modifiers = @('Ctrl') }
            "Edit.Copy" = @{ Key = 'C'; Modifiers = @('Ctrl') }
            "Edit.Paste" = @{ Key = 'V'; Modifiers = @('Ctrl') }
            "Edit.Undo" = @{ Key = 'Z'; Modifiers = @('Ctrl') }
            "Edit.Redo" = @{ Key = 'Y'; Modifiers = @('Ctrl') }
        }
        
        # Merge custom bindings
        $keyMap = $defaultKeyMap
        foreach ($action in $CustomBindings.Keys) {
            $keyMap[$action] = $CustomBindings[$action]
        }
        
        $service = @{
            _keyMap = $keyMap
            _enableChords = $EnableChords
            _chordBuffer = @()
            _chordTimeout = 1000  # milliseconds
            _lastKeyTime = [DateTime]::MinValue
            _contextStack = @()  # For context-specific bindings
            _globalHandlers = @{}  # Action name -> handler scriptblock
            
            IsAction = {
                param(
                    $self,
                    [string]$ActionName, 
                    [System.ConsoleKeyInfo]$KeyInfo,
                    [string]$Context = $null
                )
                Invoke-WithErrorHandling -Component "KeybindingService.IsAction" -ScriptBlock {
                    if ([string]::IsNullOrWhiteSpace($ActionName)) { return $false }
                    
                    # Check context-specific binding first
                    $contextKey = if ($Context) { "$Context.$ActionName" } else { $null }
                    if ($contextKey -and $self._keyMap.ContainsKey($contextKey)) {
                        return (& $self._matchesBinding -self $self -binding $self._keyMap[$contextKey] -keyInfo $KeyInfo)
                    }
                    
                    # Check global binding
                    if (-not $self._keyMap.ContainsKey($ActionName)) { return $false }
                    
                    return (& $self._matchesBinding -self $self -binding $self._keyMap[$ActionName] -keyInfo $KeyInfo)
                } -Context @{ ActionName = $ActionName; KeyInfo = $KeyInfo; Context = $Context } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "KeybindingService IsAction error: $($Exception.Message)" -Data $Exception.Context
                    return $false
                }
            }
            
            _matchesBinding = {
                param($self, $binding, $keyInfo)
                Invoke-WithErrorHandling -Component "KeybindingService._matchesBinding" -ScriptBlock {
                    # Match key
                    $keyMatches = $false
                    if ($binding.Key -is [System.ConsoleKey]) {
                        $keyMatches = $keyInfo.Key -eq $binding.Key
                    }
                    elseif ($binding.Key -is [string] -and $binding.Key.Length -eq 1) {
                        $keyMatches = $keyInfo.KeyChar.ToString().Equals($binding.Key, [System.StringComparison]::InvariantCultureIgnoreCase)
                    }
                    
                    if (-not $keyMatches) { return $false }
                    
                    # Match modifiers
                    $requiredModifiers = $binding.Modifiers ?? @()
                    $hasCtrl = ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Control) -ne 0
                    $hasAlt = ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Alt) -ne 0
                    $hasShift = ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift) -ne 0
                    
                    $ctrlRequired = 'Ctrl' -in $requiredModifiers
                    $altRequired = 'Alt' -in $requiredModifiers
                    $shiftRequired = 'Shift' -in $requiredModifiers
                    
                    return ($hasCtrl -eq $ctrlRequired) -and 
                           ($hasAlt -eq $altRequired) -and 
                           ($hasShift -eq $shiftRequired)
                } -Context @{ Binding = $binding; KeyInfo = $KeyInfo } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "KeybindingService _matchesBinding error: $($Exception.Message)" -Data $Exception.Context
                    return $false
                }
            }
            
            GetBinding = {
                param($self, [string]$ActionName)
                Invoke-WithErrorHandling -Component "KeybindingService.GetBinding" -ScriptBlock {
                    return $self._keyMap[$ActionName]
                } -Context @{ ActionName = $ActionName } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "KeybindingService GetBinding error: $($Exception.Message)" -Data $Exception.Context
                    return $null
                }
            }
            
            SetBinding = {
                param($self, [string]$ActionName, $Key, [string[]]$Modifiers = @())
                Invoke-WithErrorHandling -Component "KeybindingService.SetBinding" -ScriptBlock {
                    $self._keyMap[$ActionName] = @{ Key = $Key; Modifiers = $Modifiers }
                    Write-Log -Level Debug -Message "Set keybinding for '$ActionName': $Key + $($Modifiers -join '+')"
                } -Context @{ ActionName = $ActionName; Key = $Key; Modifiers = $Modifiers } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "KeybindingService SetBinding error: $($Exception.Message)" -Data $Exception.Context
                }
            }
            
            RemoveBinding = {
                param($self, [string]$ActionName)
                Invoke-WithErrorHandling -Component "KeybindingService.RemoveBinding" -ScriptBlock {
                    $self._keyMap.Remove($ActionName)
                    Write-Log -Level Debug -Message "Removed keybinding for '$ActionName'"
                } -Context @{ ActionName = $ActionName } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "KeybindingService RemoveBinding error: $($Exception.Message)" -Data $Exception.Context
                }
            }
            
            GetBindingDescription = {
                param($self, [string]$ActionName)
                Invoke-WithErrorHandling -Component "KeybindingService.GetBindingDescription" -ScriptBlock {
                    if (-not $self._keyMap.ContainsKey($ActionName)) { return $null }
                    $binding = $self._keyMap[$ActionName]
                    $keyStr = if ($binding.Key -is [System.ConsoleKey]) { $binding.Key.ToString() } else { $binding.Key.ToString().ToUpper() }
                    if ($binding.Modifiers.Count -gt 0) { return "$($binding.Modifiers -join '+') + $keyStr" }
                    return $keyStr
                } -Context @{ ActionName = $ActionName } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "KeybindingService GetBindingDescription error: $($Exception.Message)" -Data $Exception.Context
                    return $null
                }
            }
            
            RegisterGlobalHandler = {
                param($self, [string]$ActionName, [scriptblock]$Handler)
                Invoke-WithErrorHandling -Component "KeybindingService.RegisterGlobalHandler" -ScriptBlock {
                    $self._globalHandlers[$ActionName] = $Handler
                    Write-Log -Level Debug -Message "Registered global handler for '$ActionName'"
                } -Context @{ ActionName = $ActionName } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "KeybindingService RegisterGlobalHandler error: $($Exception.Message)" -Data $Exception.Context
                }
            }
            
            HandleKey = {
                param($self, [System.ConsoleKeyInfo]$KeyInfo, [string]$Context = $null)
                Invoke-WithErrorHandling -Component "KeybindingService.HandleKey" -ScriptBlock {
                    foreach ($action in $self._keyMap.Keys) {
                        if ((& $self.IsAction -self $self -ActionName $action -KeyInfo $KeyInfo -Context $Context)) {
                            if ($self._globalHandlers.ContainsKey($action)) {
                                Write-Log -Level Debug -Message "Executing global handler for '$action'"
                                return (& $self._globalHandlers[$action] -KeyInfo $KeyInfo -Context $Context)
                            }
                            return $action
                        }
                    }
                    return $null
                } -Context @{ KeyInfo = $KeyInfo; Context = $Context } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "KeybindingService HandleKey error: $($Exception.Message)" -Data $Exception.Context
                    return $null
                }
            }
            
            PushContext = {
                param($self, [string]$Context)
                Invoke-WithErrorHandling -Component "KeybindingService.PushContext" -ScriptBlock {
                    $self._contextStack += $Context
                    Write-Log -Level Debug -Message "Pushed keybinding context: $Context"
                } -Context @{ Context = $Context } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "KeybindingService PushContext error: $($Exception.Message)" -Data $Exception.Context
                }
            }
            
            PopContext = {
                param($self)
                Invoke-WithErrorHandling -Component "KeybindingService.PopContext" -ScriptBlock {
                    if ($self._contextStack.Count -gt 0) {
                        $context = $self._contextStack[-1]
                        $self._contextStack = $self._contextStack[0..($self._contextStack.Count - 2)]
                        Write-Log -Level Debug -Message "Popped keybinding context: $context"
                        return $context
                    }
                    return $null
                } -Context @{} -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "KeybindingService PopContext error: $($Exception.Message)" -Data $Exception.Context
                    return $null
                }
            }
            
            GetCurrentContext = {
                param($self)
                Invoke-WithErrorHandling -Component "KeybindingService.GetCurrentContext" -ScriptBlock {
                    if ($self._contextStack.Count -gt 0) { return $self._contextStack[-1] }
                    return $null
                } -Context @{} -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "KeybindingService GetCurrentContext error: $($Exception.Message)" -Data $Exception.Context
                    return $null
                }
            }
            
            GetAllBindings = {
                param($self, [bool]$GroupByCategory = $false)
                Invoke-WithErrorHandling -Component "KeybindingService.GetAllBindings" -ScriptBlock {
                    if (-not $GroupByCategory) { return $self._keyMap }
                    $grouped = @{}
                    foreach ($action in $self._keyMap.Keys) {
                        $parts = $action.Split('.')
                        $category = if ($parts.Count -gt 1) { $parts[0] } else { "General" }
                        if (-not $grouped.ContainsKey($category)) { $grouped[$category] = @{} }
                        $grouped[$category][$action] = $self._keyMap[$action]
                    }
                    return $grouped
                } -Context @{ GroupByCategory = $GroupByCategory } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "KeybindingService GetAllBindings error: $($Exception.Message)" -Data $Exception.Context
                    return @{}
                }
            }
            
            ExportBindings = {
                param($self, [string]$Path)
                Invoke-WithErrorHandling -Component "KeybindingService.ExportBindings" -ScriptBlock {
                    $self._keyMap | ConvertTo-Json -Depth 3 | Out-File -FilePath $Path
                    Write-Log -Level Info -Message "Exported keybindings to: $Path"
                } -Context @{ FilePath = $Path } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "KeybindingService ExportBindings error: $($Exception.Message)" -Data $Exception.Context
                }
            }
            
            ImportBindings = {
                param($self, [string]$Path)
                Invoke-WithErrorHandling -Component "KeybindingService.ImportBindings" -ScriptBlock {
                    if (Test-Path $Path) {
                        $imported = Get-Content $Path | ConvertFrom-Json
                        foreach ($prop in $imported.PSObject.Properties) {
                            $self._keyMap[$prop.Name] = @{
                                Key = $prop.Value.Key
                                Modifiers = $prop.Value.Modifiers
                            }
                        }
                        Write-Log -Level Info -Message "Imported keybindings from: $Path"
                    }
                } -Context @{ FilePath = $Path } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "KeybindingService ImportBindings error: $($Exception.Message)" -Data $Exception.Context
                }
            }
        }
        
        return $service
    } -Context @{ CustomBindings = $CustomBindings; EnableChords = $EnableChords } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to initialize Keybinding Service: $($Exception.Message)" -Data $Exception.Context
        return $null
    }
}

Export-ModuleMember -Function "Initialize-KeybindingService"
@{
    # Module manifest for navigation service
    RootModule = 'navigation.psm1'
    ModuleVersion = '1.0.0'
    GUID = 'b2c3d4e5-6f7a-8b9c-0d1e-2f3a4b5c6d7e'
    Author = 'PMC Terminal Team'
    CompanyName = 'PMC Terminal'
    Copyright = '(c) 2025 PMC Terminal. All rights reserved.'
    Description = 'Centralized navigation service with routing and breadcrumbs for PMC Terminal'
    
    # Minimum PowerShell version
    PowerShellVersion = '5.1'
    
    # Functions to export
    FunctionsToExport = @('Initialize-NavigationService')
    
    # Variables to export
    VariablesToExport = @()
    
    # Aliases to export
    AliasesToExport = @()
    
    # Cmdlets to export
    CmdletsToExport = @()
    
    # Required modules
    RequiredModules = @(
        @{ ModuleName = 'tui-engine-v2'; ModuleVersion = '1.0.0' },
        @{ ModuleName = 'dialog-system'; ModuleVersion = '1.0.0' }
    )
    
    # Module dependencies that must be loaded
    NestedModules = @()
    
    # Private data
    PrivateData = @{
        PSData = @{
            Tags = @('Navigation', 'Routing', 'TUI', 'PMC')
            ProjectUri = 'https://github.com/pmc-terminal/pmc-terminal'
            ReleaseNotes = 'Initial release of navigation service with route guards and breadcrumbs'
        }
    }
}
# FILE: services/navigation.psm1
# PURPOSE: Decouples screens by managing all navigation through a centralized route map.

function Initialize-NavigationService {
    param(
        [hashtable]$CustomRoutes = @{},
        [bool]$EnableBreadcrumbs = $true
    )
    Invoke-WithErrorHandling -Component "NavigationService.Initialize" -ScriptBlock {
        # Default routes - can be overridden by CustomRoutes
        $defaultRoutes = @{
            "/dashboard" = @{ 
                Factory = { Get-DashboardScreen }
                Title = "Dashboard"
                RequiresAuth = $false
            }
            "/tasks" = @{ 
                Factory = { Get-TaskManagementScreen }
                Title = "Task Management"
                RequiresAuth = $false
            }
            "/timer/start" = @{ 
                Factory = { Get-TimerStartScreen }
                Title = "Timer"
                RequiresAuth = $false
            }
            "/timer/manage" = @{
                Factory = { Get-TimerManagementScreen }
                Title = "Timer Management"
                RequiresAuth = $false
            }
            "/reports" = @{ 
                Factory = { Get-ReportsScreen }
                Title = "Reports"
                RequiresAuth = $false
            }
            "/settings" = @{ 
                Factory = { Get-SettingsScreen }
                Title = "Settings"
                RequiresAuth = $false
            }
            "/projects" = @{ 
                Factory = { Get-ProjectManagementScreen }
                Title = "Projects"
                RequiresAuth = $false
            }
            "/log" = @{ 
                Factory = { Get-DebugLogScreen }
                Title = "Debug Log"
                RequiresAuth = $false
            }
            "/simple-test" = @{ # ADDED THIS ROUTE
                Factory = { Get-SimpleTestScreen }
                Title = "Simple Test"
                RequiresAuth = $false
            }
        }
        
        # Merge custom routes
        $routes = $defaultRoutes
        foreach ($key in $CustomRoutes.Keys) {
            $routes[$key] = $CustomRoutes[$key]
        }
        
        $service = @{
            _routes = $routes
            _history = @()  # Navigation history for back button
            _breadcrumbs = @()  # For UI breadcrumb display
            _beforeNavigate = @()  # Navigation guards
            _afterNavigate = @()  # Navigation hooks
            
            GoTo = {
                param(
                    $self,
                    [string]$Path,
                    [hashtable]$Params = @{},
                    [hashtable]$Services = $null
                )
                Invoke-WithErrorHandling -Component "NavigationService.GoTo" -ScriptBlock {
                    if ([string]::IsNullOrWhiteSpace($Path)) {
                        Write-Log -Level Error -Message "Navigation path cannot be empty"
                        return $false
                    }
                    
                    # Normalize path
                    if (-not $Path.StartsWith("/")) { $Path = "/$Path" }
                    
                    # Check if route exists
                    if (-not $self._routes.ContainsKey($Path)) {
                        $availableRoutes = ($self._routes.Keys | Sort-Object) -join ", "
                        $msg = "Route not found: $Path. Available routes: $availableRoutes"
                        Write-Log -Level Error -Message $msg
                        Show-AlertDialog -Title "Navigation Error" -Message "The screen '$Path' does not exist."
                        return $false
                    }
                    
                    $route = $self._routes[$Path]
                    
                    # Run before navigation guards
                    foreach ($guard in $self._beforeNavigate) {
                        try {
                            $canNavigate = & $guard -Path $Path -Route $route -Params $Params
                            if (-not $canNavigate) {
                                Write-Log -Level Debug -Message "Navigation to '$Path' cancelled by guard"
                                return $false
                            }
                        } catch {
                            Write-Log -Level Error -Message "Navigation guard failed for path '$Path': $_" -Data @{ Path = $Path; Guard = $guard; Exception = $_ }
                            Show-AlertDialog -Title "Navigation Error" -Message "A navigation check failed. Cannot proceed."
                            return $false
                        }
                    }
                    
                    # Check authentication if required
                    if ($route.RequiresAuth -and -not (& $self._checkAuth -self $self)) {
                        Write-Log -Level Warning -Message "Navigation to '$Path' requires authentication"
                        Show-AlertDialog -Title "Access Denied" -Message "You must be logged in to access this screen."
                        return $false
                    }
                    
                    try {
                        # Pass Services to factory if provided
                        if ($Services) {
                            $screen = & $route.Factory -Services $Services
                        } else {
                            $screen = & $route.Factory
                        }
                        if (-not $screen) { throw "Screen factory returned null for route '$Path'" }
                        
                        # CRITICAL: Ensure screen has services stored
                        if ($Services -and -not $screen._services) {
                            $screen._services = $Services
                        }
                        
                        if ($screen.SetParams -and $Params.Count -gt 0) { 
                            try {
                                & $screen.SetParams -self $screen -Params $Params 
                            } catch {
                                Write-Log -Level Error -Message "Screen SetParams failed for '$Path': $_" -Data @{ Path = $Path; Params = $Params; Exception = $_ }
                            }
                        }
                        
                        $self._history += @{ Path = $Path; Timestamp = [DateTime]::UtcNow; Params = $Params }
                        if ($EnableBreadcrumbs) { $self._breadcrumbs += @{ Path = $Path; Title = $route.Title ?? $Path } }
                        
                        Push-Screen -Screen $screen
                        
                        foreach ($hook in $self._afterNavigate) { 
                            try {
                                & $hook -Path $Path -Screen $screen 
                            } catch {
                                Write-Log -Level Error -Message "After navigation hook failed for path '$Path': $_" -Data @{ Path = $Path; Hook = $hook; Exception = $_ }
                            }
                        }
                        
                        Write-Log -Level Info -Message "Navigated to: $Path"
                        return $true
                    }
                    catch {
                        throw [NavigationException]::new(
                            "Failed to create or navigate to screen for route '$Path'",
                            @{
                                Route = $Path
                                RouteConfig = $route
                                OriginalException = $_
                            }
                        )
                    }
                } -Context @{ Path = $Path; Params = $Params } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "NavigationService GoTo error for path '$($Exception.Context.Path)': $($Exception.Message)" -Data $Exception.Context
                    Show-AlertDialog -Title "Navigation Error" -Message "Failed to navigate to '$($Exception.Context.Path)': $($Exception.Message)"
                    return $false
                }
            }
            
            Back = { 
                param($self, [int]$Steps = 1)
                Invoke-WithErrorHandling -Component "NavigationService.Back" -ScriptBlock {
                    for ($i = 0; $i -lt $Steps; $i++) {
                        if ($global:TuiState.ScreenStack.Count -le 1) {
                            Write-Log -Level Debug -Message "Cannot go back - at root screen"
                            return $false
                        }
                        Pop-Screen
                        if ($EnableBreadcrumbs -and $self._breadcrumbs.Count -gt 0) {
                            $self._breadcrumbs = $self._breadcrumbs[0..($self._breadcrumbs.Count - 2)]
                        }
                    }
                    return $true
                } -Context @{ Steps = $Steps } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "NavigationService Back error: $($Exception.Message)" -Data $Exception.Context
                    return $false
                }
            }
            
            GetCurrentPath = {
                param($self)
                Invoke-WithErrorHandling -Component "NavigationService.GetCurrentPath" -ScriptBlock {
                    if ($self._history.Count -eq 0) { return "/" }
                    return $self._history[-1].Path
                } -Context @{} -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "NavigationService GetCurrentPath error: $($Exception.Message)" -Data $Exception.Context
                    return "/"
                }
            }
            
            GetBreadcrumbs = {
                param($self)
                Invoke-WithErrorHandling -Component "NavigationService.GetBreadcrumbs" -ScriptBlock {
                    return $self._breadcrumbs
                } -Context @{} -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "NavigationService GetBreadcrumbs error: $($Exception.Message)" -Data $Exception.Context
                    return @()
                }
            }
            
            AddRoute = {
                param($self, [string]$Path, [hashtable]$RouteConfig)
                Invoke-WithErrorHandling -Component "NavigationService.AddRoute" -ScriptBlock {
                    if (-not $RouteConfig.Factory) { throw "Route must have a Factory scriptblock" }
                    $self._routes[$Path] = $RouteConfig
                    Write-Log -Level Debug -Message "Added route: $Path"
                } -Context @{ Path = $Path; RouteConfig = $RouteConfig } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "NavigationService AddRoute error for path '$($Exception.Context.Path)': $($Exception.Message)" -Data $Exception.Context
                }
            }
            
            RegisterRoute = {
                param($self, [string]$Path, [scriptblock]$ScreenFactory)
                Invoke-WithErrorHandling -Component "NavigationService.RegisterRoute" -ScriptBlock {
                    # Convert the simpler RegisterRoute format to the AddRoute format
                    $routeConfig = @{
                        Factory = $ScreenFactory
                        Title = $Path.Substring(1).Replace('/', ' ').Replace('-', ' ')
                        RequiresAuth = $false
                    }
                    # Call AddRoute with the proper format
                    & $self.AddRoute -self $self -Path $Path -RouteConfig $routeConfig
                    Write-Log -Level Debug -Message "Registered route: $Path"
                } -Context @{ Path = $Path } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "NavigationService RegisterRoute error for path '$($Exception.Context.Path)': $($Exception.Message)" -Data $Exception.Context
                }
            }
            
            RemoveRoute = {
                param($self, [string]$Path)
                Invoke-WithErrorHandling -Component "NavigationService.RemoveRoute" -ScriptBlock {
                    $self._routes.Remove($Path)
                    Write-Log -Level Debug -Message "Removed route: $Path"
                } -Context @{ Path = $Path } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "NavigationService RemoveRoute error for path '$($Exception.Context.Path)': $($Exception.Message)" -Data $Exception.Context
                }
            }
            
            AddBeforeNavigateGuard = {
                param($self, [scriptblock]$Guard)
                Invoke-WithErrorHandling -Component "NavigationService.AddBeforeNavigateGuard" -ScriptBlock {
                    $self._beforeNavigate += $Guard
                } -Context @{} -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "NavigationService AddBeforeNavigateGuard error: $($Exception.Message)" -Data $Exception.Context
                }
            }
            
            AddAfterNavigateHook = {
                param($self, [scriptblock]$Hook)
                Invoke-WithErrorHandling -Component "NavigationService.AddAfterNavigateHook" -ScriptBlock {
                    $self._afterNavigate += $Hook
                } -Context @{} -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "NavigationService AddAfterNavigateHook error: $($Exception.Message)" -Data $Exception.Context
                }
            }
            
            _checkAuth = {
                param($self)
                Invoke-WithErrorHandling -Component "NavigationService._checkAuth" -ScriptBlock {
                    # Placeholder for authentication check
                    return $true
                } -Context @{} -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "NavigationService _checkAuth error: $($Exception.Message)" -Data $Exception.Context
                    return $false
                }
            }
            
            GetRoutes = {
                param($self)
                Invoke-WithErrorHandling -Component "NavigationService.GetRoutes" -ScriptBlock {
                    return $self._routes.Keys | Sort-Object
                } -Context @{} -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "NavigationService GetRoutes error: $($Exception.Message)" -Data $Exception.Context
                    return @()
                }
            }
            
            IsValidRoute = {
                param($self, [string]$Path)
                Invoke-WithErrorHandling -Component "NavigationService.IsValidRoute" -ScriptBlock {
                    return $self._routes.ContainsKey($Path)
                } -Context @{ Path = $Path } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "NavigationService IsValidRoute error for path '$($Exception.Context.Path)': $($Exception.Message)" -Data $Exception.Context
                    return $false
                }
            }
        }
        
        return $service
    } -Context @{ CustomRoutes = $CustomRoutes; EnableBreadcrumbs = $EnableBreadcrumbs } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to initialize Navigation Service: $($Exception.Message)" -Data $Exception.Context
        return $null
    }
}

Export-ModuleMember -Function "Initialize-NavigationService"
# FILE: utilities/focus-manager.psm1
# PURPOSE: Provides the single source of truth for component focus management with scope support.

$script:Focus = @{
    FocusedComponent = $null 
    TabOrder = @()
    ActiveScope = $null
    History = @()  # Focus history for debugging
    ScopeStack = @()  # For nested focus scopes
}

function global:Request-Focus {
    param(
        [hashtable]$Component,
        [bool]$UpdateTabOrder = $false,
        [string]$Reason = "Direct"
    )
    Invoke-WithErrorHandling -Component "FocusManager.RequestFocus" -ScriptBlock {
        # Validate component
        if ($Component -and -not $Component.IsFocusable) {
            Write-Log -Level Debug -Message "Cannot focus non-focusable component: $($Component.Name ?? $Component.Type)"
            return $false
        }
        
        if ($Component -and -not $Component.Visible) {
            Write-Log -Level Debug -Message "Cannot focus invisible component: $($Component.Name ?? $Component.Type)"
            return $false
        }
        
        # Handle losing focus on previous component
        $oldFocused = $script:Focus.FocusedComponent
        if ($oldFocused -and ($oldFocused -ne $Component)) {
            $oldFocused.IsFocused = $false
            
            if ($oldFocused.OnBlur) {
                try {
                    & $oldFocused.OnBlur -self $oldFocused
                } catch {
                    Write-Log -Level Error -Message "Error in OnBlur handler for '$($oldFocused.Name ?? $oldFocused.Type)': $_" -Data @{ Component = $oldFocused.Name; Exception = $_ }
                }
            }
            
            # Fire blur event
            if (Get-Command -Name "Publish-Event" -ErrorAction SilentlyContinue) {
                Publish-Event -EventName "Component.Blur" -Data @{ Component = $oldFocused }
            }
        }
        
        # Update focus scope if needed
        $newScope = if ($Component) { Get-FocusScope -Component $Component } else { $null }
        if ($newScope -ne $script:Focus.ActiveScope) {
            # Leave old scope
            if ($script:Focus.ActiveScope -and $script:Focus.ActiveScope.OnLeaveFocusScope) {
                try {
                    & $script:Focus.ActiveScope.OnLeaveFocusScope -self $script:Focus.ActiveScope
                } catch {
                    Write-Log -Level Error -Message "Error in OnLeaveFocusScope handler for '$($script:Focus.ActiveScope.Name ?? $script:Focus.ActiveScope.Type)': $_" -Data @{ Component = $script:Focus.ActiveScope.Name; Exception = $_ }
                }
            }
            
            $script:Focus.ActiveScope = $newScope
            
            # Enter new scope
            if ($newScope -and $newScope.OnEnterFocusScope) {
                try {
                    & $newScope.OnEnterFocusScope -self $newScope
                } catch {
                    Write-Log -Level Error -Message "Error in OnEnterFocusScope handler for '$($newScope.Name ?? $newScope.Type)': $_" -Data @{ Component = $newScope.Name; Exception = $_ }
                }
            }
        }
        
        # Set new focus
        $script:Focus.FocusedComponent = $Component
        
        # Update global state if available
        if ($global:TuiState) {
            $global:TuiState.FocusedComponent = $Component
        }
        
        # Update history
        $script:Focus.History += @{
            Component = $Component
            Timestamp = [DateTime]::UtcNow
            Reason = $Reason
        }
        if ($script:Focus.History.Count -gt 50) {
            $script:Focus.History = $script:Focus.History[-50..-1]
        }
        
        if ($Component) {
            $Component.IsFocused = $true
            
            # Call focus handler
            if ($Component.OnFocus) {
                try {
                    & $Component.OnFocus -self $Component
                } catch {
                    Write-Log -Level Error -Message "Error in OnFocus handler for '$($Component.Name ?? $Component.Type)': $_" -Data @{ Component = $Component.Name; Exception = $_ }
                }
            }
            
            # Fire focus event
            if (Get-Command -Name "Publish-Event" -ErrorAction SilentlyContinue) {
                Publish-Event -EventName "Component.Focus" -Data @{ Component = $Component }
            }
            
            # Update tab order if requested
            if ($UpdateTabOrder) {
                Update-TabOrder -FocusedComponent $Component
            }
        }
        
        # Request screen refresh
        if (Get-Command -Name "Request-TuiRefresh" -ErrorAction SilentlyContinue) {
            Request-TuiRefresh
        }
        
        if ($Component) {
            Write-Log -Level Debug -Message "Focused: $($Component.Name ?? $Component.Type) (Reason: $Reason)"
        } else {
            Write-Log -Level Debug -Message "Cleared focus (Reason: $Reason)"
        }
        
        return $true
    } -Context @{ Component = $Component.Name; Reason = $Reason } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "FocusManager RequestFocus error for '$($Exception.Context.Component)': $($Exception.Message)" -Data $Exception.Context
        return $false
    }
}

function global:Clear-Focus {
    Invoke-WithErrorHandling -Component "FocusManager.ClearFocus" -ScriptBlock {
        Request-Focus -Component $null -Reason "Clear"
    } -Context @{} -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "FocusManager ClearFocus error: $($Exception.Message)" -Data $Exception.Context
    }
}

function global:Move-Focus {
    param(
        [bool]$Reverse = $false,
        [bool]$Wrap = $true
    )
    Invoke-WithErrorHandling -Component "FocusManager.MoveFocus" -ScriptBlock {
        # Check if active scope handles its own focus movement
        if ($script:Focus.ActiveScope -and $script:Focus.ActiveScope.HandleScopedFocus) {
            try {
                $handled = & $script:Focus.ActiveScope.HandleScopedFocus -self $script:Focus.ActiveScope -Reverse $Reverse
                if ($handled) {
                    return $true
                }
            } catch {
                Write-Log -Level Error -Message "Active focus scope HandleScopedFocus failed for '$($script:Focus.ActiveScope.Name ?? $script:Focus.ActiveScope.Type)': $_" -Data @{ Scope = $script:Focus.ActiveScope.Name; Reverse = $Reverse; Exception = $_ }
            }
        }
        
        # No focusable components
        if ($script:Focus.TabOrder.Count -eq 0) {
            Write-Log -Level Debug -Message "No focusable components in tab order"
            return $false
        }
        
        # Find current index
        $currentIndex = [array]::IndexOf($script:Focus.TabOrder, $script:Focus.FocusedComponent)
        
        # If no current focus, focus first/last based on direction
        if ($currentIndex -eq -1) {
            $targetIndex = if ($Reverse) { $script:Focus.TabOrder.Count - 1 } else { 0 }
            Request-Focus -Component $script:Focus.TabOrder[$targetIndex] -Reason "TabNavigation"
            return $true
        }
        
        # Calculate next index
        if ($Reverse) {
            $nextIndex = $currentIndex - 1
            if ($nextIndex -lt 0) {
                $nextIndex = if ($Wrap) { $script:Focus.TabOrder.Count - 1 } else { 0 }
            }
        } else {
            $nextIndex = $currentIndex + 1
            if ($nextIndex -ge $script:Focus.TabOrder.Count) {
                $nextIndex = if ($Wrap) { 0 } else { $script:Focus.TabOrder.Count - 1 }
            }
        }
        
        # Skip invisible or disabled components
        $attempts = 0
        while ($attempts -lt $script:Focus.TabOrder.Count) {
            $candidate = $script:Focus.TabOrder[$nextIndex]
            
            if ($candidate.Visible -and $candidate.IsFocusable -and 
                (-not $candidate.PSObject.Properties['IsEnabled'] -or $candidate.IsEnabled)) {
                Request-Focus -Component $candidate -Reason "TabNavigation"
                return $true
            }
            
            # Move to next candidate
            if ($Reverse) {
                $nextIndex--
                if ($nextIndex -lt 0) {
                    $nextIndex = if ($Wrap) { $script:Focus.TabOrder.Count - 1 } else { 0 }
                }
            } else {
                $nextIndex++
                if ($nextIndex -ge $script:Focus.TabOrder.Count) {
                    $nextIndex = if ($Wrap) { 0 } else { $script:Focus.TabOrder.Count - 1 }
                }
            }
            
            $attempts++
        }
        
        Write-Log -Level Debug -Message "No valid focus target found"
        return $false
    } -Context @{ Reverse = $Reverse; Wrap = $Wrap; CurrentFocused = $script:Focus.FocusedComponent.Name } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "FocusManager MoveFocus error: $($Exception.Message)" -Data $Exception.Context
        return $false
    }
}

function global:Get-FocusedComponent {
    Invoke-WithErrorHandling -Component "FocusManager.GetFocusedComponent" -ScriptBlock {
        return $script:Focus.FocusedComponent
    } -Context @{} -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "FocusManager GetFocusedComponent error: $($Exception.Message)" -Data $Exception.Context
        return $null
    }
}

function global:Get-FocusHistory {
    Invoke-WithErrorHandling -Component "FocusManager.GetFocusHistory" -ScriptBlock {
        return $script:Focus.History
    } -Context @{} -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "FocusManager GetFocusHistory error: $($Exception.Message)" -Data $Exception.Context
        return @()
    }
}

# --- FIX: REMOVED 'private:' ---
function Get-FocusScope {
    param($Component)
    Invoke-WithErrorHandling -Component "FocusManager.GetFocusScope" -ScriptBlock {
        $current = $Component
        while ($current) {
            if ($current.IsFocusScope) {
                return $current
            }
            $current = $current.Parent
        }
        
        return $null
    } -Context @{ Component = $Component.Name } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "FocusManager GetFocusScope error for '$($Exception.Context.Component)': $($Exception.Message)" -Data $Exception.Context
        return $null
    }
}

function global:Push-FocusScope {
    param([hashtable]$Scope)
    Invoke-WithErrorHandling -Component "FocusManager.PushFocusScope" -ScriptBlock {
        if (-not $Scope.IsFocusScope) {
            $Scope.IsFocusScope = $true
        }
        
        $script:Focus.ScopeStack += $Scope
        $script:Focus.ActiveScope = $Scope
        
        Write-Log -Level Debug -Message "Pushed focus scope: $($Scope.Name ?? $Scope.Type)"
    } -Context @{ Scope = $Scope.Name } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "FocusManager PushFocusScope error for '$($Exception.Context.Scope)': $($Exception.Message)" -Data $Exception.Context
    }
}

function global:Pop-FocusScope {
    Invoke-WithErrorHandling -Component "FocusManager.PopFocusScope" -ScriptBlock {
        if ($script:Focus.ScopeStack.Count -eq 0) {
            return $null
        }
        
        $poppedScope = $script:Focus.ScopeStack[-1]
        $script:Focus.ScopeStack = $script:Focus.ScopeStack[0..($script:Focus.ScopeStack.Count - 2)]
        
        # Restore previous scope
        if ($script:Focus.ScopeStack.Count -gt 0) {
            $script:Focus.ActiveScope = $script:Focus.ScopeStack[-1]
        } else {
            $script:Focus.ActiveScope = $null
        }
        
        Write-Log -Level Debug -Message "Popped focus scope: $($poppedScope.Name ?? $poppedScope.Type)"
        
        return $poppedScope
    } -Context @{} -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "FocusManager PopFocusScope error: $($Exception.Message)" -Data $Exception.Context
        return $null
    }
}

# --- FIX: REMOVED 'private:' ---
function Update-TabOrder {
    param($FocusedComponent)
    Invoke-WithErrorHandling -Component "FocusManager.UpdateTabOrder" -ScriptBlock {
        # If component is already in tab order, no need to update
        if ($FocusedComponent -in $script:Focus.TabOrder) {
            return
        }
        
        # Rebuild tab order
        Register-ScreenForFocus -Screen $global:TuiState.CurrentScreen
    } -Context @{ FocusedComponent = $FocusedComponent.Name } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "FocusManager UpdateTabOrder error: $($Exception.Message)" -Data $Exception.Context
    }
}

# --- FIX: REMOVED 'private:' ---
function Register-ScreenForFocus {
    param($Screen)
    Invoke-WithErrorHandling -Component "FocusManager.RegisterScreenForFocus" -ScriptBlock {
        $script:Focus.TabOrder = @()
        $script:Focus.ActiveScope = $null
        
        if (-not $Screen) {
            Request-Focus -Component $null -Reason "NoScreen"
            return
        }
        
        # Find all focusable components
        $focusableComponents = @()
        
        $FindFocusable = $null
        $FindFocusable = {
            param($component, $depth = 0)
            
            if (-not $component) { return }
            
            # Add focusable components
            if ($component.IsFocusable -and $component.Visible) {
                $focusableComponents += @{
                    Component = $component
                    Depth = $depth
                    TabIndex = $component.TabIndex ?? 0
                    Position = @{
                        Y = $component.Y ?? 0
                        X = $component.X ?? 0
                    }
                }
            }
            
            # Process panel children
            if ($component.Children) {
                foreach ($child in $component.Children) {
                    & $FindFocusable -component $child -depth ($depth + 1)
                }
            }
            
            # Process named children (for backward compatibility)
            if ($component.Components) {
                foreach ($child in $component.Components.Values) {
                    & $FindFocusable -component $child -depth ($depth + 1)
                }
            }
        }.GetNewClosure()
        
        # Start from screen components and children
        if ($Screen.Children) {
            foreach ($comp in $Screen.Children) {
                & $FindFocusable -component $comp
            }
        }
        
        # Also check legacy Components collection
        if ($Screen.Components) {
            foreach ($comp in $Screen.Components.Values) {
                & $FindFocusable -component $comp
            }
        }
        
        # Sort by TabIndex, then by position (top to bottom, left to right)
        $script:Focus.TabOrder = $focusableComponents | 
            Sort-Object { $_.TabIndex }, { $_.Position.Y }, { $_.Position.X } |
            ForEach-Object { $_.Component }
        
        Write-Log -Level Debug -Message "Registered $($script:Focus.TabOrder.Count) focusable components"
        
        # Focus first component if none focused
        if ($script:Focus.TabOrder.Count -gt 0 -and -not ($script:Focus.FocusedComponent -in $script:Focus.TabOrder)) {
            Request-Focus -Component $script:Focus.TabOrder[0] -Reason "InitialFocus"
        } elseif ($script:Focus.TabOrder.Count -eq 0) {
            Request-Focus -Component $null -Reason "NoFocusableComponents"
        }
    } -Context @{ ScreenName = $Screen.Name } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "FocusManager RegisterScreenForFocus error for '$($Exception.Context.ScreenName)': $($Exception.Message)" -Data $Exception.Context
    }
}

function global:Initialize-FocusManager {
    Invoke-WithErrorHandling -Component "FocusManager.Initialize" -ScriptBlock {
        # Subscribe to screen events
        if (Get-Command -Name "Subscribe-Event" -ErrorAction SilentlyContinue) {
            Subscribe-Event -EventName "Screen.Pushed" -Handler {
                param($Event)
                Invoke-WithErrorHandling -Component "FocusManager.ScreenPushedHandler" -ScriptBlock {
                    Register-ScreenForFocus -Screen $Event.Data.Screen
                } -Context @{ EventData = $Event.Data } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "FocusManager Screen.Pushed event handler error: $($Exception.Message)" -Data $Exception.Context
                }
            }
            
            Subscribe-Event -EventName "Screen.Popped" -Handler {
                param($Event)
                Invoke-WithErrorHandling -Component "FocusManager.ScreenPoppedHandler" -ScriptBlock {
                    # Clear focus scopes
                    $script:Focus.ScopeStack = @()
                    $script:Focus.ActiveScope = $null
                    
                    # Re-register for new top screen
                    if ($global:TuiState -and $global:TuiState.CurrentScreen) {
                        Register-ScreenForFocus -Screen $global:TuiState.CurrentScreen
                    }
                } -Context @{ EventData = $Event.Data } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "FocusManager Screen.Popped event handler error: $($Exception.Message)" -Data $Exception.Context
                }
            }
            
            Subscribe-Event -EventName "Component.VisibilityChanged" -Handler {
                param($Event)
                Invoke-WithErrorHandling -Component "FocusManager.ComponentVisibilityChangedHandler" -ScriptBlock {
                    $component = $Event.Data.Component
                    
                    # If hiding focused component, move focus
                    if (-not $component.Visible -and $component -eq $script:Focus.FocusedComponent) {
                        Move-Focus
                    }
                    
                    # Update tab order if visibility changed
                    if ($global:TuiState -and $global:TuiState.CurrentScreen) {
                        Register-ScreenForFocus -Screen $global:TuiState.CurrentScreen
                    }
                } -Context @{ EventData = $Event.Data } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "FocusManager Component.VisibilityChanged event handler error: $($Exception.Message)" -Data $Exception.Context
                }
            }
        }
        
        Write-Log -Level Info -Message "Focus Manager initialized"
    } -Context @{} -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to initialize Focus Manager: $($Exception.Message)" -Data $Exception.Context
    }
}

# Utility functions for components
function global:Set-ComponentFocusable {
    param(
        [hashtable]$Component,
        [bool]$IsFocusable
    )
    Invoke-WithErrorHandling -Component "FocusManager.SetComponentFocusable" -ScriptBlock {
        $wasFocusable = $Component.IsFocusable
        $Component.IsFocusable = $IsFocusable
        
        # If making unfocusable and it's currently focused, clear focus
        if ($wasFocusable -and -not $IsFocusable -and $Component -eq $script:Focus.FocusedComponent) {
            Move-Focus
        }
        
        # Update tab order
        if ($global:TuiState -and $global:TuiState.CurrentScreen) {
            Register-ScreenForFocus -Screen $global:TuiState.CurrentScreen
        }
    } -Context @{ Component = $Component.Name; IsFocusable = $IsFocusable } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "FocusManager SetComponentFocusable error for '$($Exception.Context.Component)': $($Exception.Message)" -Data $Exception.Context
    }
}

function global:Focus-NextInScope {
    param([hashtable]$Scope)
    Invoke-WithErrorHandling -Component "FocusManager.FocusNextInScope" -ScriptBlock {
        if (-not $Scope -or -not $Scope.IsFocusScope) {
            return $false
        }
        
        # Find focusable children within scope
        $scopeFocusable = @()
        
        $FindScopeFocusable = {
            param($component)
            
            if ($component.IsFocusable -and $component.Visible) {
                $scopeFocusable += $component
            }
            
            if ($component.Children -and $component -ne $Scope) {
                foreach ($child in $component.Children) {
                    & $FindScopeFocusable -component $child
                }
            }
        }
        
        & $FindScopeFocusable -component $Scope
        
        if ($scopeFocusable.Count -eq 0) {
            return $false
        }
        
        # Find current index
        $currentIndex = [array]::IndexOf($scopeFocusable, $script:Focus.FocusedComponent)
        $nextIndex = ($currentIndex + 1) % $scopeFocusable.Count
        
        Request-Focus -Component $scopeFocusable[$nextIndex] -Reason "ScopeNavigation"
        return $true
    } -Context @{ Scope = $Scope.Name } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "FocusManager FocusNextInScope error for '$($Exception.Context.Scope)': $($Exception.Message)" -Data $Exception.Context
        return $false
    }
}

Export-ModuleMember -Function @(
    "Initialize-FocusManager",
    "Request-Focus", 
    "Clear-Focus",
    "Move-Focus",
    "Get-FocusedComponent",
    "Get-FocusHistory",
    "Push-FocusScope",
    "Pop-FocusScope",
    "Set-ComponentFocusable",
    "Focus-NextInScope"
)
# Layout Manager Utility Module
# Provides helper functions for component positioning and layout management

function global:New-TuiLayoutManager {
    <#
    .SYNOPSIS
    Creates a layout manager for organizing components within a container
    
    .DESCRIPTION
    The layout manager helps with automatic positioning, spacing, and alignment of components.
    It provides various layout modes: Stack, Grid, Dock, and Manual.
    
    .PARAMETER Container
    A hashtable with X, Y, Width, Height properties defining the container bounds
    
    .PARAMETER Mode
    Layout mode: 'Stack', 'Grid', 'Dock', or 'Manual'
    
    .EXAMPLE
    $layout = New-TuiLayoutManager -Container @{X=0; Y=0; Width=80; Height=25} -Mode 'Stack'
    $layout.Add($component1)
    $layout.Add($component2)
    $layout.Apply()
    #>
    param(
        [hashtable]$Container = @{ X = 0; Y = 0; Width = 80; Height = 25 },
        [string]$Mode = 'Manual',
        [hashtable]$Options = @{}
    )
    
    $manager = @{
        Container = $Container
        Mode = $Mode
        Components = @()
        Options = @{
            # Stack options
            Direction = $Options.Direction ?? 'Vertical'  # 'Vertical' or 'Horizontal'
            Spacing = $Options.Spacing ?? 1
            Padding = $Options.Padding ?? @{ Top = 0; Right = 0; Bottom = 0; Left = 0 }
            Alignment = $Options.Alignment ?? 'Left'  # 'Left', 'Center', 'Right'
            
            # Grid options
            Columns = $Options.Columns ?? 2
            RowHeight = $Options.RowHeight ?? 5
            ColumnWidth = $Options.ColumnWidth ?? 20
            
            # Dock options
            FillLast = $Options.FillLast ?? $true
        }
        
        # Methods
        Add = {
            param($Component, [hashtable]$LayoutProps = @{})
            $this = $args[-1]
            $this.Components += @{
                Component = $Component
                LayoutProps = $LayoutProps
            }
        }.GetNewClosure()
        
        Clear = {
            $this = $args[-1]
            $this.Components = @()
        }.GetNewClosure()
        
        Apply = {
            $this = $args[-1]
            switch ($this.Mode) {
                'Stack' { & $this.ApplyStackLayout }
                'Grid' { & $this.ApplyGridLayout }
                'Dock' { & $this.ApplyDockLayout }
                'Manual' { # Do nothing - components use their existing positions }
            }
        }.GetNewClosure()
        
        ApplyStackLayout = {
            $this = $args[-1]
            $x = $this.Container.X + $this.Options.Padding.Left
            $y = $this.Container.Y + $this.Options.Padding.Top
            $maxWidth = $this.Container.Width - $this.Options.Padding.Left - $this.Options.Padding.Right
            $maxHeight = $this.Container.Height - $this.Options.Padding.Top - $this.Options.Padding.Bottom
            
            foreach ($item in $this.Components) {
                $comp = $item.Component
                
                # Apply alignment
                switch ($this.Options.Alignment) {
                    'Center' { $comp.X = $x + [Math]::Floor(($maxWidth - $comp.Width) / 2) }
                    'Right' { $comp.X = $x + $maxWidth - $comp.Width }
                    default { $comp.X = $x }
                }
                
                if ($this.Options.Direction -eq 'Vertical') {
                    $comp.Y = $y
                    $y += $comp.Height + $this.Options.Spacing
                } else {
                    $comp.Y = $y
                    $x += $comp.Width + $this.Options.Spacing
                }
            }
        }.GetNewClosure()
        
        ApplyGridLayout = {
            $this = $args[-1]
            $startX = $this.Container.X + $this.Options.Padding.Left
            $startY = $this.Container.Y + $this.Options.Padding.Top
            $cols = $this.Options.Columns
            
            for ($i = 0; $i -lt $this.Components.Count; $i++) {
                $comp = $this.Components[$i].Component
                $row = [Math]::Floor($i / $cols)
                $col = $i % $cols
                
                $comp.X = $startX + ($col * ($this.Options.ColumnWidth + $this.Options.Spacing))
                $comp.Y = $startY + ($row * ($this.Options.RowHeight + $this.Options.Spacing))
                
                # Optionally constrain size to grid cell
                if ($this.Components[$i].LayoutProps.ConstrainToCell) {
                    $comp.Width = [Math]::Min($comp.Width, $this.Options.ColumnWidth)
                    $comp.Height = [Math]::Min($comp.Height, $this.Options.RowHeight)
                }
            }
        }.GetNewClosure()
        
        ApplyDockLayout = {
            $this = $args[-1]
            $remainingX = $this.Container.X
            $remainingY = $this.Container.Y
            $remainingWidth = $this.Container.Width
            $remainingHeight = $this.Container.Height
            
            # Process in order: Top, Bottom, Left, Right, Fill
            $dockOrder = @('Top', 'Bottom', 'Left', 'Right', 'Fill')
            
            foreach ($dock in $dockOrder) {
                $items = $this.Components | Where-Object { $_.LayoutProps.Dock -eq $dock }
                
                foreach ($item in $items) {
                    $comp = $item.Component
                    
                    switch ($dock) {
                        'Top' {
                            $comp.X = $remainingX
                            $comp.Y = $remainingY
                            $comp.Width = $remainingWidth
                            $remainingY += $comp.Height
                            $remainingHeight -= $comp.Height
                        }
                        'Bottom' {
                            $comp.X = $remainingX
                            $comp.Y = $remainingY + $remainingHeight - $comp.Height
                            $comp.Width = $remainingWidth
                            $remainingHeight -= $comp.Height
                        }
                        'Left' {
                            $comp.X = $remainingX
                            $comp.Y = $remainingY
                            $comp.Height = $remainingHeight
                            $remainingX += $comp.Width
                            $remainingWidth -= $comp.Width
                        }
                        'Right' {
                            $comp.X = $remainingX + $remainingWidth - $comp.Width
                            $comp.Y = $remainingY
                            $comp.Height = $remainingHeight
                            $remainingWidth -= $comp.Width
                        }
                        'Fill' {
                            $comp.X = $remainingX
                            $comp.Y = $remainingY
                            $comp.Width = $remainingWidth
                            $comp.Height = $remainingHeight
                        }
                    }
                }
            }
        }.GetNewClosure()
        
        # Helper to calculate required size
        GetRequiredSize = {
            $this = $args[-1]
            $width = 0
            $height = 0
            
            switch ($this.Mode) {
                'Stack' {
                    if ($this.Options.Direction -eq 'Vertical') {
                        $width = ($this.Components | ForEach-Object { $_.Component.Width } | Measure-Object -Maximum).Maximum
                        $height = ($this.Components | ForEach-Object { $_.Component.Height } | Measure-Object -Sum).Sum
                        $height += ($this.Components.Count - 1) * $this.Options.Spacing
                    } else {
                        $width = ($this.Components | ForEach-Object { $_.Component.Width } | Measure-Object -Sum).Sum
                        $width += ($this.Components.Count - 1) * $this.Options.Spacing
                        $height = ($this.Components | ForEach-Object { $_.Component.Height } | Measure-Object -Maximum).Maximum
                    }
                }
                'Grid' {
                    $cols = $this.Options.Columns
                    $rows = [Math]::Ceiling($this.Components.Count / $cols)
                    $width = $cols * $this.Options.ColumnWidth + ($cols - 1) * $this.Options.Spacing
                    $height = $rows * $this.Options.RowHeight + ($rows - 1) * $this.Options.Spacing
                }
            }
            
            $width += $this.Options.Padding.Left + $this.Options.Padding.Right
            $height += $this.Options.Padding.Top + $this.Options.Padding.Bottom
            
            return @{ Width = $width; Height = $height }
        }.GetNewClosure()
    }
    
    # Bind methods to the manager instance
    $manager.Add = $manager.Add.Invoke(@($manager))
    $manager.Clear = $manager.Clear.Invoke(@($manager))
    $manager.Apply = $manager.Apply.Invoke(@($manager))
    $manager.ApplyStackLayout = $manager.ApplyStackLayout.Invoke(@($manager))
    $manager.ApplyGridLayout = $manager.ApplyGridLayout.Invoke(@($manager))
    $manager.ApplyDockLayout = $manager.ApplyDockLayout.Invoke(@($manager))
    $manager.GetRequiredSize = $manager.GetRequiredSize.Invoke(@($manager))
    
    return $manager
}

function global:Center-Component {
    <#
    .SYNOPSIS
    Centers a component within a container
    #>
    param(
        [hashtable]$Component,
        [hashtable]$Container = @{ X = 0; Y = 0; Width = $global:TuiState.BufferWidth; Height = $global:TuiState.BufferHeight }
    )
    
    $Component.X = $Container.X + [Math]::Floor(($Container.Width - $Component.Width) / 2)
    $Component.Y = $Container.Y + [Math]::Floor(($Container.Height - $Component.Height) / 2)
}

function global:Align-Components {
    <#
    .SYNOPSIS
    Aligns multiple components horizontally or vertically
    #>
    param(
        [hashtable[]]$Components,
        [string]$Direction = 'Horizontal',  # 'Horizontal' or 'Vertical'
        [string]$Alignment = 'Center',      # 'Top', 'Middle', 'Bottom' for horizontal; 'Left', 'Center', 'Right' for vertical
        [int]$Spacing = 2
    )
    
    if ($Components.Count -eq 0) { return }
    
    if ($Direction -eq 'Horizontal') {
        # Calculate total width needed
        $totalWidth = ($Components | ForEach-Object { $_.Width } | Measure-Object -Sum).Sum
        $totalWidth += ($Components.Count - 1) * $Spacing
        
        # Starting X position
        $currentX = switch ($Alignment) {
            'Left' { 0 }
            'Right' { $global:TuiState.BufferWidth - $totalWidth }
            default { [Math]::Floor(($global:TuiState.BufferWidth - $totalWidth) / 2) }
        }
        
        # Position each component
        foreach ($comp in $Components) {
            $comp.X = $currentX
            $currentX += $comp.Width + $Spacing
        }
    } else {
        # Calculate total height needed
        $totalHeight = ($Components | ForEach-Object { $_.Height } | Measure-Object -Sum).Sum
        $totalHeight += ($Components.Count - 1) * $Spacing
        
        # Starting Y position
        $currentY = switch ($Alignment) {
            'Top' { 0 }
            'Bottom' { $global:TuiState.BufferHeight - $totalHeight }
            default { [Math]::Floor(($global:TuiState.BufferHeight - $totalHeight) / 2) }
        }
        
        # Position each component
        foreach ($comp in $Components) {
            $comp.Y = $currentY
            $currentY += $comp.Height + $Spacing
        }
    }
}

function global:Create-ComponentGrid {
    <#
    .SYNOPSIS
    Arranges components in a grid layout
    #>
    param(
        [hashtable[]]$Components,
        [int]$Columns = 2,
        [int]$StartX = 0,
        [int]$StartY = 0,
        [int]$CellWidth = 20,
        [int]$CellHeight = 5,
        [int]$HorizontalSpacing = 2,
        [int]$VerticalSpacing = 1
    )
    
    for ($i = 0; $i -lt $Components.Count; $i++) {
        $row = [Math]::Floor($i / $Columns)
        $col = $i % $Columns
        
        $Components[$i].X = $StartX + ($col * ($CellWidth + $HorizontalSpacing))
        $Components[$i].Y = $StartY + ($row * ($CellHeight + $VerticalSpacing))
    }
}

Export-ModuleMember -Function @(
    'New-TuiLayoutManager',
    'Center-Component',
    'Align-Components',
    'Create-ComponentGrid'
)
# Component Positioning Helper Module
# Provides utilities for easier component placement and relative positioning

function global:New-TuiPositioner {
    <#
    .SYNOPSIS
    Creates a positioning helper for managing component placement
    
    .DESCRIPTION
    The positioner helps calculate positions for components relative to each other
    and handles common layout patterns like rows, columns, and grids.
    
    .PARAMETER Container
    Defines the bounding container for positioning
    
    .EXAMPLE
    $pos = New-TuiPositioner -Container @{X=0; Y=0; Width=80; Height=25}
    $button1Pos = $pos.NextInRow(10, 3)  # Width=10, Height=3
    $button2Pos = $pos.NextInRow(10, 3)  # Automatically positioned after button1
    #>
    param(
        [hashtable]$Container = @{ X = 0; Y = 0; Width = 80; Height = 25 },
        [hashtable]$Options = @{}
    )
    
    $positioner = @{
        Container = $Container
        CurrentX = $Container.X + ($Options.PaddingLeft ?? 0)
        CurrentY = $Container.Y + ($Options.PaddingTop ?? 0)
        RowHeight = 0
        Options = @{
            Spacing = $Options.Spacing ?? 1
            PaddingTop = $Options.PaddingTop ?? 0
            PaddingRight = $Options.PaddingRight ?? 0
            PaddingBottom = $Options.PaddingBottom ?? 0
            PaddingLeft = $Options.PaddingLeft ?? 0
        }
        
        # Reset to start of container
        Reset = {
            $this.CurrentX = $this.Container.X + $this.Options.PaddingLeft
            $this.CurrentY = $this.Container.Y + $this.Options.PaddingTop
            $this.RowHeight = 0
        }
        
        # Move to next row
        NewRow = {
            $this.CurrentX = $this.Container.X + $this.Options.PaddingLeft
            $this.CurrentY += $this.RowHeight + $this.Options.Spacing
            $this.RowHeight = 0
        }
        
        # Get next position in current row
        NextInRow = {
            param([int]$Width, [int]$Height)
            
            # Check if component fits in current row
            $maxX = $this.Container.X + $this.Container.Width - $this.Options.PaddingRight
            if (($this.CurrentX + $Width) -gt $maxX) {
                & $this.NewRow
            }
            
            $position = @{
                X = $this.CurrentX
                Y = $this.CurrentY
                Width = $Width
                Height = $Height
            }
            
            # Update position for next component
            $this.CurrentX += $Width + $this.Options.Spacing
            $this.RowHeight = [Math]::Max($this.RowHeight, $Height)
            
            return $position
        }
        
        # Get next position in current column
        NextInColumn = {
            param([int]$Width, [int]$Height)
            
            # Check if component fits in current column
            $maxY = $this.Container.Y + $this.Container.Height - $this.Options.PaddingBottom
            if (($this.CurrentY + $Height) -gt $maxY) {
                # Move to next column
                $this.CurrentY = $this.Container.Y + $this.Options.PaddingTop
                $this.CurrentX += $Width + $this.Options.Spacing
            }
            
            $position = @{
                X = $this.CurrentX
                Y = $this.CurrentY
                Width = $Width
                Height = $Height
            }
            
            # Update position for next component
            $this.CurrentY += $Height + $this.Options.Spacing
            
            return $position
        }
        
        # Position at specific coordinates
        At = {
            param([int]$X, [int]$Y, [int]$Width, [int]$Height)
            
            $this.CurrentX = $X + $Width + $this.Options.Spacing
            $this.CurrentY = $Y
            $this.RowHeight = $Height
            
            return @{
                X = $X
                Y = $Y
                Width = $Width
                Height = $Height
            }
        }
        
        # Position relative to another position
        RelativeTo = {
            param(
                [hashtable]$Reference,
                [string]$Direction = "Right",  # Right, Left, Above, Below
                [int]$Width,
                [int]$Height,
                [int]$Offset = $null
            )
            
            if ($null -eq $Offset) { $Offset = $this.Options.Spacing }
            
            $position = switch ($Direction) {
                "Right" {
                    @{
                        X = $Reference.X + $Reference.Width + $Offset
                        Y = $Reference.Y
                        Width = $Width
                        Height = $Height
                    }
                }
                "Left" {
                    @{
                        X = $Reference.X - $Width - $Offset
                        Y = $Reference.Y
                        Width = $Width
                        Height = $Height
                    }
                }
                "Below" {
                    @{
                        X = $Reference.X
                        Y = $Reference.Y + $Reference.Height + $Offset
                        Width = $Width
                        Height = $Height
                    }
                }
                "Above" {
                    @{
                        X = $Reference.X
                        Y = $Reference.Y - $Height - $Offset
                        Width = $Width
                        Height = $Height
                    }
                }
            }
            
            return $position
        }
        
        # Center component in container
        Center = {
            param([int]$Width, [int]$Height)
            
            return @{
                X = $this.Container.X + [Math]::Floor(($this.Container.Width - $Width) / 2)
                Y = $this.Container.Y + [Math]::Floor(($this.Container.Height - $Height) / 2)
                Width = $Width
                Height = $Height
            }
        }
        
        # Align to edges
        AlignTopLeft = {
            param([int]$Width, [int]$Height)
            return @{
                X = $this.Container.X + $this.Options.PaddingLeft
                Y = $this.Container.Y + $this.Options.PaddingTop
                Width = $Width
                Height = $Height
            }
        }
        
        AlignTopRight = {
            param([int]$Width, [int]$Height)
            return @{
                X = $this.Container.X + $this.Container.Width - $Width - $this.Options.PaddingRight
                Y = $this.Container.Y + $this.Options.PaddingTop
                Width = $Width
                Height = $Height
            }
        }
        
        AlignBottomLeft = {
            param([int]$Width, [int]$Height)
            return @{
                X = $this.Container.X + $this.Options.PaddingLeft
                Y = $this.Container.Y + $this.Container.Height - $Height - $this.Options.PaddingBottom
                Width = $Width
                Height = $Height
            }
        }
        
        AlignBottomRight = {
            param([int]$Width, [int]$Height)
            return @{
                X = $this.Container.X + $this.Container.Width - $Width - $this.Options.PaddingRight
                Y = $this.Container.Y + $this.Container.Height - $Height - $this.Options.PaddingBottom
                Width = $Width
                Height = $Height
            }
        }
    }
    
    return $positioner
}

function global:Position-Components {
    <#
    .SYNOPSIS
    Positions multiple components using a layout pattern
    
    .PARAMETER Components
    Array of component hashtables to position
    
    .PARAMETER Pattern
    Layout pattern: 'Row', 'Column', 'Grid', 'Flow'
    
    .PARAMETER Container
    Container bounds
    
    .PARAMETER Options
    Layout options (spacing, columns for grid, etc.)
    #>
    param(
        [hashtable[]]$Components,
        [string]$Pattern = 'Row',
        [hashtable]$Container = @{ X = 0; Y = 0; Width = 80; Height = 25 },
        [hashtable]$Options = @{}
    )
    
    $spacing = $Options.Spacing ?? 1
    $padding = $Options.Padding ?? @{ Top = 0; Right = 0; Bottom = 0; Left = 0 }
    
    switch ($Pattern) {
        'Row' {
            $x = $Container.X + $padding.Left
            $y = $Container.Y + $padding.Top
            
            foreach ($comp in $Components) {
                $comp.X = $x
                $comp.Y = $y
                $x += $comp.Width + $spacing
            }
        }
        
        'Column' {
            $x = $Container.X + $padding.Left
            $y = $Container.Y + $padding.Top
            
            foreach ($comp in $Components) {
                $comp.X = $x
                $comp.Y = $y
                $y += $comp.Height + $spacing
            }
        }
        
        'Grid' {
            $columns = $Options.Columns ?? 2
            $x = $Container.X + $padding.Left
            $y = $Container.Y + $padding.Top
            $col = 0
            $rowHeight = 0
            
            foreach ($comp in $Components) {
                if ($col -ge $columns) {
                    $col = 0
                    $x = $Container.X + $padding.Left
                    $y += $rowHeight + $spacing
                    $rowHeight = 0
                }
                
                $comp.X = $x
                $comp.Y = $y
                $x += $comp.Width + $spacing
                $rowHeight = [Math]::Max($rowHeight, $comp.Height)
                $col++
            }
        }
        
        'Flow' {
            $x = $Container.X + $padding.Left
            $y = $Container.Y + $padding.Top
            $maxX = $Container.X + $Container.Width - $padding.Right
            $rowHeight = 0
            
            foreach ($comp in $Components) {
                # Check if component fits in current row
                if (($x + $comp.Width) -gt $maxX -and $x -ne ($Container.X + $padding.Left)) {
                    # Move to next row
                    $x = $Container.X + $padding.Left
                    $y += $rowHeight + $spacing
                    $rowHeight = 0
                }
                
                $comp.X = $x
                $comp.Y = $y
                $x += $comp.Width + $spacing
                $rowHeight = [Math]::Max($rowHeight, $comp.Height)
            }
        }
    }
}

function global:Get-RelativePosition {
    <#
    .SYNOPSIS
    Calculate position relative to another component
    #>
    param(
        [hashtable]$Reference,
        [string]$Direction = "Right",
        [int]$Offset = 1
    )
    
    switch ($Direction) {
        "Right" { return @{ X = $Reference.X + $Reference.Width + $Offset; Y = $Reference.Y } }
        "Left" { return @{ X = $Reference.X - $Offset; Y = $Reference.Y } }
        "Above" { return @{ X = $Reference.X; Y = $Reference.Y - $Offset } }
        "Below" { return @{ X = $Reference.X; Y = $Reference.Y + $Reference.Height + $Offset } }
        "TopRight" { return @{ X = $Reference.X + $Reference.Width + $Offset; Y = $Reference.Y } }
        "TopLeft" { return @{ X = $Reference.X - $Offset; Y = $Reference.Y } }
        "BottomRight" { return @{ X = $Reference.X + $Reference.Width + $Offset; Y = $Reference.Y + $Reference.Height } }
        "BottomLeft" { return @{ X = $Reference.X - $Offset; Y = $Reference.Y + $Reference.Height } }
    }
}

Export-ModuleMember -Function @(
    'New-TuiPositioner',
    'Position-Components',
    'Get-RelativePosition'
)
# Test file for app-store service
# Run with: Invoke-Pester -Path .\tests\app-store.tests.ps1

BeforeAll {
    # Set up test environment
    $script:BasePath = Split-Path -Parent (Split-Path -Parent $PSCommandPath)
    
    # Import required modules
    Import-Module "$script:BasePath\modules\event-system.psm1" -Force
    Import-Module "$script:BasePath\modules\tui-framework.psm1" -Force
    Import-Module "$script:BasePath\services\app-store.psm1" -Force
    
    # Initialize dependencies
    Initialize-EventSystem
    Initialize-TuiFramework
}

Describe "AppStore Service" {
    Context "Initialization" {
        It "should initialize with empty state" {
            # Arrange & Act
            $store = Initialize-AppStore
            
            # Assert
            $store | Should -Not -BeNullOrEmpty
            $store.GetState() | Should -BeOfType [hashtable]
        }
        
        It "should initialize with provided initial data" {
            # Arrange
            $initialData = @{
                counter = 0
                user = @{ name = "Test User" }
            }
            
            # Act
            $store = Initialize-AppStore -InitialData $initialData
            
            # Assert
            $store.GetState("counter") | Should -Be 0
            $store.GetState("user.name") | Should -Be "Test User"
        }
    }
    
    Context "State Management" {
        It "should update state via registered action" {
            # Arrange
            $store = Initialize-AppStore -InitialData @{ counter = 0 }
            
            $store.RegisterAction("INCREMENT", {
                param($Context)
                $current = $Context.GetState("counter")
                $Context.UpdateState(@{ counter = $current + 1 })
            })
            
            # Act
            $result = $store.Dispatch("INCREMENT")
            
            # Assert
            $result.Success | Should -Be $true
            $store.GetState("counter") | Should -Be 1
        }
        
        It "should handle action with payload" {
            # Arrange
            $store = Initialize-AppStore -InitialData @{ counter = 0 }
            
            $store.RegisterAction("ADD", {
                param($Context, $Payload)
                $current = $Context.GetState("counter")
                $Context.UpdateState(@{ counter = $current + $Payload.Amount })
            })
            
            # Act
            $result = $store.Dispatch("ADD", @{ Amount = 5 })
            
            # Assert
            $result.Success | Should -Be $true
            $store.GetState("counter") | Should -Be 5
        }
        
        It "should return error for unregistered action" {
            # Arrange
            $store = Initialize-AppStore
            
            # Act
            $result = $store.Dispatch("UNKNOWN_ACTION")
            
            # Assert
            $result.Success | Should -Be $false
            $result.Error | Should -BeLike "*not registered*"
        }
    }
    
    Context "Subscriptions" {
        It "should notify subscribers on state change" {
            # Arrange
            $store = Initialize-AppStore -InitialData @{ value = "initial" }
            $notificationReceived = $false
            $newValue = $null
            
            $subId = $store.Subscribe("value", {
                param($data)
                $script:notificationReceived = $true
                $script:newValue = $data.NewValue
            })
            
            $store.RegisterAction("UPDATE_VALUE", {
                param($Context)
                $Context.UpdateState(@{ value = "updated" })
            })
            
            # Act
            $store.Dispatch("UPDATE_VALUE")
            
            # Assert
            $notificationReceived | Should -Be $true
            $newValue | Should -Be "updated"
            
            # Cleanup
            $store.Unsubscribe($subId)
        }
        
        It "should support nested path subscriptions" {
            # Arrange
            $store = Initialize-AppStore -InitialData @{
                user = @{ profile = @{ name = "Test" } }
            }
            
            $notified = $false
            $subId = $store.Subscribe("user.profile.name", {
                param($data)
                $script:notified = $true
            })
            
            $store.RegisterAction("UPDATE_NAME", {
                param($Context)
                $Context.UpdateState(@{ 
                    user = @{ profile = @{ name = "Updated" } }
                })
            })
            
            # Act
            $store.Dispatch("UPDATE_NAME")
            
            # Assert
            $notified | Should -Be $true
            
            # Cleanup
            $store.Unsubscribe($subId)
        }
    }
    
    Context "Middleware" {
        It "should execute middleware before actions" {
            # Arrange
            $store = Initialize-AppStore
            $middlewareExecuted = $false
            
            $store.AddMiddleware({
                param($Action, $Store)
                $script:middlewareExecuted = $true
                return $Action  # Pass through
            })
            
            $store.RegisterAction("TEST", { })
            
            # Act
            $store.Dispatch("TEST")
            
            # Assert
            $middlewareExecuted | Should -Be $true
        }
        
        It "should allow middleware to cancel actions" {
            # Arrange
            $store = Initialize-AppStore
            
            $store.AddMiddleware({
                param($Action, $Store)
                if ($Action.Type -eq "FORBIDDEN") {
                    return $null  # Cancel action
                }
                return $Action
            })
            
            $actionExecuted = $false
            $store.RegisterAction("FORBIDDEN", {
                $script:actionExecuted = $true
            })
            
            # Act
            $result = $store.Dispatch("FORBIDDEN")
            
            # Assert
            $result.Success | Should -Be $false
            $result.Error | Should -BeLike "*cancelled*"
            $actionExecuted | Should -Be $false
        }
    }
    
    Context "Time Travel (Debug Features)" {
        It "should maintain action history" {
            # Arrange
            $store = Initialize-AppStore -InitialData @{ value = 0 }
            
            $store.RegisterAction("SET_VALUE", {
                param($Context, $Payload)
                $Context.UpdateState(@{ value = $Payload })
            })
            
            # Act
            $store.Dispatch("SET_VALUE", 1)
            $store.Dispatch("SET_VALUE", 2)
            $store.Dispatch("SET_VALUE", 3)
            
            $history = $store.GetHistory()
            
            # Assert
            $history.Count | Should -Be 3
            $history[0].Action.Payload | Should -Be 1
            $history[1].Action.Payload | Should -Be 2
            $history[2].Action.Payload | Should -Be 3
        }
        
        It "should restore previous state" {
            # Arrange
            $store = Initialize-AppStore -InitialData @{ value = 0 }
            
            $store.RegisterAction("SET_VALUE", {
                param($Context, $Payload)
                $Context.UpdateState(@{ value = $Payload })
            })
            
            # Act
            $store.Dispatch("SET_VALUE", 1)
            $store.Dispatch("SET_VALUE", 2)
            $store.Dispatch("SET_VALUE", 3)
            
            $store.RestoreState(2)  # Go back 2 steps
            
            # Assert
            $store.GetState("value") | Should -Be 1
        }
    }
}

Describe "AppStore Integration" {
    Context "With Navigation Service" {
        It "should update navigation state" -Skip {
            # This would test integration with navigation service
            # Skipped as it requires full service setup
        }
    }
    
    Context "With UI Components" {
        It "should trigger component updates on state change" -Skip {
            # This would test integration with UI components
            # Skipped as it requires full UI setup
        }
    }
}

AfterAll {
    # Cleanup
    Remove-Module app-store -Force -ErrorAction SilentlyContinue
    Remove-Module tui-framework -Force -ErrorAction SilentlyContinue
    Remove-Module event-system -Force -ErrorAction SilentlyContinue
}
